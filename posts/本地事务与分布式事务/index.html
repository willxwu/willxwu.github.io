<!doctype html><html lang=en><head><title>// 一路向北</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.113.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="MegaAI"><meta name=description content><link rel=stylesheet href=https://willxwu.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="本地事务 一、事务的基本性质 数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation) 和持久性(Durabilily)，简称就是ACID；
原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败 一致性：数据在事务的前后，业务整体一致。(A向B转账，转账前后AB总金额一致) 隔离性：事务之间互相隔离。 持久性：一旦事务成功，数据一定会落盘在数据库。 单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易的整体回滚；
Business：我们具体的业务代码 Storage：库存业务代码；扣库存 Order：订单业务代码；保存订单 Account：账号业务代码；减账户余额 比如买东西业务，扣库存，下订单，账户扣款，是一个整体；必须同时成功或者失败 一个事务开始，代表以下的所有操作都在同一个连接里面；
二、事务的隔离级别 READ UNCOMMITTED（读未提交）
该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。
READ COMMITTED（读提交）
一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重 复读问题，Oracle 和SQL Server 的默认隔离级别。
REPEATABLE READ（可重复读）
该隔离级别是MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间 点的状态，因此，同样的select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的InnoDB 引擎可以通过next-key locks 机制（行锁的算法）来避免幻读。
SERIALIZABLE（序列化）
在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的InnoDB 引擎会给读操作隐式 加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。
三、事务的传播行为 PROPAGATION_REQUIRED
如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
PROPAGATION_SUPPORTS
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
PROPAGATION_MANDATORY
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
PROPAGATION_REQUIRES_NEW
创建新事务，无论当前存不存在事务，都创建新事务。
PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。
四、SpringBoot 事务关键点 事务的自动配置
TransactionAutoConfiguration
事务的坑
在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到 代理对象的缘故。
解决"><meta property="og:title" content><meta property="og:description" content="本地事务 一、事务的基本性质 数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation) 和持久性(Durabilily)，简称就是ACID；
原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败 一致性：数据在事务的前后，业务整体一致。(A向B转账，转账前后AB总金额一致) 隔离性：事务之间互相隔离。 持久性：一旦事务成功，数据一定会落盘在数据库。 单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易的整体回滚；
Business：我们具体的业务代码 Storage：库存业务代码；扣库存 Order：订单业务代码；保存订单 Account：账号业务代码；减账户余额 比如买东西业务，扣库存，下订单，账户扣款，是一个整体；必须同时成功或者失败 一个事务开始，代表以下的所有操作都在同一个连接里面；
二、事务的隔离级别 READ UNCOMMITTED（读未提交）
该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。
READ COMMITTED（读提交）
一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重 复读问题，Oracle 和SQL Server 的默认隔离级别。
REPEATABLE READ（可重复读）
该隔离级别是MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间 点的状态，因此，同样的select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的InnoDB 引擎可以通过next-key locks 机制（行锁的算法）来避免幻读。
SERIALIZABLE（序列化）
在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的InnoDB 引擎会给读操作隐式 加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。
三、事务的传播行为 PROPAGATION_REQUIRED
如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
PROPAGATION_SUPPORTS
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
PROPAGATION_MANDATORY
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
PROPAGATION_REQUIRES_NEW
创建新事务，无论当前存不存在事务，都创建新事务。
PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。
四、SpringBoot 事务关键点 事务的自动配置
TransactionAutoConfiguration
事务的坑
在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到 代理对象的缘故。
解决"><meta property="og:type" content="article"><meta property="og:url" content="https://willxwu.github.io/posts/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><meta property="article:section" content="posts"></head><body><header class=app-header><a href=https://willxwu.github.io/><img class=app-header-avatar src=/avatar.jpg alt=MegaAI></a><h1>一路向北</h1><p>生活哪有那么复杂，简单甚好。@万般滋味，皆是生活。</p><div class=app-header-social><a target=_blank href=https://github.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://twitter.com/i2school rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a target=_blank href=https://twitter.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-umbrella"><title>umbrella</title><path d="M23 12A11.05 11.05.0 001 12zm-5 7a3 3 0 01-6 0v-7"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 1, 0001</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div></div></header><div class=post-content><h1 id=本地事务>本地事务</h1><h2 id=一事务的基本性质>一、事务的基本性质</h2><p>数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)
和持久性(Durabilily)，简称就是ACID；</p><ol><li>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败</li><li>一致性：数据在事务的前后，业务整体一致。(A向B转账，转账前后AB总金额一致)</li><li>隔离性：事务之间互相隔离。</li><li>持久性：一旦事务成功，数据一定会落盘在数据库。</li></ol><p>单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易的整体回滚；</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012319227.jpg alt></p><p>Business：我们具体的业务代码
Storage：库存业务代码；扣库存
Order：订单业务代码；保存订单
Account：账号业务代码；减账户余额
比如买东西业务，扣库存，下订单，账户扣款，是一个整体；必须同时成功或者失败
一个事务开始，代表以下的所有操作都在同一个连接里面；</p><h2 id=二事务的隔离级别>二、事务的隔离级别</h2><ol><li><p><strong>READ UNCOMMITTED（读未提交）</strong></p><p>该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p></li><li><p><strong>READ COMMITTED（读提交）</strong></p><p>一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重
复读问题，Oracle 和SQL Server 的默认隔离级别。</p></li><li><p><strong>REPEATABLE READ（可重复读）</strong></p><p>该隔离级别是MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间
点的状态，因此，同样的select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL
的InnoDB 引擎可以通过next-key locks 机制（行锁的算法）来避免幻读。</p></li><li><p><strong>SERIALIZABLE（序列化）</strong></p><p>在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的InnoDB 引擎会给读操作隐式
加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p></li></ol><h2 id=三事务的传播行为>三、事务的传播行为</h2><ol><li><p><strong>PROPAGATION_REQUIRED</strong></p><p>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p></li><li><p><strong>PROPAGATION_SUPPORTS</strong></p><p>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p><strong>PROPAGATION_MANDATORY</strong></p><p>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p></li><li><p><strong>PROPAGATION_REQUIRES_NEW</strong></p><p>创建新事务，无论当前存不存在事务，都创建新事务。</p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED</strong></p><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p><strong>PROPAGATION_NEVER</strong></p><p>以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p><strong>PROPAGATION_NESTED</strong></p><p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。</p></li></ol><h2 id=四springboot-事务关键点>四、SpringBoot 事务关键点</h2><ol><li><p>事务的自动配置</p><p>TransactionAutoConfiguration</p></li><li><p>事务的坑</p><p>在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到
代理对象的缘故。</p></li><li><p>解决</p><p>0）、导入spring-boot-starter-aop
1）、@EnableTransactionManagement(proxyTargetClass = true)
2）、@EnableAspectJAutoProxy(exposeProxy=true)
3）、AopContext.currentProxy() 调用方法</p></li></ol><hr><h1 id=分布式事务>分布式事务</h1><h2 id=一为什么有分布式事务>一、为什么有分布式事务</h2><p>分布式系统经常出现的异常
机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失&mldr;</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012328808.jpg alt></p><h2 id=二cap-定理与base-理论>二、CAP 定理与BASE 理论</h2><h3 id=1cap-定理><strong>1、CAP 定理</strong></h3><p>CAP 原则又称CAP 定理，指的是在一个分布式系统中</p><ol><li><p><strong>一致性（Consistency）</strong></p><p>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p></li><li><p><strong>可用性（Availability）</strong></p><p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p></li><li><p><strong>分区容错性（Partition tolerance）</strong></p><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p></li></ol><p>CAP 原则指的是，这三个要素最多只能同时实现两点，<strong>不可能三者兼顾</strong>。</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012332100.jpg alt></p><p>一般来说，分区容错无法避免，因此可以认为CAP 的P 总是成立。CAP 定理告诉我们，剩下的C 和A 无法同时做到。</p><p>分布式系统中实现一致性的raft 算法、paxos <a href=http://thesecretlivesofdata.com/raft/>http://thesecretlivesofdata.com/raft/</a></p><p><strong>面临的问题</strong></p><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到99.99999%（N 个9），即保证P 和A，舍弃C。</p><h3 id=2base-理论>2、BASE 理论</h3><p>是对CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即最终一致性。</p><h4 id=什么是base->什么是BASE ：</h4><ol><li><p><strong>基本可用（Basically Available）</strong></p><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</p><ul><li>响应时间上的损失：正常情况下搜索引擎需要在0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2 秒。</li><li>功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><p><strong>软状态（ Soft State）</strong></p><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</p></li><li><p><strong>最终一致性（ Eventual Consistency）</strong></p><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li></ol><h4 id=强一致性弱一致性最终一致性>强一致性、弱一致性、最终一致性</h4><p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求
能访问到更新后的数据，则是最终一致性。</p><h3 id=3分布式事务几种方案>3、分布式事务几种方案</h3><h4 id=2pc-模式><strong>2PC 模式</strong></h4><p>数据库支持的2PC【2 phase commit 二阶提交】，又叫做XA Transactions。MySQL 从5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><p><strong>第一阶段</strong>：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。
<strong>第二阶段</strong>：事务协调器要求每个数据库提交数据。其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012338929.jpg alt></p><ul><li>XA 协议比较简单，而且一旦商业数据库实现了XA 协议，使用分布式事务的成本也比较低。</li><li>XA 性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景</li><li>XA 目前在商业数据库支持的比较理想，在mysql 数据库中支持的不太理想，mysql 的XA 实现，没有记录prepare 阶段日志，主备切换回导致主库与备库数据不一致。</li><li>许多nosql 也没有支持XA，这让XA 的应用场景变得非常狭隘。</li><li>也有3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）。</li></ul><h4 id=柔性事务-tcc-事务补偿型方案>柔性事务-TCC 事务补偿型方案</h4><p><strong>刚性事务</strong>：遵循ACID 原则，强一致性。
<strong>柔性事务</strong>：遵循BASE 理论，最终一致性；
<strong>与刚性事务不同</strong>，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012340620.jpg alt></p><p>一阶段prepare 行为：调用自定义的prepare 逻辑。
二阶段commit 行为：调用自定义的commit 逻辑。
二阶段rollback 行为：调用自定义的rollback 逻辑。</p><p>所谓TCC 模式，是指支持把自定义的分支事务纳入到全局事务的管理中。</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204012341572.jpg alt></p><h4 id=柔性事务-最大努力通知型方案>柔性事务-最大努力通知型方案</h4><p>按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ 进行实现，例如：通过MQ 发送http 请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调。</p><h4 id=柔性事务-可靠消息最终一致性方案异步确保型>柔性事务-可靠消息+最终一致性方案（异步确保型）</h4><p>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><p>防止消息丢失：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>* 1、做好消息确认机制（pulisher，consumer【手动ack】）
</span></span></span><span style=display:flex><span><span style=color:#75715e>* 2、每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一
</span></span></span><span style=display:flex><span><span style=color:#75715e>遍
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>mq_message<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>message_id<span style=color:#f92672>`</span> char(<span style=color:#ae81ff>32</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>content<span style=color:#f92672>`</span> text,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>to_exchane<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>routing_key<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>class_type<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>message_status<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;0-新建1-已发送2-错误抵达3-已抵达&#39;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>create_time<span style=color:#f92672>`</span> datetime <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>`</span>update_time<span style=color:#f92672>`</span> datetime <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span><span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>message_id<span style=color:#f92672>`</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8mb4
</span></span></code></pre></div></div><div class=post-footer></div></article></main></body></html>