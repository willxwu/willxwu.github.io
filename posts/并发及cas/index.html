<!doctype html><html lang=en><head><title>// 归去来兮</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="willxwu"><meta name=description content><link rel=stylesheet href=https://willxwu.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="计算机架构 CPU多级缓存 为什么需要CPU cache CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu->cache->memory）。
CPU cache有什么意义 1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问 2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问；
CPU 多级缓存一致性（MESI） CPU缓存4种状态 M：被修改状态，指该缓存行只被缓存在该CPU的缓存中，并且是被修改过的。因此与主存中的数据是不一致的，该缓存行中的内存需要再未来的某个时间点写会主存。这个时间点是允许其它CPU读取主存中相应的内存之前，当这里面的值被写会主存之后该缓存行的状态会变成E独享状态。
E：独享状态，指缓存行只被缓存在该CPU的缓存中，它是未被修改过的，是和主存的数据一致的，这个状态可以在任何时刻，当有其它CPU读取该内存时变成S共享状态。当CPU修改该缓存行内容时，状态变成M状态。
S：共享状态，意味该缓存行可能被多个CPU缓存，并且各CPU缓存中的数据与主存中的数据一致，当有一个CPU修改该缓存行时，其它CPU中该缓存行，是可以被作废的，变成I无效状态。
I：无效状态，代表缓存无效，可能有其它CPU修改了该缓存行。
引起CPU缓存状态变化的4种操作 local read：读本地缓存中的数据
local write：将数据写到本地的缓存里面
remote read：将主内中的数据读取到本地缓存中
remote write：将本地缓存中数据写到主存里面
MESI协议：CPU缓存数据有4种状态，引起CPU缓存转变的操作也有4种，因此本质就是要理解这16种操作状态的关系，可以通过下图表示：
重点理解 1、CPU缓存是为了减少CPU读写共享主存的次数。
2、除了I状态，其它三种状态都是可以被读取的。
3、只有再M和E状态才能写。
4、当为S状态时，必须将该缓存行变为无效状态，一般通过广播方式完成，此时不允许不同的CPU同时修改该缓存行，即使修改该缓存行不同位置的数据也是不允许的，这里主要解决缓存一致性的问题。
5、只有M和E状态可以写，如果是S状态需要变为I状态。
6、一个处于M装的缓存行，需要时刻监听所有试图读该缓存行，相对有主存的操作，这种操作必须将缓存行写会到主存，并将状态变为S状态之前，被延迟执行。
7、S状态的缓存行，监听所有试图将该缓存行无效或独享该缓存行的请求，并将缓存行变为无效。
8、处于E状态的缓存行，需要监听其它读该缓存行的操作，一旦有该缓存行的操作，那么该缓存行需要变为S状态。因此对于M和E状态的数据总是精确的，和缓存行的状态是真正一致的。S状态可能是非一致的。如果一个缓存将处于S状态的数据作废了，另一个缓存实际上可能已经独享了该缓存行，但是该缓存不会把缓存行升迁为E状态，因为其它不会广播该作废的通知，同样由于缓存没有缓存该COPY的数量，因此也无法确定自己是否独享了该缓存行。E状态更像一种投机的优化，因为当一个CPU想修改一个处于S共享状态的缓存行，总线事务需要将所有copy该缓存行缓存的值变成I状态才行。修改E状态的CPU缓存不需要总线事务。
JAVA内存模型抽象结构图 JAVA内存模型8个操作 8种同步操作 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中 同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） compareAndSetInt 举例一 package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java."><meta property="og:title" content><meta property="og:description" content="计算机架构 CPU多级缓存 为什么需要CPU cache CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu->cache->memory）。
CPU cache有什么意义 1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问 2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问；
CPU 多级缓存一致性（MESI） CPU缓存4种状态 M：被修改状态，指该缓存行只被缓存在该CPU的缓存中，并且是被修改过的。因此与主存中的数据是不一致的，该缓存行中的内存需要再未来的某个时间点写会主存。这个时间点是允许其它CPU读取主存中相应的内存之前，当这里面的值被写会主存之后该缓存行的状态会变成E独享状态。
E：独享状态，指缓存行只被缓存在该CPU的缓存中，它是未被修改过的，是和主存的数据一致的，这个状态可以在任何时刻，当有其它CPU读取该内存时变成S共享状态。当CPU修改该缓存行内容时，状态变成M状态。
S：共享状态，意味该缓存行可能被多个CPU缓存，并且各CPU缓存中的数据与主存中的数据一致，当有一个CPU修改该缓存行时，其它CPU中该缓存行，是可以被作废的，变成I无效状态。
I：无效状态，代表缓存无效，可能有其它CPU修改了该缓存行。
引起CPU缓存状态变化的4种操作 local read：读本地缓存中的数据
local write：将数据写到本地的缓存里面
remote read：将主内中的数据读取到本地缓存中
remote write：将本地缓存中数据写到主存里面
MESI协议：CPU缓存数据有4种状态，引起CPU缓存转变的操作也有4种，因此本质就是要理解这16种操作状态的关系，可以通过下图表示：
重点理解 1、CPU缓存是为了减少CPU读写共享主存的次数。
2、除了I状态，其它三种状态都是可以被读取的。
3、只有再M和E状态才能写。
4、当为S状态时，必须将该缓存行变为无效状态，一般通过广播方式完成，此时不允许不同的CPU同时修改该缓存行，即使修改该缓存行不同位置的数据也是不允许的，这里主要解决缓存一致性的问题。
5、只有M和E状态可以写，如果是S状态需要变为I状态。
6、一个处于M装的缓存行，需要时刻监听所有试图读该缓存行，相对有主存的操作，这种操作必须将缓存行写会到主存，并将状态变为S状态之前，被延迟执行。
7、S状态的缓存行，监听所有试图将该缓存行无效或独享该缓存行的请求，并将缓存行变为无效。
8、处于E状态的缓存行，需要监听其它读该缓存行的操作，一旦有该缓存行的操作，那么该缓存行需要变为S状态。因此对于M和E状态的数据总是精确的，和缓存行的状态是真正一致的。S状态可能是非一致的。如果一个缓存将处于S状态的数据作废了，另一个缓存实际上可能已经独享了该缓存行，但是该缓存不会把缓存行升迁为E状态，因为其它不会广播该作废的通知，同样由于缓存没有缓存该COPY的数量，因此也无法确定自己是否独享了该缓存行。E状态更像一种投机的优化，因为当一个CPU想修改一个处于S共享状态的缓存行，总线事务需要将所有copy该缓存行缓存的值变成I状态才行。修改E状态的CPU缓存不需要总线事务。
JAVA内存模型抽象结构图 JAVA内存模型8个操作 8种同步操作 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中 同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） compareAndSetInt 举例一 package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java."><meta property="og:type" content="article"><meta property="og:url" content="https://willxwu.github.io/posts/%E5%B9%B6%E5%8F%91%E5%8F%8Acas/"><meta property="article:section" content="posts"></head><body><header class=app-header><a href=https://willxwu.github.io/><img class=app-header-avatar src=/avatar.jpg alt=willxwu></a><h1>归去来兮</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>首页</a>
-
<a class=app-header-menu-item href=/archives/>归档</a>
-
<a class=app-header-menu-item href=/tags/>标签</a>
-
<a class=app-header-menu-item href=/links/>友链</a></nav><p>生活哪有那么复杂，简单甚好。@万般滋味，皆是生活。</p><div class=app-header-social><a target=_blank href=https://github.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://yanxizhu.com rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 1, 0001</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div></div></header><div class=post-content><h1 id=计算机架构>计算机架构</h1><h2 id=cpu多级缓存><strong>CPU多级缓存</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204192221622.png alt></p><h2 id=为什么需要cpu-cache><strong>为什么需要CPU cache</strong></h2><p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu->cache->memory）。</p><h2 id=cpu-cache有什么意义><strong>CPU cache有什么意义</strong></h2><p>1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问
2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问；</p><h2 id=cpu-多级缓存一致性mesi><strong>CPU 多级缓存一致性（MESI）</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204192224075.png alt></p><h3 id=cpu缓存4种状态><strong>CPU缓存4种状态</strong></h3><p><strong>M：被修改状态</strong>，指该缓存行只被缓存在该CPU的缓存中，并且是被修改过的。因此与主存中的数据是不一致的，该缓存行中的内存需要再未来的某个时间点写会主存。这个时间点是允许其它CPU读取主存中相应的内存之前，当这里面的值被写会主存之后该缓存行的状态会变成E独享状态。</p><p><strong>E：独享状态</strong>，指缓存行只被缓存在该CPU的缓存中，它是未被修改过的，是和主存的数据一致的，这个状态可以在任何时刻，当有其它CPU读取该内存时变成S共享状态。当CPU修改该缓存行内容时，状态变成M状态。</p><p><strong>S：共享状态</strong>，意味该缓存行可能被多个CPU缓存，并且各CPU缓存中的数据与主存中的数据一致，当有一个CPU修改该缓存行时，其它CPU中该缓存行，是可以被作废的，变成I无效状态。</p><p><strong>I：无效状态</strong>，代表缓存无效，可能有其它CPU修改了该缓存行。</p><h3 id=引起cpu缓存状态变化的4种操作><strong>引起CPU缓存状态变化的4种操作</strong></h3><p><strong>local read</strong>：读本地缓存中的数据</p><p><strong>local write</strong>：将数据写到本地的缓存里面</p><p><strong>remote read</strong>：将主内中的数据读取到本地缓存中</p><p><strong>remote write</strong>：将本地缓存中数据写到主存里面</p><p>MESI协议：CPU缓存数据有4种状态，引起CPU缓存转变的操作也有4种，因此本质就是要理解这16种操作状态的关系，可以通过下图表示：</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204192248453.png alt></p><h2 id=重点理解><strong>重点理解</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204192322821.png alt></p><p>1、CPU缓存是为了减少CPU读写共享主存的次数。</p><p>2、除了I状态，其它三种状态都是可以被读取的。</p><p>3、只有再M和E状态才能写。</p><p>4、当为S状态时，必须将该缓存行变为无效状态，一般通过广播方式完成，此时不允许不同的CPU同时修改该缓存行，即使修改该缓存行不同位置的数据也是不允许的，这里主要<strong>解决缓存一致性的问题</strong>。</p><p>5、只有M和E状态可以写，如果是S状态需要变为I状态。</p><p>6、一个处于M装的缓存行，需要时刻监听所有试图读该缓存行，相对有主存的操作，这种操作必须将缓存行写会到主存，并将状态变为S状态之前，被延迟执行。</p><p>7、S状态的缓存行，监听所有试图将该缓存行无效或独享该缓存行的请求，并将缓存行变为无效。</p><p>8、处于E状态的缓存行，需要监听其它读该缓存行的操作，一旦有该缓存行的操作，那么该缓存行需要变为S状态。因此对于M和E状态的数据总是精确的，和缓存行的状态是真正一致的。S状态可能是非一致的。如果一个缓存将处于S状态的数据作废了，另一个缓存实际上可能已经独享了该缓存行，但是该缓存不会把缓存行升迁为E状态，因为其它不会广播该作废的通知，同样由于缓存没有缓存该COPY的数量，因此也无法确定自己是否独享了该缓存行。E状态更像一种投机的优化，因为当一个CPU想修改一个处于S共享状态的缓存行，总线事务需要将所有copy该缓存行缓存的值变成I状态才行。修改E状态的CPU缓存不需要总线事务。</p><hr><h1 id=java内存模型抽象结构图><strong>JAVA内存模型抽象结构图</strong></h1><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204202019042.png alt></p><h2 id=java内存模型8个操作><strong>JAVA内存模型8个操作</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204202035910.png alt></p><h2 id=8种同步操作><strong>8种同步操作</strong></h2><ol><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中</li></ol><h2 id=同步规则><strong>同步规则</strong></h2><ol><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li></ol><hr><h1 id=compareandsetint>compareAndSetInt</h1><h2 id=举例一><strong>举例一</strong></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.yanxizhu.demo.concurrency.atomic<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.yanxizhu.demo.concurrency.annotation.ThreadSafety<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> lombok.extern.slf4j.Slf4j<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.CountDownLatch<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.ExecutorService<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.Executors<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.Semaphore<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.atomic.AtomicInteger<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @description: 线程安全
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author: &lt;a href=&#34;mailto:batis@foxmail.com&#34;&gt;清风&lt;/a&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @date: 2022/4/19 20:05
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @version: 1.0
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ThreadSafety</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoSemaphoreAndCountDownLatchAndAtomic</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//用户数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> clientsTotal <span style=color:#f92672>=</span> 5000<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//并发数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> concurrencyTotal <span style=color:#f92672>=</span> 200<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//累加总和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> AtomicInteger count <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger<span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors<span style=color:#f92672>.</span><span style=color:#a6e22e>newCachedThreadPool</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> Semaphore semaphore <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore<span style=color:#f92672>(</span>concurrencyTotal<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//闭锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> CountDownLatch countDownLatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span>clientsTotal<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> clientsTotal<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            executorService<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(()-&gt;{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    semaphore<span style=color:#f92672>.</span><span style=color:#a6e22e>acquire</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    add<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    semaphore<span style=color:#f92672>.</span><span style=color:#a6e22e>release</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    log<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;出现错误:【{}】&#34;</span><span style=color:#f92672>,</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        countDownLatch<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        executorService<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdown</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;累加结果为count=【{}】&#34;</span><span style=color:#f92672>,</span>count<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 累加
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//说明:incrementAndGet、getAndIncrement类似,i++与++i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        count<span style=color:#f92672>.</span><span style=color:#a6e22e>incrementAndGet</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        count<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndIncrement</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><hr><h2 id=源码解析><strong>源码解析</strong></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>count<span style=color:#f92672>.</span><span style=color:#a6e22e>incrementAndGet</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>incrementAndGet</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> U<span style=color:#f92672>.</span><span style=color:#a6e22e>getAndAddInt</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> VALUE<span style=color:#f92672>,</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@HotSpotIntrinsicCandidate</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAndAddInt</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> offset<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> delta<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> getIntVolatile<span style=color:#f92672>(</span>o<span style=color:#f92672>,</span> offset<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>weakCompareAndSetInt<span style=color:#f92672>(</span>o<span style=color:#f92672>,</span> offset<span style=color:#f92672>,</span> v<span style=color:#f92672>,</span> v <span style=color:#f92672>+</span> delta<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><strong>weakCompareAndSetInt(o, offset, v, v + delta)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@HotSpotIntrinsicCandidate</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>weakCompareAndSetInt</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> offset<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                          <span style=color:#66d9ef>int</span> expected<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                          <span style=color:#66d9ef>int</span> x<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> compareAndSetInt<span style=color:#f92672>(</span>o<span style=color:#f92672>,</span> offset<span style=color:#f92672>,</span> expected<span style=color:#f92672>,</span> x<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><strong>compareAndSetInt(o, offset, expected, x)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@HotSpotIntrinsicCandidate</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>native</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>compareAndSetInt</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> offset<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                             <span style=color:#66d9ef>int</span> expected<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                             <span style=color:#66d9ef>int</span> x<span style=color:#f92672>);</span>
</span></span></code></pre></div><p><strong>native</strong></p><p>native标识，说明是Java底层操作方法。</p><h2 id=重点说明><strong>重点说明</strong></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@HotSpotIntrinsicCandidate</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>* o:      当前对象,上面的count
</span></span></span><span style=display:flex><span><span style=color:#75715e>* offset: 当前值  （例如2+1），offset=2
</span></span></span><span style=display:flex><span><span style=color:#75715e>* delta:         （例如2+1），delta=1
</span></span></span><span style=display:flex><span><span style=color:#75715e>**/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAndAddInt</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> offset<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> delta<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//v:底层获取的值,如果没有其它线程修改，理论应该是2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        v <span style=color:#f92672>=</span> getIntVolatile<span style=color:#f92672>(</span>o<span style=color:#f92672>,</span> offset<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//重点：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//   1)、当没有其它线程修改底层值时：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       o这个对象，当前值offset=2与底层值v=2相等，则把底层值更新为(底层值v=2 + 增加值delta=1 = 最后就等于3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//   2)、如果此有其它线程修改了底层值v(例如修改为v=4):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       此时低层值v=4与当前值offset=2不相等，则重新从count对象取出当前值offset=4,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       再判断当前值offset=4与底层值v=4相等，然后再讲底层值修改为(低层值v=4 + 增加值delta= 最后就登陆5),
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//       如果一直有其它线程修改底层值v，导致当前值offset与底层值v一直不相等，则一直循环上面的操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>weakCompareAndSetInt<span style=color:#f92672>(</span>o<span style=color:#f92672>,</span> offset<span style=color:#f92672>,</span> v<span style=color:#f92672>,</span> v <span style=color:#f92672>+</span> delta<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>CAS就是compareAndSet的缩写。底层值其实就是计算机的主内存，当前值就是JMM模型中工作内存值。</p><h2 id=特别说明><strong>特别说明</strong></h2><p>JDK1.8后新增了LongAdder。</p><p><strong>AtomicLong</strong>：是基于 CAS 方式自旋更新的；</p><p><strong>LongAdder</strong>： 是把 value 分成若干cell，并发量低的时候，直接 CAS 更新值，成功即结束。并发量高的情况，CAS更新某个cell值和需要时对cell数据扩容，成功结束；更新失败自旋 CAS 更新 cell值。取值的时候，调用 sum() 方法进行每个cell累加。</p><p><strong>AtomicLong</strong>： 包含有原子性的读、写结合的api；</p><p><strong>LongAdder</strong> ：没有原子性的读、写结合的api，能保证结果最终一致性。</p><p><strong>低并发</strong>：低并发场景AtomicLong 和 LongAdder 性能相似。</p><p><strong>高并发</strong>：高并发场景 LongAdder 性能优于 AtomicLong。</p></div><div class=post-footer></div></article></main></body></html>