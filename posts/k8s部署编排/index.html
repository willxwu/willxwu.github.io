<!doctype html><html lang=en><head><title>// 归去来兮</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="willxwu"><meta name=description content><link rel=stylesheet href=https://willxwu.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="初识k8s 简介： Kubernetes 简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。 中文官网：https://kubernetes.io/zh/ 中文社区：https://www.kubernetes.org.cn/ 官方文档：https://kubernetes.io/zh/docs/home/ 社区文档：http://docs.kubernetes.org.cn/
部署方式的进化 https://kubernetes.io/zh/docs/concepts/overview/
功能 架构 整体主从方式 Master 节点架构 kube-apiserver 对外暴露K8S 的api 接口，是外界进行资源操作的唯一入口。
提供认证、授权、访问控制、API 注册和发现等机制。
etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes 所有集 群数据的后台数据库。 Kubernetes 集群的etcd 数据库通常需要有个备份计划
kube-scheduler 主节点上的组件，该组件监视那些新创建的未指定运行节点的Pod，并选择节点 让Pod 在上面运行。 所有对k8s 的集群操作，都必须经过主节点进行调度
kube-controller-manager 在主节点上运行控制器的组件 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维 护正确数量的Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入Service 与Pod)。 服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名 空间创建默认帐户和API 访问令牌
Node 节点架构 kubelet 一个在集群中每个节点上运行的代理。它保证容器都运行在Pod 中。 负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；
kube-proxy 负责为Service 提供cluster 内部的服务发现和负载均衡；
容器运行环境(Container Runtime) 容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、containerd、cri-o、rktlet 以及任 何实现Kubernetes CRI (容器运行环境接口)。"><meta property="og:title" content><meta property="og:description" content="初识k8s 简介： Kubernetes 简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。 中文官网：https://kubernetes.io/zh/ 中文社区：https://www.kubernetes.org.cn/ 官方文档：https://kubernetes.io/zh/docs/home/ 社区文档：http://docs.kubernetes.org.cn/
部署方式的进化 https://kubernetes.io/zh/docs/concepts/overview/
功能 架构 整体主从方式 Master 节点架构 kube-apiserver 对外暴露K8S 的api 接口，是外界进行资源操作的唯一入口。
提供认证、授权、访问控制、API 注册和发现等机制。
etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes 所有集 群数据的后台数据库。 Kubernetes 集群的etcd 数据库通常需要有个备份计划
kube-scheduler 主节点上的组件，该组件监视那些新创建的未指定运行节点的Pod，并选择节点 让Pod 在上面运行。 所有对k8s 的集群操作，都必须经过主节点进行调度
kube-controller-manager 在主节点上运行控制器的组件 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维 护正确数量的Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入Service 与Pod)。 服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名 空间创建默认帐户和API 访问令牌
Node 节点架构 kubelet 一个在集群中每个节点上运行的代理。它保证容器都运行在Pod 中。 负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；
kube-proxy 负责为Service 提供cluster 内部的服务发现和负载均衡；
容器运行环境(Container Runtime) 容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、containerd、cri-o、rktlet 以及任 何实现Kubernetes CRI (容器运行环境接口)。"><meta property="og:type" content="article"><meta property="og:url" content="https://willxwu.github.io/posts/k8s%E9%83%A8%E7%BD%B2%E7%BC%96%E6%8E%92/"><meta property="article:section" content="posts"></head><body><header class=app-header><a href=https://willxwu.github.io/><img class=app-header-avatar src=/avatar.jpg alt=willxwu></a><h1>归去来兮</h1><nav class=app-header-menu><a class=app-header-menu-item href=/archives/>归档</a>
-
<a class=app-header-menu-item href=/tags/>标签</a>
-
<a class=app-header-menu-item href=/links/>友链</a></nav><p>万般滋味，皆是生活。@生活哪有那么复杂，简单甚好。</p><div class=app-header-social><a target=_blank href=https://github.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://twitter.com/i2school rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a target=_blank href=https://yanxizhu.com rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 1, 0001</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div></div></header><div class=post-content><h1 id=初识k8s>初识k8s</h1><h1 id=简介><strong>简介</strong>：</h1><p>Kubernetes 简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。
中文官网：https://kubernetes.io/zh/
中文社区：https://www.kubernetes.org.cn/
官方文档：https://kubernetes.io/zh/docs/home/
社区文档：http://docs.kubernetes.org.cn/</p><h1 id=部署方式的进化><strong>部署方式的进化</strong></h1><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112019717.png alt></p><p><a href=https://kubernetes.io/zh/docs/concepts/overview/>https://kubernetes.io/zh/docs/concepts/overview/</a></p><h1 id=功能><strong>功能</strong></h1><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112020357.png alt></p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112021860.png alt></p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112022602.png alt></p><h1 id=架构><strong>架构</strong></h1><h2 id=整体主从方式>整体主从方式</h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112025982.png alt></p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112025961.png alt></p><h2 id=master-节点架构><strong>Master 节点架构</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112026193.png alt></p><h3 id=kube-apiserver><strong>kube-apiserver</strong></h3><p>对外暴露K8S 的api 接口，是外界进行资源操作的唯一入口。</p><p>提供认证、授权、访问控制、API 注册和发现等机制。</p><h3 id=etcd><strong>etcd</strong></h3><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes 所有集
群数据的后台数据库。
Kubernetes 集群的etcd 数据库通常需要有个备份计划</p><h3 id=kube-scheduler><strong>kube-scheduler</strong></h3><p>主节点上的组件，该组件监视那些新创建的未指定运行节点的Pod，并选择节点
让Pod 在上面运行。
所有对k8s 的集群操作，都必须经过主节点进行调度</p><h3 id=kube-controller-manager><strong>kube-controller-manager</strong></h3><p>在主节点上运行控制器的组件
这些控制器包括:
节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。
副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维
护正确数量的Pod。
端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入Service
与Pod)。
服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名
空间创建默认帐户和API 访问令牌</p><h2 id=node-节点架构><strong>Node 节点架构</strong></h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112028719.png alt></p><h3 id=kubelet><strong>kubelet</strong></h3><p>一个在集群中每个节点上运行的代理。它保证容器都运行在Pod 中。
负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</p><h3 id=kube-proxy><strong>kube-proxy</strong></h3><p>负责为Service 提供cluster 内部的服务发现和负载均衡；</p><h3 id=容器运行环境container-runtime><strong>容器运行环境(Container Runtime)</strong></h3><p>容器运行环境是负责运行容器的软件。
Kubernetes 支持多个容器运行环境: Docker、containerd、cri-o、rktlet 以及任
何实现Kubernetes CRI (容器运行环境接口)。</p><h3 id=fluentd><strong>fluentd</strong></h3><p>是一个守护进程，它有助于提供集群层面日志集群层面的日志</p><h1 id=概念><strong>概念</strong></h1><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112030694.png alt></p><h2 id=container容器可以是docker-启动的一个容器><strong>Container</strong>：容器，可以是docker 启动的一个容器</h2><h2 id=pod><strong>Pod</strong>：</h2><p>k8s 使用Pod 来组织一组容器
一个Pod 中的所有容器共享同一网络。
Pod 是k8s 中的最小部署单元</p><h2 id=volume><strong>Volume</strong></h2><p>声明在Pod 容器中可访问的文件目录
可以被挂载在Pod 中一个或多个容器指定路径下
支持多种后端存储抽象(本地存储，分布式存储，云存
储…)</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112031724.png alt></p><h2 id=controllers更高层次对象部署和管理pod><strong>Controllers</strong>：更高层次对象，部署和管理Pod；</h2><p>ReplicaSet：确保预期的Pod 副本数量
Deplotment：无状态应用部署
StatefulSet：有状态应用部署
DaemonSet：确保所有Node 都运行一个指定Pod
Job：一次性任务
Cronjob：定时任务</p><h2 id=deployment><strong>Deployment</strong>：</h2><p>定义一组Pod 的副本数目、版本等
通过控制器（Controller）维持Pod 数目(自动回
复失败的Pod)
通过控制器以指定的策略控制版本（滚动升级，回滚等）</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112033197.png alt></p><h2 id=service><strong>Service</strong></h2><p>定义一组Pod 的访问策略
Pod 的负载均衡，提供一个或者多个Pod 的稳定访问地址</p><p>支持多种方式（ClusterIP、NodePort、LoadBalance）</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112033137.png alt></p><h2 id=label标签用于对象资源的查询筛选><strong>Label</strong>：标签，用于对象资源的查询，筛选</h2><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112034404.png alt></p><h2 id=namespace命名空间逻辑隔离><strong>Namespace</strong>：命名空间，逻辑隔离</h2><p>一个集群内部的逻辑隔离机制（鉴权，资源）</p><p>每个资源都属于一个namespace</p><p>同一个namespace 所有资源名不能重复</p><p>不同namespace 可以资源名重复</p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112035801.png alt></p><h2 id=api><strong>API</strong></h2><p>我们通过kubernetes 的API 来操作整个集群。
可以通过kubectl、ui、curl 最终发送http+json/yaml 方式的请求给API Server，然后控制k8s集群。</p><h1 id=注意>注意</h1><p><strong>k8s 里的所有的资源对象都可以采用yaml 或JSON 格式的文件定义或描述</strong></p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112036114.png alt></p><h1 id=流程叙述>流程叙述</h1><p>1、通过Kubectl 提交一个创建RC（Replication Controller）的请求，该请求通过APIServer
被写入etcd 中
2、此时Controller Manager 通过API Server 的监听资源变化的接口监听到此RC 事件</p><p>3、分析之后，发现当前集群中还没有它所对应的Pod 实例，
4、于是根据RC 里的Pod 模板定义生成一个Pod 对象，通过APIServer 写入etcd
5、此事件被Scheduler 发现，它立即执行一个复杂的调度流程，为这个新Pod 选定一
个落户的Node，然后通过API Server 讲这一结果写入到etcd 中，
6、目标Node 上运行的Kubelet 进程通过APIServer 监测到这个“新生的”Pod，并按照它
的定义，启动该Pod 并任劳任怨地负责它的下半生，直到Pod 的生命结束。
7、随后，我们通过Kubectl 提交一个新的映射到该Pod 的Service 的创建请求
8、ControllerManager 通过Label 标签查询到关联的Pod 实例，然后生成Service 的
Endpoints 信息，并通过APIServer 写入到etcd 中，
9、接下来，所有Node 上运行的Proxy 进程通过APIServer 查询并监听Service 对象与
其对应的Endpoints 信息，建立一个软件方式的负载均衡器来实现Service 访问到后端
Pod 的流量转发功能。</p><p><strong>k8s 里的所有的资源对象都可以采用yaml 或JSON 格式的文件定义或描述</strong></p><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202203112107697.png alt></p></div><div class=post-footer></div></article></main></body></html>