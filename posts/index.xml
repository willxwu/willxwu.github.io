<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 朱言蹊</title><link>https://www.yanxizhu.com/posts/</link><description>Recent content in Posts on 朱言蹊</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://www.yanxizhu.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://www.yanxizhu.com/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid><description>使用dbcp连接池，进行数据库的CRUD，涉及jar包：commons-dbcp2-2.8.0.jar（连接池包）、commons-pool2-2.9.0.jar（dbcp依赖该包）、commons-logging-1.2.jar（接口日志包）、mysql-connector-java-5.1.37-bin.jar（数据库连接驱动）、commons-dbutils-1.7.jar（基本CRUD操作）
DbcpUtils数据库连接池配置：
package learn.javase.dbcppool; import org.apache.commons.dbcp2.BasicDataSource; /** * 利用DBCP链接数据库 * @author Jole * */ public class DbcpUtils { private static BasicDataSource dataSource = new BasicDataSource(); static { //必配参数 dataSource.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource.setUrl(&amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;); dataSource.setUsername(&amp;#34;root&amp;#34;); dataSource.setPassword(&amp;#34;11111&amp;#34;); //可配参数 dataSource.setInitialSize(10); dataSource.setMaxIdle(8); dataSource.setMinIdle(2); } public static BasicDataSource getConnecton() { return dataSource; } } 利用DbcpUtils进行数据库的CRUD操作：
package learn.javase.dbcppool; import java.</description></item><item><title/><link>https://www.yanxizhu.com/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</guid><description>通过读取properties获取链接数据库信息，利用apache开源数据库操作工具包DBUtils进行数据库CRUD操作。
properties文件：
driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test user=root password=11111 通过dbutils自定义获取数据库连接对象:
package learn.javase.jdbc; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.util.Properties; public class JdbcUtils{ private static Connection conn; private static String driverClass; private static String url; private static String user; private static String password; static { try { getReadConfig(); Class.forName(driverClass); conn = DriverManager.getConnection(url, user, password); }catch(Exception e) { new RuntimeException(&amp;#34;链接数据库失败！&amp;#34;); } } private static void getReadConfig() throws Exception{ InputStream in = JdbcUtils.</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85/</guid><description>一、环境准备 备份原yum 源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup CentOS设置新yum 源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 使用阿里云Docker Yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 生成缓存
yum makecache 卸载旧版本Docker
yum remove docker docker-common docker-selinux 二、安装Docker CE 安装需要的依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2 安装
yum install docker-ce -y 启动docker
sudo systemctl start docker 设置开机启动
sudo systemctl enable docker 配置Docker 镜像加速</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85mysql/</guid><description>安装前提，已经搭建好Docker环境，关于docker安装可参考我另一篇文章《Docker安装》
一、Docker安装MySQL 拉取Docker镜像
docker pull mysql:5.7 运行MySQL容器,参数说明见-说明1
docker run -p 3306:3306 --name mysql \ -v /mydata/mysql/log:/var/log/mysql \ -v /mydata/mysql/data:/var/lib/mysql \ -v /mydata/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=密码 \ -d mysql:5.7 二、MySQL配置 修改MySQL配置文件,my.cnf内容见-说明2
vi /mydata/mysql/conf/my.cnf 容器的mysql 命令行工具连接
docker exec -it mysql mysql -uroot -p 注意：会提示输入密码，也就是上面2运行容器时配置的密码
设置root 远程访问
grant all privileges on *.* to &amp;#39;root&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;密码&amp;#39; with grant option; 刷新MySQL配置</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85nginx/</guid><description>一、Docker安装Nginx 拉取Nginx镜像
docker pull nginx:1.10 随便启动一个nginx 实例，只是为了复制出配置
docker run -p 80:80 --name nginx -d nginx:1.10 拷贝容器内的配置文件
docker container cp nginx:/etc/nginx . 重命名文件夹
mv nginx conf 移动配置文件到/mydata/nginx下
mv conf /mydata/nginx/ 终止原容器
docker stop nginx 删除原容器
docker rm nginx 运行Nginx容器,参数见-说明1
docker run -d -p 80:80 -p 443:443 --name nginx -v /mydata/nginx/html:/var/www/html -v /mydata/nginx/conf/conf.d:/etc/nginx/conf.d -v /mydata/nginx/logs:/var/log/nginx --link php:phpfpm --name nginx nginx:1.</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85php/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85php/</guid><description>Docker安装PHP 拉取PHP镜像
docker pull php:7.4-fpm 运输PHP容器
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 进入PHP容器
docker exec -it php /bin/bash PHP扩展安装(非必须)
docker-php-ext-install pdo_mysql 设置随Docke启动
docker update --restart=always php 注意：自己映射路径/mydata/nginx/html。</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Docker常用命令
一、镜像 查看docker容器镜像
docker images 拉去容器镜像
docker pull 容器 删除容器镜像
docker rmi 容器 二、容器 安装容器，-d后台运行，-v映射路径, -name容器名称, -link链接外部容器，-p 端口号映射，-e设置密码
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 启动容器
docker start 容器 关闭容器
docker stop 容器 重启容器
docker restart 容器 查看运行容器
docker ps 查看所有容器
docker ps -s 删除容器</description></item><item><title/><link>https://www.yanxizhu.com/posts/html%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/html%E5%AD%A6%E4%B9%A0/</guid><description>1、HTML基本格式 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; html：根标签，只有一个（网页所有内容都应该写在根标签里面）
head：子标签，用来设置头部内容
body：子标签，网页主体,所有要显示的内容放这里面
title：
网页的标题标签，也就是网页显示名字。
搜索引擎检索页面时，会首先检索titlte中的内容。
元素：一个完整的标签&amp;lt;&amp;gt;&amp;lt;/&amp;gt;
标签&amp;lt;&amp;gt;
2、HTML后缀名 将编写好的文件保存为.html网页格式文件
显示文件格式名
3、HTML注释 &amp;lt;！-- 这是一个注释的格式，可以直接换行 继续写注释。 --&amp;gt; 注释中的内容，不会显示在页面。
可以写注释来对代码进行描述，便于后期的维护。要养成良好的编写注释习惯。
4、标签属性 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello &amp;lt;font color=&amp;#34;red&amp;#34;&amp;gt;World&amp;lt;/font&amp;gt; ！&amp;lt;/h1&amp;gt; &amp;lt;!</description></item><item><title/><link>https://www.yanxizhu.com/posts/java-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java-io/</guid><description>将自己看作为程序，将数据输出到文件中，称之为输出。 从文件读取数据到程序，称为输出。
JAVA流操作主要分为字节流、字符流。
字节流鼻祖：InputStream\OutpuStream
字符流鼻祖:Reader\Writer
File 1、File常用方法 package learn.javase; import java.io.File; /** * File常用操作 * @author Jole * */ public class FileDemo01 { public static void main(String[] args) { File file = new File(&amp;#34;H://&amp;#34;); //此抽象路径名表示的文件或目录的名称；如果路径名的名称序列为空，则返回空字符串 System.out.println(file.getName()); //返回文件大小 System.out.println(file.length()); //返回绝对路径 System.out.println(file.getAbsolutePath()); //绝对路径名 System.out.println(file.getAbsoluteFile()); //父目录 System.out.println(file.getParentFile()); //是否存在 System.out.println(file.exists()); //是否是目录 System.out.println(file.isDirectory()); //返回路径下的文件或文件夹 System.out.println(file.list()); for(String path : file.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</guid><description>利用JAVA原生JDBC进行数据库的CRUD操作。简单记录一下。
package learn.javase.jdbc; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Scanner; import java.sql.PreparedStatement; import java.sql.Connection; /** * jdbc使用 * @author Jole * */ public class MyDriver { public static void main(String[] args) throws ClassNotFoundException, SQLException{ //1.注册驱动 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); //2.获取数据库连接对象 String url = &amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;; String user = &amp;#34;root&amp;#34;; String password = &amp;#34;111111&amp;#34;; Connection conn = DriverManager.getConnection(url, user, password); // System.out.println(conn); //3.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%8F%8D%E5%B0%84/</guid><description>获取反射对象的3种方法。通过反射创建对象、通过反射获取有参、无参、公有、私有构造方法。通过反射获取公有、私有成员变量并修改之。通过反射获取成员方法，并调用。通过反射泛型擦除，存值。通过读取配置文件运行反射方法。
package learn.javase.mycalss; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; /** * 一、获取class的三种方式 * * 二、获取公有构造方法 * 注意： * 1、被反射的类必须是有空参数的构造器 * 2、构造方法必须是public的才能反射获取 * * 三、获取所有构造方法 * * @author Jole * */ public class ClassDemo { public static void main(String[] args) throws Exception{ // 方式1、.getClass() Person p = new Person(); Class c = p.getClass(); System.out.println(c); //方式2、类名.class Class c3 = Person.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</guid><description>总结一下JAVA基础知识如：注释、关键字、标识符、数据类型、变量、数据类型转换等基础语法。初学者可参考看看。
1、程序注释 单行注释：
//xxxxxx 多行注释：
/* xxxxxx */ 文档注释：
/** xxxxxx */ 2、关键字 关键字：是被Java语言赋予特殊含义，具有专门用途的单词。所有的Java关键词，都是小写。关键词比较多，不用刻意去背，以后用多了自己就记住了。
3、标识符 Java中除了关键字以外基本上都是标识符。我们自己定义的词，比如自己定义的HelloWorld。
标志符命名规则：
标志符组成：字母、数字、下划线、美元符号 字母：a~z、A~Z 数字：0-9 下划线：_ 美元符号：$ 注意：不能数字开头，不能是关键字，严格区分大小写，不限制长度起名时，尽量达到见名知意。
4、数据类型 数据类型分为基本数据类型和引用数据类型。
A、基本数据类型：4类8种（4类展开后共8种基本类型），基本数据类型是JAVA中内置的类型。
第一类：整型
字节
byte 1个字节 二进制位数：8 -128～127 短整型
short 2个字节 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 （-2的15此方） 最大值：Short.MAX_VALUE=32767 （2的15次方-1） 整型
int 4个字节 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方） 最大值：Integer.MAX_VALUE= 2147483647 （2的31次方-1） 长整型
long 8个字节 二进制位数：64 包装类：java.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid><description>JAVA流程控制语句JAVA中非常重要的基础知识点务必完全理解掌握，总结记录一下之前学习笔记。JAVA流程控制语句是编程的基础知识，主要是为了更好的组织代码的执行流程，下面将详细介绍java流程控制语句。
一、选择结构if if条件语句分为三种格式。
if语句
如果满足某种条件就执行。
if语句格式：
if（条件）{ 语句的执行体 } 条件：结果必须是布尔类型 1==1 true || false 执行体：当id条件为true的时候，执行大括号中的语句，否则什么都不做。
例如：
/** * if语句例子 */ public class IfDemo { public static void main(String[] args) { // TODO Auto-generated method stub int i = 5; if(i==5) { System.out.println(&amp;#34;if中的条件是true&amp;#34;); i++; } System.out.println(&amp;#34;i=&amp;#34;+i); } } 注意：if()括号后面没有分号&amp;quot;;&amp;quot;
if&amp;hellip;else语句
如果满足某种条件，就执行某种处理，否则就执行另一种处理。
if &amp;hellip; else语法格式：
if(条件){ if的执行体 }else{ else的执行体 } 当if中的条件为true时，执行if的执行体，为false时，执行else的执行体。</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>进程：CPU为每个应用程序分配的独立空间，一个进程可能有多个线程。进程为线程中的摸个执行任务程序，多个进程之间可以进行共享数据。而JAVA的线程则是由JVM进程分配的，main方法所在线程，则成为主线程。
〇、线程状态 正常情况线程执行步骤：新建-》运行-》死亡
当CPU资源不够时，CUP分配给各个线程的资源可能不同(貌似有点像是线程在抢资源，实际是CPU分配资源给每个线程)。 因此就会出现线程的阻塞、休眠、等待3个状态。其中阻塞状态，当cpu资源够时，阻塞状态的线程可能恢复到运行状态，而休眠、等待的线程也可能进入运行状态。休眠、等待状态可能转换成阻塞状态，但是阻塞状态不会变成休眠、等待状态。
一、多线程的实现 0、线程常用方法 package learn.javase.threads; /** * 继承Thread创建线程，设置线程名称、获取线程名称 * @author Jole * */ public class ThreadDemo01 { public static void main(String[] args) { MyThreadsDemo mt = new MyThreadsDemo(); mt.setName(&amp;#34;Hi&amp;#34;); mt.start(); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName()); } } 线程实现方式主测试类：
package learn.javase.threads; public class MyThreadsDemo extends Thread{ public MyThreadsDemo() { super(&amp;#34;Google&amp;#34;); } public void run() { for(int i=0;i&amp;lt;5;i++) { try { Thread.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%BC%82%E5%B8%B8/</guid><description>异常 Throwable Throwable类是所有错误跟异常类的超类.
Exception Exception异常类及其子类都是继承自Throwable类，用来表示java中可能出现的异常，并且合理的处理这些异常。
RuntimeException RuntimeException类是运行异常类，继承自Exception类，它以及它的子类只能在运行过程中存在，当出现时，只能修改源代码，此异常无法处理。
特点：
　方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常
　运行时期异常一旦发生,需要程序人员修改源代码
Error Error类是与Exception的平级的类，用来表示Java中存在的严重错误，只能通过修改代码来解决问题。
区别 Exception与Error区别：
Exception是指程序在编译或者运行时出现的某种异常问题，我们可以对异常进行某种处理，如果不处理异常的话，程序将会停止运行。
Error是指程序在运行时出现的严重问题，无法处理，程序将会停止运行，Error通常都是系统级别的问题，都是虚拟机jvm所在系统发生的，只能通过修改源代码解决问题。
异常的产生 运行或编译时产生异常。 创建异常类的对象。 声明异常类。 将异常类对象传给调用者（main()方法）处理。 调用者无法处理，再将异常类对象传给jvm虚拟机。 jvm虚拟机将异常类的信息（名称、详细信息、异常所处的位置）打印在屏幕上，并且停止程序的运行。 抛出异常throw 在java中，提供了一个throw关键字，用来抛出一个指定的异常。
使用方法：
1.创建一个异常对象。封装一些提示信息
2.将这个异常告知调用者
使用格式：throw new 异常类名（参数）；
声明异常throws 声明异常格式：
修饰符 返回值类型 方法名称 （参数）throws 异常1名称，异常2名称{
}
捕获异常try&amp;hellip;catch&amp;hellip;finally
捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理
语句格式：
ry { //需要被检测的语句。 }catch(异常类 变量) { //参数。 //异常的处理语句。 }finally { //一定会被执行的语句。 } try：该代码块中编写可能产生异常的代码。
catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。
finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。
捕获异常的组合方式 try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放。 try catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。 一个try 多个catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 try finally 组合: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。 package learn.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E6%95%B0%E7%BB%84/</guid><description>JAVA数组重点掌握知识，以后肯定会用到的，可以了解一下底层原理。数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。
数组 数组定义格式：
数据类型[] 数组名(变量名) = new 数据类型[元素个数或数组长度]; 实例：
public class ArrayDemo01 { public static void main(String[] args) { int[] x = new int[100]; } } 注意：数组定长，一但定义长度为100，在使用时大小就是100了。不变量。
数组特点：定长、引用类型。
JVM java程序运行时，操作系统会给jvm虚拟机分配一块内存。JVM又会将这块内存，进行划分管理。
JVM内存划分：JVM对自己的内存进行了划分，分成5个区域。
1、寄存器：内存和CPU之间。 2、本地方法栈：JVM调用操作系统中的功能。 3、方法和数据共享：运行时其class文件，进入的地方。 4、方法栈：所有的方法运行的时候，进入的内存。 5、堆：存储的是容器和对象。 开发人员主要关心：方法和数据共享、方法栈、堆。
数组内存划分 首先，运行class文件，所以先进入方法区。 运行main方法，在方法栈中运行，但是main用不了那么多，所以方法栈中会分配一块给main方法是用。 执行数组，一个容器，所以JVM在堆内存，开空间，存储数组容器。 JVM会将该地址，给定义的数组变量arr（相当于arr引用了这个地址），所以数组是引用类型。 每次运行，JVM分配的地址是不同的。 当main方法运行完了，arr变量就没了，然后new int[3]也就没了 ，JVM垃圾回收机制，会自动帮我们回收，不用我们去处理了。 堆空间太大，怎么找到这个容器呢，所以每个数组，在内存中，都有自己的内存地址，也就是数组元素的首地址，第一个数据的地址。
注意：arr引用类型，保存的数据，实际上是内存中的地址。
数组元素的访问 数组是一个容器，存储到数组中的每个元素，都有自己的自动编号/下标（专业名词：索引）。
访问数组存储的元素，必须依赖索引。
访问公式：数组名[索引]
public class ArrayDemo02 { public static void main(String[] args) { int[] arr = new int[3]; System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</guid><description>最近项目对接时，中间B2B服务切换了域名，导致现有项目调用接口地址需要进行切换为https，同时需要安装SSL证书，这里记录一下JAVA工具keytool导入证书的过程。
一、问题点 切换域名后加上https，未导入证书报错:
[ERROR] - [2022-02-25 08:49:40.861] - [http-nio-9999-exec-1] - [DealParamAction.java:needConfirmAction:133] - no confirm method, call actual method = getNSDDtailByInterface [INFO ] - [2022-02-25 08:50:04.483] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:04.484] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:445] - Retrying request [INFO ] - [2022-02-25 08:50:25.487] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:25.</description></item><item><title/><link>https://www.yanxizhu.com/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>Map集合的2种循环方式。一种是通过map.entrySet()。
另一种是map.keySet()。 所有的集合都可以通过迭代器Iterator，进行遍历。
package learn.javase; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set; /** * 重要 * 遍历map的两种方式map.entrySet() map.keySet() * @author Jole * */ public class MapDemo { public static void main(String[] args) { Map&amp;lt;Integer ,String &amp;gt; map = new HashMap(); map.put(1, &amp;#34;111&amp;#34;); map.put(2, &amp;#34;2222&amp;#34;); //方式一 entrySet() Set&amp;lt;Map.Entry &amp;lt;Integer, String&amp;gt;&amp;gt; sets = map.entrySet(); //获取值1，通过for for(Map.Entry &amp;lt;Integer, String&amp;gt; entry : sets) { System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>使用maven的好处： 大型项目的好处，建立一个父项目，各组或部门可以模块开发，不用拉取整个项目进行开发。
创建maven项目说明： maven项目结构： Maven常用命令： 1、一键构建项目命令:
mvn tomcat:run 注意：该命令使用的是tomcat插件进行运行的，不需要单独安装配置tomcat。
2、清理编译好后的文件（target文件夹及里面所有的文件）：
mvn clean 3、编译并运行了main里面的代码（只编译main主文件里面的java代码，test里面的java代码不编译不编译）：
mvn compile 4、编译并运行了test里面的代码(只编译test里面的java代码，main里面的java代码不编译)：
mvn test 5、打包，并将包放到tager文件夹下面。打成war或jar名称由POM文件里面的这3个标签值决定： 例如打包成这个名字:HelloWorld-0.0.2-SNAPASHOT.war HelloWorld&amp;ndash;打成包的名字 0.0.2-SNAPASHOT&amp;ndash;版本 war&amp;ndash;什么类型的包
mvn package 6、把项目发布到本地仓库
mvn install 同时运行了mvn compile、mvn test、mvn package、mvn install、mvn deploy命令。
7、jar或war包发布到私服上
mvn deploy maven生命周期有三种： 1、clean生命周期：clean 2、default生命周期：compile、test、package、install、deploy命令 3、site生命周期:site(生成项目的文档说明)
不同的生命周期，命令可以同时运行。
maven依赖范围： complie
provided:编译（complie）时需要、测试时也需要、运行时不需要，打包时不需要
runtime：例如：数据库驱动包
test：编译时不需要，测试时需要、运行时不需要
maven添加插件： 常见问题： 出现该提示表示jdk安装有问题，重新安装即可。
maven整体模型也就是上面说的内容： 版本冲突解决原则：
1、路径近者原则（比如2个坐标中有不同版本的相同的jar包，自己在加入要使用的版本的这个名称的坐标）
2、第一声明有限原则（比如2个坐标，谁排在pom.xml文件的前面就用谁的）
3、排除原则.（将名字和组织加入到exclusion中） 4、版本锁定 谁先传递锁定的版本，就用这个。 可以同时锁定多个版本
锁定版本里面使用${sprint.verion}注意上面锁定了，坐标里面的version就没有了，可以去除，就算不去除也没有了。</description></item><item><title/><link>https://www.yanxizhu.com/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</guid><description>&lt;p>第一步骤：下载nexus私服软件nexus-2.12.0-01-bundle&lt;/p>
&lt;p>第二不：安装&lt;/p>
&lt;p>进入nexus解压目录进入到bin目录:&lt;/p>
&lt;p>1、安装:执行nexus.bat install&lt;/p>
&lt;p>2、启动:nexus.bat start&lt;/p>
&lt;p>第三步：查看访问路径&lt;/p>
&lt;p>进入config目录，打开nexus.properties即可看到端口号，项目命令nexus。&lt;/p>
&lt;p>第四步：浏览器打开http://127.0.0.1:8081/nexus/&lt;/p>
&lt;p>默认登录账号:admin/admin123&lt;/p></description></item><item><title/><link>https://www.yanxizhu.com/posts/scannerrandom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/scannerrandom/</guid><description>Java的两个引用输入类型Scanner、Random类，Scanner用于接收键盘输入，Random用户产生随机数。引用类型也就是Sun公司为我们写好的类，我们直接使用就可以了。
1、引用数据类型的使用 导入包：知道用的这个类，在jdk的那个目录那个文件下。 创建对象：格式， 类 对象 = new 类型(); 如何使用: 对象.类的方法() 引用数据类型的使用与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式，如下：
数据类型 变量名 = new 数据类型(); 每种引用数据类型都有其方法，我们可以调用该类型实例的方法。
变量名.方法名(); 2、Scanner类 Scanner类是引用数据类型的一种，我们可以使用该类来完成用户键盘录入，获取到录入的数据。
导包
import java.util.Scanner; 创建对象实例
Scanner sc = new Scanner(System.in); 调用方法
//用来接收控制台录入的数字 int i = sc.nextInt(); //用来接收控制台录入的字符串 String s = sc.next(); Scanner使用Demo：
package java_learn_code; //导入包，指明类所在的的文件见，关键字import import java.util.Scanner; /** * 引用数据类型,使用步骤：1、导入包 。2、创建对象 3、通过对象调用方法 * @author Jole * Scanner的使用，所在目录java文件见-util文件夹 */ public class ScannerDemo { public static void main(String[] args) { System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</guid><description>首先知道Shiro架构有3个主要概念：Subject、SecurityManager和Realms。
Shiro基础架构图 ：
基础架构说明： Subject: As we’ve mentioned in our Tutorial, the Subject is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a Subject can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software. Subject instances are all bound to (and require) a SecurityManager.</description></item><item><title/><link>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description>通过Java Socket编程，实现多线程文件上传。主要涉及ServerScoket服务端、Socket客户端、IO流操作、多线线程。
客户端：
package learn.javase.Update; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; /** * 利用TCP的Socket\ServerSocket客户端向服务器上传文件 * 客户端 * @author Jole * */ public class UpClent { public static void main(String[] args) throws IOException{ Socket socket = new Socket(&amp;#34;127.0.0.1&amp;#34;,8888); OutputStream out = socket.getOutputStream(); //读取本地文件，并通过out输出流，发送给服务端 File file = new File(&amp;#34;J:&amp;#34;+File.separator+&amp;#34;wxhandbook-master.zip&amp;#34;); FileInputStream in = new FileInputStream(file); byte[] data = new byte[1024]; int len =0; while((len=in.</description></item><item><title/><link>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</guid><description>通过Socket网络编程，UDP实现简单聊天。主要涉及DatagramSocket进行数据传输、DatagramPacket进行数据包封装，2个类。
发送端:
package learn.javase.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; /** * 控制台输入；实现聊天。 * 发送方 * @author Jole * */ public class UdpSend { public static void main(String[] args) throws Exception{ Scanner scan = new Scanner(System.in); InetAddress ia = InetAddress.getByName(&amp;#34;192.168.1.4&amp;#34;); DatagramSocket socket = new DatagramSocket(); while(true) { String chatInfo = scan.nextLine(); byte[] info = chatInfo.getBytes(); DatagramPacket pack = new DatagramPacket(info, info.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88redis/</guid><description>适合当如缓存场景： 即时性、数据一致性要求不高的。 访问量大且更新频率不高的数据(读多，写少) 承担持久化工作。
读模式缓存使用流程: 凡是放入缓存中的数据，我们应该指定过期时间，使其可以再系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。
解决分布式缓存中本地缓存导致数据不一致问题，可以使用redis中间件解决。
springboot整合redis 1、引入springboot整合的start：pom文件引入依赖
&amp;lt;!--redis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 引入依赖之后就会有RedisAutoConfiguration，里面可以看的到redis的配置文件Redis.Properties.
@Configuration( proxyBeanMethods = false ) @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&amp;#34;redisTemplate&amp;#34;} ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.</description></item><item><title/><link>https://www.yanxizhu.com/posts/ssh%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/ssh%E5%88%9B%E5%BB%BA/</guid><description>1. 设置Git用user name和email git config --global user.name &amp;#34;XXX&amp;#34; git config --global user.email &amp;#34;XXX@gmail.com&amp;#34; 2. 生成密钥 ssh-keygen -t rsa -C &amp;#34;XXX@gmail.com&amp;#34; 中间连续3次Enter键.
3. 测试SSH key是否设置成功 ssh -T git@github.com 出现下面提示直接输入yes.
The authenticity of host &amp;#39;github.com (192.30.253.113)&amp;#39; can&amp;#39;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes 输出如下，则表示通过.
Hi xxxx! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access. 使用时，会根据本地git密钥信息与git或者coding仓库密钥信息比对，本地上传时会提示登录。</description></item><item><title/><link>https://www.yanxizhu.com/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Typora最后免费版本下载
Typora收费后，开始保留最后一个免费版本Version0.11.18(beta)，欢迎食用。
阿里网盘：
「typora-update-x64-1117.exe」https://www.aliyundrive.com/s/Xez1W6kvWZv 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。
百度网盘：
链接：https://pan.baidu.com/s/1zaaqxIv99xX98Qemw9tLrw 提取码：utq4
天翼网盘:
https://cloud.189.cn/t/3yEJbavmieye (访问码:1oov)</description></item><item><title/><link>https://www.yanxizhu.com/posts/virtualbox%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/virtualbox%E5%AE%89%E8%A3%85/</guid><description>一、virtualbox安装 1、下载 https://www.virtualbox.org/
2、在主板开启CPU虚拟化，自行百度
3、安装，直接下一步，选择安装路径。
二、安装虚拟机 1、下载虚拟系统CentOS7
https://app.vagrantup.com/boxes/search Vagrant官方镜像仓库
https://www.vagrantup.com/ Vagrant下载
2、初始化虚拟系统
打开安装好的virtualbox软件，打开window cmd窗口，运行下面命令，即可初始化一个CentOS7系统。初始化之后window用户文件夹夹会多出一个Vagrantfile文件。此时virtualbox界面就会多出一个CentOS系统了。
Vagrant init centos/7 3、启动虚拟机，初始root用户密码vagrant，此时看到virtualbox中的CentOS正在启动。
vagrant up 4、vagrant其他命令
使用vagrant用户链接至CentOS虚拟机，初始root用户密码vagrant。
vagrant ssh 上传文件
vagrant upload source [destination][name][id] 更多命令可以访问官网文档
5、设置固定ip，默认虚拟机ip是随机的，方式1-修改Vagrantfile，方式2-进入linx系统修改网卡配置信息
config.vm.network &amp;#34;private_network&amp;#34;,ip:&amp;#34;192.168.10.1&amp;#34; 6、重启虚拟机
vagrant reload 7、启动，除了上面的3启动虚拟机，也可以在virtualbox界面选择虚拟机右键开启。
8、virtualbox界面还可以设置虚拟机内存大小等信息，更多设置可以查看官网。</description></item><item><title/><link>https://www.yanxizhu.com/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Xshell 7、Xftp 7免费版本下载，官网每次下载懒得找，懒得注册，这里提供官网原版下载，官网下载地址
https://www.xshell.com/zh/free-for-home-school/
阿里网盘：
https://www.aliyundrive.com/s/ZV2jMWP4Fsr
百度网盘：
链接：https://pan.baidu.com/s/13Hx_HYbZFC4BGW56IlOdqA 提取码：xb2e
天翼网盘：
https://cloud.189.cn/t/ueABVvANryMn (访问码:w2se)
https://cloud.189.cn/t/Yjymuu3EF3Az (访问码:7it5)</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>博客一直使用firekylin搭建，最近看着typecho活跃度还可以，于是本周末用docker重新搭建了博客。
一、环境说明 操作系统：CentOS7.6
技术：Docker、MySQL、PHP、Nginx
使用工具：Xftp 7、Xshell 7、Notepad++
博客系统：Typecho
二、安装步骤 Docker环境搭建 Docker安装MySQL Docker安装PHP Docker安装Nginx 三、遇到问题 安装mysql、php、nginx时，映射文件路径错误，导致安装好后，找不到文件。
Nginx配置时映射路径错误、80端口自动转发443端口，导致http访问一直追加路径。
证书路径放置错误。
Typecho初始化安装时，提示&amp;quot;对不起，无法连接数据库，请先检查数据库配置再继续进行安装&amp;quot;。
四、解决方案 通过docker log 容器，查看日志，一步步解决。 添加异常提示代码：, $e-&amp;gt;getMessage() instal.php第56行，添加ob_start(); ip地址错误，默认localhost，docker安装时，需要改成公网ip或局域网ip。 未创建typecho数据库。 Nginx配置文件:
server { listen 443 ssl http2 reuseport; server_name yanxizhu.com www.yanxizhu.com; root /var/www/html/yanxizhu.com; index index.php; ssl on; ssl_certificate /etc/nginx/conf.d/自己证书.crt; ssl_certificate_key /etc/nginx/conf.</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid><description>一、创建仓库 注意：仓库名称、路径、选择语言、添加.gitignore、添加开源许可证、选择分支模型。
二、拉取项目 三、创建微服务模块-记账管理微服务 选择微服务必要组件
创建好第一个记账微服务后，项目结构。
然后安装上述步骤，依次创建出其它微服务模块。
各微服务共同点：
1、都导入了必备的spring web，OpenFeign
2、每一个服务，包名：com.yanxizhu.ifamily.xxxxx(booking/firend/。。。服务名)
3、模块名:ifamily-xxxxx(booking/fired/&amp;hellip;&amp;hellip;.服务名)
实例的包名：com.yanxizhu.ifamily.booking
模块名：ifamily-booking
四、设置总项目聚合各微服务 一、随便复制一个微服务的pom文件，粘贴到总项目中。
本次项目，如，复制ifamily-booking微服务中的pom.xml到总项目ifamily中。
二、修改总项目中的pom.xml文件。
1、修改模块名、项目名、描述
修改前：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily-booking&amp;lt;/artifactId&amp;gt;&amp;lt;!--1、模块名修改为总项目名--&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily-booking&amp;lt;/name&amp;gt;&amp;lt;!--2、修改为总项目名--&amp;gt; &amp;lt;description&amp;gt;家庭管理-记账服务&amp;lt;/description&amp;gt;&amp;lt;!--3、修改为聚合服务，把其它微服务聚合起来--&amp;gt; 修改后：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;聚合服务&amp;lt;/description&amp;gt; 2、删除服务依赖
&amp;lt;parent&amp;gt;&amp;lt;!--删除父引用--&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.4&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; 3、删除多余的依赖：
4、添加类型，为pom
&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; 5、聚合其他微服务模块
&amp;lt;modules&amp;gt;&amp;lt;!--聚合其他微服务--&amp;gt; &amp;lt;module&amp;gt;ifamily-booking&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; 最终的pom文件内容如下：</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</guid><description>1、 RabbitMQ Simulator RabbitMQ模拟器，可用于模拟MQ消息的收发消费情况。使用下面的绘图区域来表示您的消息传递拓扑。 将消息元素从左侧的工具箱拖到画布上。 要连接节点，请按住 ALT 键（或 SHIFT 键）并从源节点拖动以将其连接到目标节点。 官网地址 http://tryrabbitmq.com
2、 draw.io draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等 官网地址 http://draw.io
3、 PuTTY PuTTY 是一个 SSH 和 telnet 客户端，最初由 Simon Tatham 为 Windows 平台开发。 PuTTY 是开源软件，提供源代码，由一群志愿者开发和支持。 官网地址 https://www.putty.org/
4、 WinSCP WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。 官网地址 https://winscp.net
5、 FastStone Capture FastStone Capture 是一款功能强大、轻巧但功能齐全的截图工具和屏幕录像机以及编辑共计。编辑工具包括注释（文本、箭头线、高光）、调整大小、裁剪、锐化、水印、应用边缘效果等等。其他功能包括图像扫描、全局热键、自动文件名生成、支持外部编辑器、颜色选择器、屏幕放大镜、屏幕十字准线和屏幕标尺等功能。 官网地址 https://www.faststone.org
6、 potplayer 一款功能强大、界面美观、简洁的视频播放器。 官网地址 https://potplayer.daum.net
7、 notepad++ Notepad++ 是一个免费的（如“言论自由”和“免费啤酒”）源代码编辑器和支持多种语言的记事本替代品。 在 MS Windows 环境中运行，其使用受 GNU 通用公共许可证管理。 官网地址 https://notepad-plus-plus.</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</guid><description>create a new repository on the command line. push an existing repository from the command line. import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project.
create a new repository on the command line git init git add README.md git commit -m &amp;#34;first commit&amp;#34; git branch -M main git remote add origin https://github.com/willxwu/xxx.git git push -u origin main push an existing repository from the command line git remote add origin https://github.</description></item></channel></rss>