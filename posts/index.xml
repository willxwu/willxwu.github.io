<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 朱言蹊</title><link>https://www.yanxizhu.com/posts/</link><description>Recent content in Posts on 朱言蹊</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://www.yanxizhu.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://www.yanxizhu.com/posts/completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</guid><description>通过线程池性能稳定，也可以获取执行结果，并捕获异常。但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。因此我们可以使用completableFuture 异步编排方案。
比如：一个业务场景，需要同时获取多个数据，如果同步线程挨个执行，则需要时间为所有线程执行时间的总和。
如果我们使用异步线程执行，所需时间则为耗时最长那个异步线程的执行时间。
如果多个异常线程之间还存在依赖关系，比如线程3需要线程1的执行结果，线程6依赖线程3、线程2，那这个问题怎么解决呢。那就可以使用completableFuture 异步编排方案实现。
注意：completableFuture 是jdk1.8之后添加的一个功能。
CompletableFuture接口:
public class CompletableFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, CompletionStage&amp;lt;T&amp;gt; { public interface Future&amp;lt;V&amp;gt; { 以前用到的FutureTask就是用到的Future可以得到返回结果
public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; { public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } Future可以得到返回结果
CompletableFuture随便一个方法，都接受一个Function
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; applyToEither( CompletionStage&amp;lt;? extends T&amp;gt; other, Function&amp;lt;? super T, U&amp;gt; fn) { return orApplyStage(null, other, fn); } @FunctionalInterface public interface Function&amp;lt;T, R&amp;gt; { Function是一个@FunctionalInterface，所以对Lambda使用要熟悉。</description></item><item><title/><link>https://www.yanxizhu.com/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid><description>使用dbcp连接池，进行数据库的CRUD，涉及jar包：commons-dbcp2-2.8.0.jar（连接池包）、commons-pool2-2.9.0.jar（dbcp依赖该包）、commons-logging-1.2.jar（接口日志包）、mysql-connector-java-5.1.37-bin.jar（数据库连接驱动）、commons-dbutils-1.7.jar（基本CRUD操作）
DbcpUtils数据库连接池配置：
package learn.javase.dbcppool; import org.apache.commons.dbcp2.BasicDataSource; /** * 利用DBCP链接数据库 * @author Jole * */ public class DbcpUtils { private static BasicDataSource dataSource = new BasicDataSource(); static { //必配参数 dataSource.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource.setUrl(&amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;); dataSource.setUsername(&amp;#34;root&amp;#34;); dataSource.setPassword(&amp;#34;11111&amp;#34;); //可配参数 dataSource.setInitialSize(10); dataSource.setMaxIdle(8); dataSource.setMinIdle(2); } public static BasicDataSource getConnecton() { return dataSource; } } 利用DbcpUtils进行数据库的CRUD操作：
package learn.javase.dbcppool; import java.</description></item><item><title/><link>https://www.yanxizhu.com/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</guid><description>通过读取properties获取链接数据库信息，利用apache开源数据库操作工具包DBUtils进行数据库CRUD操作。
properties文件：
driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test user=root password=11111 通过dbutils自定义获取数据库连接对象:
package learn.javase.jdbc; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.util.Properties; public class JdbcUtils{ private static Connection conn; private static String driverClass; private static String url; private static String user; private static String password; static { try { getReadConfig(); Class.forName(driverClass); conn = DriverManager.getConnection(url, user, password); }catch(Exception e) { new RuntimeException(&amp;#34;链接数据库失败！&amp;#34;); } } private static void getReadConfig() throws Exception{ InputStream in = JdbcUtils.</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker-%E5%AE%89%E8%A3%85es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker-%E5%AE%89%E8%A3%85es/</guid><description>Docker 安装ES
一、下载镜像文件，存储和检索数据
docker pull elasticsearch:7.4.2 二、创建实例
创建文件，用于映射
mkdir -p /mydata/elasticsearch/config mkdir -p /mydata/elasticsearch/data echo &amp;#34;http.host: 0.0.0.0&amp;#34; &amp;gt;&amp;gt; /mydata/elasticsearch/config/elasticsearch.yml 设置权限
chmod -R 777 /mydata/elasticsearch/ 三、启动配置镜像
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \ -e &amp;#34;discovery.type=single-node&amp;#34; \ -e ES_JAVA_OPTS=&amp;#34;-Xms64m -Xmx512m&amp;#34; \ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \ -d elasticsearch:7.4.2 以后再外面装好插件重启即可；
特别注意： -e ES_JAVA_OPTS=&amp;quot;-Xms64m -Xmx256m&amp;quot; \ 测试环境下，设置ES 的初始内存和最大内存，否则导 致过大启动不了ES</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85/</guid><description>一、环境准备 备份原yum 源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup CentOS设置新yum 源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 使用阿里云Docker Yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 生成缓存
yum makecache 卸载旧版本Docker
yum remove docker docker-common docker-selinux 二、安装Docker CE 安装需要的依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2 安装
yum install docker-ce -y 启动docker
sudo systemctl start docker 设置开机启动
sudo systemctl enable docker 配置Docker 镜像加速</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85kibana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85kibana/</guid><description>Docker安装Kibana
一、拉取镜像，可视化检索数据
docker pull kibana:7.4.2 二、启动运行容器
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.1.10:9200 -p 5601:5601 \ -d kibana:7.4.2 注意：更改自己的ip，es端口，以及和es版本号对应。</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85mysql/</guid><description>安装前提，已经搭建好Docker环境，关于docker安装可参考我另一篇文章《Docker安装》
一、Docker安装MySQL 拉取Docker镜像
docker pull mysql:5.7 运行MySQL容器,参数说明见-说明1
docker run -p 3306:3306 --name mysql \ -v /mydata/mysql/log:/var/log/mysql \ -v /mydata/mysql/data:/var/lib/mysql \ -v /mydata/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=密码 \ -d mysql:5.7 二、MySQL配置 修改MySQL配置文件,my.cnf内容见-说明2
vi /mydata/mysql/conf/my.cnf 容器的mysql 命令行工具连接
docker exec -it mysql mysql -uroot -p 注意：会提示输入密码，也就是上面2运行容器时配置的密码
设置root 远程访问
grant all privileges on *.* to &amp;#39;root&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;密码&amp;#39; with grant option; 刷新MySQL配置</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85nginx/</guid><description>一、Docker安装Nginx 拉取Nginx镜像
docker pull nginx:1.10 随便启动一个nginx 实例，只是为了复制出配置
docker run -p 80:80 --name nginx -d nginx:1.10 拷贝容器内的配置文件
docker container cp nginx:/etc/nginx . 重命名文件夹
mv nginx conf 移动配置文件到/mydata/nginx下
mv conf /mydata/nginx/ 终止原容器
docker stop nginx 删除原容器
docker rm nginx 运行Nginx容器,参数见-说明1
docker run -d -p 80:80 -p 443:443 --name nginx -v /mydata/nginx/html:/var/www/html -v /mydata/nginx/conf/conf.d:/etc/nginx/conf.d -v /mydata/nginx/logs:/var/log/nginx --link php:phpfpm --name nginx nginx:1.</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85php/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85php/</guid><description>Docker安装PHP 拉取PHP镜像
docker pull php:7.4-fpm 运输PHP容器
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 进入PHP容器
docker exec -it php /bin/bash PHP扩展安装(非必须)
docker-php-ext-install pdo_mysql 设置随Docke启动
docker update --restart=always php 注意：自己映射路径/mydata/nginx/html。</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85rabbitmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85rabbitmq/</guid><description>Docker安装RabbitMQ 运行RabbitMQ容器 第一次运行没有RabbitMQ镜像，会自动下载。
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management 说明：
4369, 25672 (Erlang发现&amp;amp;集群端口) 5672, 5671 (AMQP端口) 15672 (web管理后台端口) 61613, 61614 (STOMP协议端口) 1883, 8883 (MQTT协议端口) https://www.rabbitmq.com/networking.html
设置随docker启动 docker update --restart=always rabbitmq 访问RabbitMQ 通过ip地址加15672端口即可访问，初始账号密码guest</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%AE%89%E8%A3%85redis/</guid><description>docker安装redis 一、docker拉取redis镜像 docker pull redis 二、创建实例并启动 创建映射配置文件路径
mkdir -p /mydata/redis/conf touch /mydata/redis/conf/redis.conf 创建启动
docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \ -d redis redis-server /etc/redis/redis.conf redis 自描述文件： https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf
三、使用redis 镜像执行redis-cli 命令连接 docker exec -it redis redis-cli 四、设置随docker启动redis自动启动 docker update --restart=always redis 更多配置，请参考redis官网文档，https://redis.io/documentation。</description></item><item><title/><link>https://www.yanxizhu.com/posts/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Docker常用命令
一、镜像 查看docker容器镜像
docker images 拉去容器镜像
docker pull 容器 删除容器镜像
docker rmi 容器 二、容器 安装容器，-d后台运行，-v映射路径, -name容器名称, -link链接外部容器，-p 端口号映射，-e设置密码
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 启动容器
docker start 容器 关闭容器
docker stop 容器 重启容器
docker restart 容器 查看运行容器
docker ps 查看所有容器
docker ps -s 删除容器</description></item><item><title/><link>https://www.yanxizhu.com/posts/es6%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/es6%E8%AF%AD%E6%B3%95/</guid><description>ES6语法 一、let &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; // { // //var 声明的变量往往会跨域 // //let 声明的变量有严格局部作用域 // var a = 1; // let b = 2; // } // console.log(a); //1 // console.log(b); //Uncaught ReferenceError: b is not defined // //var 可以声明多次 // //let 只能声明一次 // var m = 3; // var m = 4; // let n = 5; // // let n=5; // console.</description></item><item><title/><link>https://www.yanxizhu.com/posts/html%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/html%E5%AD%A6%E4%B9%A0/</guid><description>1、HTML基本格式 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; html：根标签，只有一个（网页所有内容都应该写在根标签里面）
head：子标签，用来设置头部内容
body：子标签，网页主体,所有要显示的内容放这里面
title：
网页的标题标签，也就是网页显示名字。
搜索引擎检索页面时，会首先检索titlte中的内容。
元素：一个完整的标签&amp;lt;&amp;gt;&amp;lt;/&amp;gt;
标签&amp;lt;&amp;gt;
2、HTML后缀名 将编写好的文件保存为.html网页格式文件
显示文件格式名
3、HTML注释 &amp;lt;！-- 这是一个注释的格式，可以直接换行 继续写注释。 --&amp;gt; 注释中的内容，不会显示在页面。
可以写注释来对代码进行描述，便于后期的维护。要养成良好的编写注释习惯。
4、标签属性 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello &amp;lt;font color=&amp;#34;red&amp;#34;&amp;gt;World&amp;lt;/font&amp;gt; ！&amp;lt;/h1&amp;gt; &amp;lt;!</description></item><item><title/><link>https://www.yanxizhu.com/posts/java-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java-io/</guid><description>将自己看作为程序，将数据输出到文件中，称之为输出。 从文件读取数据到程序，称为输出。
JAVA流操作主要分为字节流、字符流。
字节流鼻祖：InputStream\OutpuStream
字符流鼻祖:Reader\Writer
File 1、File常用方法 package learn.javase; import java.io.File; /** * File常用操作 * @author Jole * */ public class FileDemo01 { public static void main(String[] args) { File file = new File(&amp;#34;H://&amp;#34;); //此抽象路径名表示的文件或目录的名称；如果路径名的名称序列为空，则返回空字符串 System.out.println(file.getName()); //返回文件大小 System.out.println(file.length()); //返回绝对路径 System.out.println(file.getAbsolutePath()); //绝对路径名 System.out.println(file.getAbsoluteFile()); //父目录 System.out.println(file.getParentFile()); //是否存在 System.out.println(file.exists()); //是否是目录 System.out.println(file.isDirectory()); //返回路径下的文件或文件夹 System.out.println(file.list()); for(String path : file.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</guid><description>利用JAVA原生JDBC进行数据库的CRUD操作。简单记录一下。
package learn.javase.jdbc; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Scanner; import java.sql.PreparedStatement; import java.sql.Connection; /** * jdbc使用 * @author Jole * */ public class MyDriver { public static void main(String[] args) throws ClassNotFoundException, SQLException{ //1.注册驱动 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); //2.获取数据库连接对象 String url = &amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;; String user = &amp;#34;root&amp;#34;; String password = &amp;#34;111111&amp;#34;; Connection conn = DriverManager.getConnection(url, user, password); // System.out.println(conn); //3.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%8F%8D%E5%B0%84/</guid><description>获取反射对象的3种方法。通过反射创建对象、通过反射获取有参、无参、公有、私有构造方法。通过反射获取公有、私有成员变量并修改之。通过反射获取成员方法，并调用。通过反射泛型擦除，存值。通过读取配置文件运行反射方法。
package learn.javase.mycalss; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; /** * 一、获取class的三种方式 * * 二、获取公有构造方法 * 注意： * 1、被反射的类必须是有空参数的构造器 * 2、构造方法必须是public的才能反射获取 * * 三、获取所有构造方法 * * @author Jole * */ public class ClassDemo { public static void main(String[] args) throws Exception{ // 方式1、.getClass() Person p = new Person(); Class c = p.getClass(); System.out.println(c); //方式2、类名.class Class c3 = Person.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</guid><description>总结一下JAVA基础知识如：注释、关键字、标识符、数据类型、变量、数据类型转换等基础语法。初学者可参考看看。
1、程序注释 单行注释：
//xxxxxx 多行注释：
/* xxxxxx */ 文档注释：
/** xxxxxx */ 2、关键字 关键字：是被Java语言赋予特殊含义，具有专门用途的单词。所有的Java关键词，都是小写。关键词比较多，不用刻意去背，以后用多了自己就记住了。
3、标识符 Java中除了关键字以外基本上都是标识符。我们自己定义的词，比如自己定义的HelloWorld。
标志符命名规则：
标志符组成：字母、数字、下划线、美元符号 字母：a~z、A~Z 数字：0-9 下划线：_ 美元符号：$ 注意：不能数字开头，不能是关键字，严格区分大小写，不限制长度起名时，尽量达到见名知意。
4、数据类型 数据类型分为基本数据类型和引用数据类型。
A、基本数据类型：4类8种（4类展开后共8种基本类型），基本数据类型是JAVA中内置的类型。
第一类：整型
字节
byte 1个字节 二进制位数：8 -128～127 短整型
short 2个字节 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 （-2的15此方） 最大值：Short.MAX_VALUE=32767 （2的15次方-1） 整型
int 4个字节 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方） 最大值：Integer.MAX_VALUE= 2147483647 （2的31次方-1） 长整型
long 8个字节 二进制位数：64 包装类：java.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid><description>JAVA流程控制语句JAVA中非常重要的基础知识点务必完全理解掌握，总结记录一下之前学习笔记。JAVA流程控制语句是编程的基础知识，主要是为了更好的组织代码的执行流程，下面将详细介绍java流程控制语句。
一、选择结构if if条件语句分为三种格式。
if语句
如果满足某种条件就执行。
if语句格式：
if（条件）{ 语句的执行体 } 条件：结果必须是布尔类型 1==1 true || false 执行体：当id条件为true的时候，执行大括号中的语句，否则什么都不做。
例如：
/** * if语句例子 */ public class IfDemo { public static void main(String[] args) { // TODO Auto-generated method stub int i = 5; if(i==5) { System.out.println(&amp;#34;if中的条件是true&amp;#34;); i++; } System.out.println(&amp;#34;i=&amp;#34;+i); } } 注意：if()括号后面没有分号&amp;quot;;&amp;quot;
if&amp;hellip;else语句
如果满足某种条件，就执行某种处理，否则就执行另一种处理。
if &amp;hellip; else语法格式：
if(条件){ if的执行体 }else{ else的执行体 } 当if中的条件为true时，执行if的执行体，为false时，执行else的执行体。</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>进程：CPU为每个应用程序分配的独立空间，一个进程可能有多个线程。进程为线程中的摸个执行任务程序，多个进程之间可以进行共享数据。而JAVA的线程则是由JVM进程分配的，main方法所在线程，则成为主线程。
〇、线程状态 正常情况线程执行步骤：新建-》运行-》死亡
当CPU资源不够时，CUP分配给各个线程的资源可能不同(貌似有点像是线程在抢资源，实际是CPU分配资源给每个线程)。 因此就会出现线程的阻塞、休眠、等待3个状态。其中阻塞状态，当cpu资源够时，阻塞状态的线程可能恢复到运行状态，而休眠、等待的线程也可能进入运行状态。休眠、等待状态可能转换成阻塞状态，但是阻塞状态不会变成休眠、等待状态。
一、多线程的实现 0、线程常用方法 package learn.javase.threads; /** * 继承Thread创建线程，设置线程名称、获取线程名称 * @author Jole * */ public class ThreadDemo01 { public static void main(String[] args) { MyThreadsDemo mt = new MyThreadsDemo(); mt.setName(&amp;#34;Hi&amp;#34;); mt.start(); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName()); } } 线程实现方式主测试类：
package learn.javase.threads; public class MyThreadsDemo extends Thread{ public MyThreadsDemo() { super(&amp;#34;Google&amp;#34;); } public void run() { for(int i=0;i&amp;lt;5;i++) { try { Thread.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E5%BC%82%E5%B8%B8/</guid><description>异常 Throwable Throwable类是所有错误跟异常类的超类.
Exception Exception异常类及其子类都是继承自Throwable类，用来表示java中可能出现的异常，并且合理的处理这些异常。
RuntimeException RuntimeException类是运行异常类，继承自Exception类，它以及它的子类只能在运行过程中存在，当出现时，只能修改源代码，此异常无法处理。
特点：
　方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常
　运行时期异常一旦发生,需要程序人员修改源代码
Error Error类是与Exception的平级的类，用来表示Java中存在的严重错误，只能通过修改代码来解决问题。
区别 Exception与Error区别：
Exception是指程序在编译或者运行时出现的某种异常问题，我们可以对异常进行某种处理，如果不处理异常的话，程序将会停止运行。
Error是指程序在运行时出现的严重问题，无法处理，程序将会停止运行，Error通常都是系统级别的问题，都是虚拟机jvm所在系统发生的，只能通过修改源代码解决问题。
异常的产生 运行或编译时产生异常。 创建异常类的对象。 声明异常类。 将异常类对象传给调用者（main()方法）处理。 调用者无法处理，再将异常类对象传给jvm虚拟机。 jvm虚拟机将异常类的信息（名称、详细信息、异常所处的位置）打印在屏幕上，并且停止程序的运行。 抛出异常throw 在java中，提供了一个throw关键字，用来抛出一个指定的异常。
使用方法：
1.创建一个异常对象。封装一些提示信息
2.将这个异常告知调用者
使用格式：throw new 异常类名（参数）；
声明异常throws 声明异常格式：
修饰符 返回值类型 方法名称 （参数）throws 异常1名称，异常2名称{
}
捕获异常try&amp;hellip;catch&amp;hellip;finally
捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理
语句格式：
ry { //需要被检测的语句。 }catch(异常类 变量) { //参数。 //异常的处理语句。 }finally { //一定会被执行的语句。 } try：该代码块中编写可能产生异常的代码。
catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。
finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。
捕获异常的组合方式 try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放。 try catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。 一个try 多个catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 try finally 组合: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。 package learn.</description></item><item><title/><link>https://www.yanxizhu.com/posts/java%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/java%E6%95%B0%E7%BB%84/</guid><description>JAVA数组重点掌握知识，以后肯定会用到的，可以了解一下底层原理。数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。
数组 数组定义格式：
数据类型[] 数组名(变量名) = new 数据类型[元素个数或数组长度]; 实例：
public class ArrayDemo01 { public static void main(String[] args) { int[] x = new int[100]; } } 注意：数组定长，一但定义长度为100，在使用时大小就是100了。不变量。
数组特点：定长、引用类型。
JVM java程序运行时，操作系统会给jvm虚拟机分配一块内存。JVM又会将这块内存，进行划分管理。
JVM内存划分：JVM对自己的内存进行了划分，分成5个区域。
1、寄存器：内存和CPU之间。 2、本地方法栈：JVM调用操作系统中的功能。 3、方法和数据共享：运行时其class文件，进入的地方。 4、方法栈：所有的方法运行的时候，进入的内存。 5、堆：存储的是容器和对象。 开发人员主要关心：方法和数据共享、方法栈、堆。
数组内存划分 首先，运行class文件，所以先进入方法区。 运行main方法，在方法栈中运行，但是main用不了那么多，所以方法栈中会分配一块给main方法是用。 执行数组，一个容器，所以JVM在堆内存，开空间，存储数组容器。 JVM会将该地址，给定义的数组变量arr（相当于arr引用了这个地址），所以数组是引用类型。 每次运行，JVM分配的地址是不同的。 当main方法运行完了，arr变量就没了，然后new int[3]也就没了 ，JVM垃圾回收机制，会自动帮我们回收，不用我们去处理了。 堆空间太大，怎么找到这个容器呢，所以每个数组，在内存中，都有自己的内存地址，也就是数组元素的首地址，第一个数据的地址。
注意：arr引用类型，保存的数据，实际上是内存中的地址。
数组元素的访问 数组是一个容器，存储到数组中的每个元素，都有自己的自动编号/下标（专业名词：索引）。
访问数组存储的元素，必须依赖索引。
访问公式：数组名[索引]
public class ArrayDemo02 { public static void main(String[] args) { int[] arr = new int[3]; System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</guid><description>JDK1.8的新特性 一、接口的默认方法 Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：
代码如下：
interface Formula{ double calculate(int a); default double sqrt(int a){ return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下： Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0
文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt（a*100）。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注：在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，Java8的这个在语义上有差别。
二、Lambda表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下：
Listnames=Arrays.asList（&amp;ldquo;peterF&amp;rdquo;，&amp;ldquo;anna&amp;rdquo;，&amp;ldquo;mike&amp;rdquo;，&amp;ldquo;xenia&amp;rdquo;）； Collections.sort（names，new Comparator）{@Override public int compare（String a，String b）{ return b.compareTo（a）；}}）；
只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java8中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式： 代码如下： Collections.sort（names，（String a，String b）-&amp;gt;{return b.compareTo（a）；}）；
看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下： Collections.sort（names，（String a，String b）-&amp;gt;b.compareTo（a）；
对于函数体只有一行代码的，你可以去掉大括号0以及return关键字，但是你还可以写得更短点：
代码如下： Collections.sort（names，（a，b）&amp;gt;b.compareTo（a）；
Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：
三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？
每一个lambda表达式都对应一个类型，通常是接口类型。 而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@Functionallnterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。
示例如下：</description></item><item><title/><link>https://www.yanxizhu.com/posts/k8s%E9%83%A8%E7%BD%B2%E7%BC%96%E6%8E%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/k8s%E9%83%A8%E7%BD%B2%E7%BC%96%E6%8E%92/</guid><description>初识k8s 简介： Kubernetes 简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。 中文官网：https://kubernetes.io/zh/ 中文社区：https://www.kubernetes.org.cn/ 官方文档：https://kubernetes.io/zh/docs/home/ 社区文档：http://docs.kubernetes.org.cn/
部署方式的进化 https://kubernetes.io/zh/docs/concepts/overview/
功能 架构 整体主从方式 Master 节点架构 kube-apiserver 对外暴露K8S 的api 接口，是外界进行资源操作的唯一入口。
提供认证、授权、访问控制、API 注册和发现等机制。
etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes 所有集 群数据的后台数据库。 Kubernetes 集群的etcd 数据库通常需要有个备份计划
kube-scheduler 主节点上的组件，该组件监视那些新创建的未指定运行节点的Pod，并选择节点 让Pod 在上面运行。 所有对k8s 的集群操作，都必须经过主节点进行调度
kube-controller-manager 在主节点上运行控制器的组件 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维 护正确数量的Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入Service 与Pod)。 服务帐户和令牌控制器（Service Account &amp;amp; Token Controllers）: 为新的命名 空间创建默认帐户和API 访问令牌
Node 节点架构 kubelet 一个在集群中每个节点上运行的代理。它保证容器都运行在Pod 中。 负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；
kube-proxy 负责为Service 提供cluster 内部的服务发现和负载均衡；
容器运行环境(Container Runtime) 容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、containerd、cri-o、rktlet 以及任 何实现Kubernetes CRI (容器运行环境接口)。</description></item><item><title/><link>https://www.yanxizhu.com/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</guid><description>最近项目对接时，中间B2B服务切换了域名，导致现有项目调用接口地址需要进行切换为https，同时需要安装SSL证书，这里记录一下JAVA工具keytool导入证书的过程。
一、问题点 切换域名后加上https，未导入证书报错:
[ERROR] - [2022-02-25 08:49:40.861] - [http-nio-9999-exec-1] - [DealParamAction.java:needConfirmAction:133] - no confirm method, call actual method = getNSDDtailByInterface [INFO ] - [2022-02-25 08:50:04.483] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:04.484] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:445] - Retrying request [INFO ] - [2022-02-25 08:50:25.487] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:25.</description></item><item><title/><link>https://www.yanxizhu.com/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>Map集合的2种循环方式。一种是通过map.entrySet()。
另一种是map.keySet()。 所有的集合都可以通过迭代器Iterator，进行遍历。
package learn.javase; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set; /** * 重要 * 遍历map的两种方式map.entrySet() map.keySet() * @author Jole * */ public class MapDemo { public static void main(String[] args) { Map&amp;lt;Integer ,String &amp;gt; map = new HashMap(); map.put(1, &amp;#34;111&amp;#34;); map.put(2, &amp;#34;2222&amp;#34;); //方式一 entrySet() Set&amp;lt;Map.Entry &amp;lt;Integer, String&amp;gt;&amp;gt; sets = map.entrySet(); //获取值1，通过for for(Map.Entry &amp;lt;Integer, String&amp;gt; entry : sets) { System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>maven依赖冲突解决方案 1、找到项目pom文件。
2、快捷键打开依赖图。
ctlr+alt+shift+u 3、红色表示冲突。
4、右键exclude排除。</description></item><item><title/><link>https://www.yanxizhu.com/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>使用maven的好处： 大型项目的好处，建立一个父项目，各组或部门可以模块开发，不用拉取整个项目进行开发。
创建maven项目说明： maven项目结构： Maven常用命令： 1、一键构建项目命令:
mvn tomcat:run 注意：该命令使用的是tomcat插件进行运行的，不需要单独安装配置tomcat。
2、清理编译好后的文件（target文件夹及里面所有的文件）：
mvn clean 3、编译并运行了main里面的代码（只编译main主文件里面的java代码，test里面的java代码不编译不编译）：
mvn compile 4、编译并运行了test里面的代码(只编译test里面的java代码，main里面的java代码不编译)：
mvn test 5、打包，并将包放到tager文件夹下面。打成war或jar名称由POM文件里面的这3个标签值决定： 例如打包成这个名字:HelloWorld-0.0.2-SNAPASHOT.war HelloWorld&amp;ndash;打成包的名字 0.0.2-SNAPASHOT&amp;ndash;版本 war&amp;ndash;什么类型的包
mvn package 6、把项目发布到本地仓库
mvn install 同时运行了mvn compile、mvn test、mvn package、mvn install、mvn deploy命令。
7、jar或war包发布到私服上
mvn deploy maven生命周期有三种： 1、clean生命周期：clean 2、default生命周期：compile、test、package、install、deploy命令 3、site生命周期:site(生成项目的文档说明)
不同的生命周期，命令可以同时运行。
maven依赖范围： complie
provided:编译（complie）时需要、测试时也需要、运行时不需要，打包时不需要
runtime：例如：数据库驱动包
test：编译时不需要，测试时需要、运行时不需要
maven添加插件： 常见问题： 出现该提示表示jdk安装有问题，重新安装即可。
maven整体模型也就是上面说的内容： 版本冲突解决原则：
1、路径近者原则（比如2个坐标中有不同版本的相同的jar包，自己在加入要使用的版本的这个名称的坐标）
2、第一声明有限原则（比如2个坐标，谁排在pom.xml文件的前面就用谁的）
3、排除原则.（将名字和组织加入到exclusion中） 4、版本锁定 谁先传递锁定的版本，就用这个。 可以同时锁定多个版本
锁定版本里面使用${sprint.verion}注意上面锁定了，坐标里面的version就没有了，可以去除，就算不去除也没有了。</description></item><item><title/><link>https://www.yanxizhu.com/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</guid><description>&lt;p>第一步骤：下载nexus私服软件nexus-2.12.0-01-bundle&lt;/p>
&lt;p>第二不：安装&lt;/p>
&lt;p>进入nexus解压目录进入到bin目录:&lt;/p>
&lt;p>1、安装:执行nexus.bat install&lt;/p>
&lt;p>2、启动:nexus.bat start&lt;/p>
&lt;p>第三步：查看访问路径&lt;/p>
&lt;p>进入config目录，打开nexus.properties即可看到端口号，项目命令nexus。&lt;/p>
&lt;p>第四步：浏览器打开http://127.0.0.1:8081/nexus/&lt;/p>
&lt;p>默认登录账号:admin/admin123&lt;/p></description></item><item><title/><link>https://www.yanxizhu.com/posts/nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>Nginx反向代理微服务配置 一、本地域名服务访问过程 二、正向代理和反向代理 三、Nginx+Windows搭建域名访问环境 1、修改C:\Windows\System32\drivers\etc下hosts文件，映射本地域名和192.168.56.10ip关系。 每次通过记事本修改很麻烦，可以通过SwitchHosts软件修改。
192.168.56.10 family.com 2、现在就可以通过family.com域名访问了。 想要访问部署在服务器上的其它端口应用也可以通过域名访问，比如：搭建的kibana是5601端口，通过域名http://family.com:5601/即可访问了(kibana时部署在56.10服务器上的)
四、nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39; &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39; &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.</description></item><item><title/><link>https://www.yanxizhu.com/posts/openfeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/openfeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>openFeign远程调用丢失请求头
feign在远程调用之前要构造请求，调用会经过很多拦截器。丢失请求头原因，是远程调用重新构建了request请求，新的request没有请求头headr。
解决方案：定义一个feign的拦截器
先来看一下feign远程调用类SynchronousMethodHandler
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package feign; import feign.InvocationHandlerFactory.MethodHandler; import feign.Logger.Level; import feign.Request.Options; import feign.codec.Decoder; import feign.codec.ErrorDecoder; import java.io.IOException; import java.util.Iterator; import java.util.List; import java.util.concurrent.CompletableFuture; import java.util.concurrent.CompletionException; import java.util.concurrent.TimeUnit; import java.util.stream.Stream; final class SynchronousMethodHandler implements MethodHandler { private static final long MAX_RESPONSE_BUFFER_SIZE = 8192L; private final MethodMetadata metadata; private final Target&amp;lt;?</description></item><item><title/><link>https://www.yanxizhu.com/posts/rabbitmqy%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/rabbitmqy%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid><description>RabbitMQ运行机制 AMQP 中的消息路由
AMQP 中消息的路由过程和 Java 开 发者熟悉的 JMS 存在一些差别， AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布 到 Exchange 上，消息最终到达队列 并被消费者接收，而 Binding 决定交 换器的消息应该发送到那个队列
Exchange 类型 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、 fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接 看另外三种类型：
Direct Exchange
消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器 就将消息发到对应的队列中。路由键与队 列名完全匹配，如果一个队列绑定到交换 机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发 “dog.puppy”，也不会转发“dog.guard” 等等。它是完全匹配、单播的模式
Fanout Exchange
每个发到 fanout 类型交换器的消息都 会分到所有绑定的队列上去。fanout 交 换器不处理路由键，只是简单的将队列 绑定到交换器上，每个发送到交换器的 消息都会被转发到与该交换器绑定的所 有队列上。很像子网广播，每台子网内 的主机都获得了一份复制的消息。 fanout 类型转发消息是最快的</description></item><item><title/><link>https://www.yanxizhu.com/posts/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>RabbitMQ延时队列（实现定时任务） 场景： 比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 常用解决方案： spring的 schedule 定时任务轮询数据库 缺点： 消耗系统内存、增加了数据库的压力、存在较大的时间误差 解决：rabbitmq的消息TTL和死信Exchange结合
消息的TTL（Time To Live)
• 消息的TTL就是消息的存活时间。 • RabbitMQ可以对队列和消息分别设置TTL。 • 对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的 设置。超过了这个时间，我们认为这个消息就死了，称之为死信。 • 如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队 列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的 TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者x- message-ttl属性来设置时间，两者是一样的效果。
Dead Letter Exchanges（DLX）
• 一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信） • 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不 会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false • 上面的消息的TTL到了，消息过期了。 • 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上 • Dead Letter Exchange其实就是一种普通的exchange，和创建其他 exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。 • 我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列
• 手动ack&amp;amp;异常消息统一放在一个队列处理建议的两种方式 • catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费 • 给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败
延时队列实现
SpringBoot中使用延时队列 • 1、Queue、Exchange、Binding可以@Bean进去 • 2、监听消息的方法可以有三种参数（不分数量，顺序） • Object content, Message message, Channel channel • 3、channel可以用来拒绝消息，否则自动ack；</description></item><item><title/><link>https://www.yanxizhu.com/posts/scannerrandom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/scannerrandom/</guid><description>Java的两个引用输入类型Scanner、Random类，Scanner用于接收键盘输入，Random用户产生随机数。引用类型也就是Sun公司为我们写好的类，我们直接使用就可以了。
1、引用数据类型的使用 导入包：知道用的这个类，在jdk的那个目录那个文件下。 创建对象：格式， 类 对象 = new 类型(); 如何使用: 对象.类的方法() 引用数据类型的使用与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式，如下：
数据类型 变量名 = new 数据类型(); 每种引用数据类型都有其方法，我们可以调用该类型实例的方法。
变量名.方法名(); 2、Scanner类 Scanner类是引用数据类型的一种，我们可以使用该类来完成用户键盘录入，获取到录入的数据。
导包
import java.util.Scanner; 创建对象实例
Scanner sc = new Scanner(System.in); 调用方法
//用来接收控制台录入的数字 int i = sc.nextInt(); //用来接收控制台录入的字符串 String s = sc.next(); Scanner使用Demo：
package java_learn_code; //导入包，指明类所在的的文件见，关键字import import java.util.Scanner; /** * 引用数据类型,使用步骤：1、导入包 。2、创建对象 3、通过对象调用方法 * @author Jole * Scanner的使用，所在目录java文件见-util文件夹 */ public class ScannerDemo { public static void main(String[] args) { System.</description></item><item><title/><link>https://www.yanxizhu.com/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</guid><description>首先知道Shiro架构有3个主要概念：Subject、SecurityManager和Realms。
Shiro基础架构图 ：
基础架构说明： Subject: As we’ve mentioned in our Tutorial, the Subject is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a Subject can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software. Subject instances are all bound to (and require) a SecurityManager.</description></item><item><title/><link>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description>通过Java Socket编程，实现多线程文件上传。主要涉及ServerScoket服务端、Socket客户端、IO流操作、多线线程。
客户端：
package learn.javase.Update; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; /** * 利用TCP的Socket\ServerSocket客户端向服务器上传文件 * 客户端 * @author Jole * */ public class UpClent { public static void main(String[] args) throws IOException{ Socket socket = new Socket(&amp;#34;127.0.0.1&amp;#34;,8888); OutputStream out = socket.getOutputStream(); //读取本地文件，并通过out输出流，发送给服务端 File file = new File(&amp;#34;J:&amp;#34;+File.separator+&amp;#34;wxhandbook-master.zip&amp;#34;); FileInputStream in = new FileInputStream(file); byte[] data = new byte[1024]; int len =0; while((len=in.</description></item><item><title/><link>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</guid><description>通过Socket网络编程，UDP实现简单聊天。主要涉及DatagramSocket进行数据传输、DatagramPacket进行数据包封装，2个类。
发送端:
package learn.javase.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; /** * 控制台输入；实现聊天。 * 发送方 * @author Jole * */ public class UdpSend { public static void main(String[] args) throws Exception{ Scanner scan = new Scanner(System.in); InetAddress ia = InetAddress.getByName(&amp;#34;192.168.1.4&amp;#34;); DatagramSocket socket = new DatagramSocket(); while(true) { String chatInfo = scan.nextLine(); byte[] info = chatInfo.getBytes(); DatagramPacket pack = new DatagramPacket(info, info.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>Springboot同一Server类方法调用事务解决方案 1、引入springboot-aop start &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 主要是使用里面的动态代理
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.7&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 2、开启动态代理 @EnableAspectJAutoProxy(exposeProxy = true) @EnableDiscoveryClient @SpringBootApplication public class FamilyBookingApplication { public static void main(String[] args) { SpringApplication.run(FamilyBookingApplication.class, args); } } @EnableAspectJAutoProxy(exposeProxy = true)：
开启aspectj动态代理功能。以后所有的动态代理都是aspectj对象暴露代理对象。
3、本类互调用代理对象调用 @Service(&amp;#34;userService&amp;#34;) public class UserServiceImpl implements userService { @Transactional public void a(){ UserService userService = (UserService)AopContext.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/</guid><description>Springboot拦截器配置
1、拦截器配置，主要实现HandlerInterceptor接口 import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @description: 拦截器，配合FamilyWebConfig 配置使用 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/10 22:36 * @version: 1.0 */ @Component public class LoginUserInterceptor implements HandlerInterceptor { public static ThreadLocal&amp;lt;Object&amp;gt; objUser = new ThreadLocal&amp;lt;&amp;gt;(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object loginusr = request.getSession().getAttribute(&amp;#34;LOGIN_USR&amp;#34;); if(loginusr != null){ objUser.set(loginusr); //登录了才能访问 return true; }else{ //没登录，跳转去登录 return false; } } } 由于拦截器需要配合web配置使用，因此创建web配置。</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88mq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88mq/</guid><description>SpringBoot整合RabbitMQ 1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2、配置rabbitmq 通过RabbitProperties.properties配置文件配置链接
rabbitmq: host: 192.168.56.10 virtual-host: / port: 5672 publisher-confirm-type: correlated publisher-returns: true template: mandatory: true 重点： publisher-confirm-type: correlated开启发送端确认机制，发送到Broke的确认
publisher-returns: true：开启时消息发送到队列的消息确认机制
template: mandatory: true：只要抵达队列，以异步发送优先回调我们这个Returnconfirm
3、开启Rabbit 启动类添加@EnableRabbit注解
@EnableRabbit @SpringBootApplication public class FamilyBookingApplication { public static void main(String[] args) { SpringApplication.run(FamilyBookingApplication.class, args); } } 4、Rabbit使用 现在RabbitAutoConfiguration就生效了，就有了组件RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate
5、使用测试 1、创建Exchange、Queue、Binding 使用AmqpAdmin创建。</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88quartz-scheduler%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88quartz-scheduler%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>SpringBoot整合定时任务和异步任务 一、定时任务 SpringBoot整合quartz-scheduler，执行定时任务。
1、开启定时任务 @EnableScheduling 2、开启一个定时任务 @Scheduled 3、编写cron表达式 cron表达式格式请参考官方文档
4、实例 package com.yanxizhu.ifamily.booking.controller.scheduler; import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * SpringBoot整合Scheduling定时任务 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/15 20:26 * @version: 1.0 */ @Slf4j @Component @EnableScheduling public class MyScheduler { /** * cron表达式 */ @Scheduled(cron = &amp;#34;1/3 1/1 * * * ? &amp;#34;) public void sayHell(){ log.info(&amp;#34;Hello&amp;#34;); } } 5、定时任务总结 1、@EnableScheduling 开启一个定时任务</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88redis/</guid><description>适合当如缓存场景： 即时性、数据一致性要求不高的。 访问量大且更新频率不高的数据(读多，写少) 承担持久化工作。
读模式缓存使用流程: 凡是放入缓存中的数据，我们应该指定过期时间，使其可以再系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。
解决分布式缓存中本地缓存导致数据不一致问题，可以使用redis中间件解决。
springboot整合redis 1、引入springboot整合的start：pom文件引入依赖
&amp;lt;!--redis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 引入依赖之后就会有RedisAutoConfiguration，里面可以看的到redis的配置文件Redis.Properties.
@Configuration( proxyBeanMethods = false ) @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&amp;#34;redisTemplate&amp;#34;} ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid><description>Springboot整合seata分布式事务 一、创建seata日志表 -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 二、安装事务协调器（seata-server） 1、下载地址</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88sentinel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88sentinel/</guid><description>SpringBoot整合Sentinel 1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2、下载安装Sentinel可视化控制台 下载自己引入sentinel对应的核心包版本，下载地址：https://github.com/alibaba/Sentinel/releases
运行Sentinel可视化控制台
java -jar sentinel-dashboard-1.8.1.jar 注意自己的版本。
打开http://127.0.0.1:8080/，默认账号密码sentinel
3、微服务配置sentinel application.yml
spring: cloud: sentinel: transport: port: 8719 dashboard: localhost:8080 port: 8719端口随意，只要不被占用，用于各微服务与控制台通讯。
4、查看监控信息 启动微服务，随意访问一个接口，Sentinel控制台即可看到实施监控信息。
5、启用相关功能 可在Sentinel控制台调整相应功能。默认所有流控设置都是保存在内存中，重启服务就没有了。
6、添加监控图标 引入审计start，sentinel会自动根据spring-boot-starter-actuator监控。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 开启监控图标
management.endpoints.web.exposure.include=* 7、自定义流控返回提示信息 import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.alibaba.fastjson.JSON; import com.yanxizhu.common.utils.R; import org.springframework.context.annotation.Configuration; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @description: Sentinel流控信息提示自定i * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88sleuth+zipkin-%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88sleuth+zipkin-%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</guid><description>SpringBoot整合Sleuth+Zipkin 服务链路追踪 一、整合 Sleu 1、服务提供者与消费者导入依赖 &amp;lt;!--整合 Sleut:服务提供者与消费者导入依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2、打开 debug 日志 logging: level: org.springframework.cloud.openfeign: debug org.springframework.cloud.sleuth: debug 3、发起一次远程调用，观察控制台 DEBUG [user-service,541450f08573fff5,541450f08573fff5,false] user-service：服务名
541450f08573fff5：是 TranceId，一条链路中，只有一个 TranceId
541450f08573fff5：是 spanId，链路中的基本工作单元 id
false：表示是否将数据输出到其他服务，true 则会把信息输出到其他可视化的服务上观察
二、整合 zipkin 可视化观察 1、docker 安装 zipkin 服务器 docker run -d -p 9411:9411 openzipkin/zipkin 设置随docker启动
docker update --restart=always 容器名称 2、导入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.8.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 因为spring-cloud-starter-zipkin中引入了spring-cloud-starter-sleuth，因此上面的spring-cloud-starter-sleuth可以不用引入。
3、添加 zipkin 相关配置 spring: application: name: ifamily-booking zipkin: base-url: http://127.</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88springsession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%95%B4%E5%90%88springsession/</guid><description>springboot整合SpringSession
1、引入依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2、springboot配置 application.properties配置：保存类型
spring.session.store-type=redis # Session store type. session过期时间：
server.servlet.session.timeout= # Session timeout. If a duration suffix is not specified, seconds is used. 其它配置信息可参考官网：
spring.session.redis.flush-mode=on_save # Sessions flush mode. spring.session.redis.namespace=spring:session # Namespace for keys used to store sessions. 连接信息配置：
spring.redis.host=localhost # Redis server host. spring.redis.password= # Login password of the redis server. spring.redis.port=6379 # Redis server port. 3、开启springSession 主类加上注解@EnableRedisHttpSession</description></item><item><title/><link>https://www.yanxizhu.com/posts/springboot%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/springboot%E6%B3%A8%E8%A7%A3/</guid><description>SpringBoot注解 某个对象创建完成后，执行这个方法
@PostConstruct</description></item><item><title/><link>https://www.yanxizhu.com/posts/ssh%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/ssh%E5%88%9B%E5%BB%BA/</guid><description>1. 设置Git用user name和email git config --global user.name &amp;#34;XXX&amp;#34; git config --global user.email &amp;#34;XXX@gmail.com&amp;#34; 2. 生成密钥 ssh-keygen -t rsa -C &amp;#34;XXX@gmail.com&amp;#34; 中间连续3次Enter键.
3. 测试SSH key是否设置成功 ssh -T git@github.com 出现下面提示直接输入yes.
The authenticity of host &amp;#39;github.com (192.30.253.113)&amp;#39; can&amp;#39;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes 输出如下，则表示通过.
Hi xxxx! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access. 使用时，会根据本地git密钥信息与git或者coding仓库密钥信息比对，本地上传时会提示登录。</description></item><item><title/><link>https://www.yanxizhu.com/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Typora最后免费版本下载
Typora收费后，开始保留最后一个免费版本Version0.11.18(beta)，欢迎食用。
阿里网盘：
「typora-update-x64-1117.exe」https://www.aliyundrive.com/s/Xez1W6kvWZv 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。
百度网盘：
链接：https://pan.baidu.com/s/1zaaqxIv99xX98Qemw9tLrw 提取码：utq4
天翼网盘:
https://cloud.189.cn/t/3yEJbavmieye (访问码:1oov)</description></item><item><title/><link>https://www.yanxizhu.com/posts/virtualbox%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/virtualbox%E5%AE%89%E8%A3%85/</guid><description>一、virtualbox安装 1、下载 https://www.virtualbox.org/
2、在主板开启CPU虚拟化，自行百度
3、安装，直接下一步，选择安装路径。
二、安装虚拟机 1、下载虚拟系统CentOS7
https://app.vagrantup.com/boxes/search Vagrant官方镜像仓库
https://www.vagrantup.com/ Vagrant下载
2、初始化虚拟系统
打开安装好的virtualbox软件，打开window cmd窗口，运行下面命令，即可初始化一个CentOS7系统。初始化之后window用户文件夹夹会多出一个Vagrantfile文件。此时virtualbox界面就会多出一个CentOS系统了。
Vagrant init centos/7 3、启动虚拟机，初始root用户密码vagrant，此时看到virtualbox中的CentOS正在启动。
vagrant up 4、vagrant其他命令
使用vagrant用户链接至CentOS虚拟机，初始root用户密码vagrant。
vagrant ssh 上传文件
vagrant upload source [destination][name][id] 更多命令可以访问官网文档
5、设置固定ip，默认虚拟机ip是随机的，方式1-修改Vagrantfile，方式2-进入linx系统修改网卡配置信息
config.vm.network &amp;#34;private_network&amp;#34;,ip:&amp;#34;192.168.10.1&amp;#34; 6、重启虚拟机
vagrant reload 7、启动，除了上面的3启动虚拟机，也可以在virtualbox界面选择虚拟机右键开启。
8、virtualbox界面还可以设置虚拟机内存大小等信息，更多设置可以查看官网。</description></item><item><title/><link>https://www.yanxizhu.com/posts/vue%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/vue%E5%AD%A6%E4%B9%A0/</guid><description>一、vue的基本使用 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;vue的基本使用&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!-- 模板语法--插值{{}} --&amp;gt; &amp;lt;!-- 优先加载template里面的内容，如果为空也加载#app，在加载#app --&amp;gt; &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;./node_modules/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { msg: &amp;#39;黄瓜&amp;#39; }, template: &amp;#39;&amp;lt;div&amp;gt;&amp;lt;h5&amp;gt;{{msg}}&amp;lt;/h5&amp;gt;&amp;lt;/div&amp;gt;&amp;#39; }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 二、vue指令 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;vue指令&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .box{ width: 300px; height: 300px; background-color: red; } .</description></item><item><title/><link>https://www.yanxizhu.com/posts/widnows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/widnows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Widnows常用命令 查看所有端口号情况
netstat -ano 搜索查看指定端口
netstat -ano|findstr 端口号 查看所有程序占用端口信息
tasklist 搜索指定端口被那个程序占用
tasklist|findstr 端口号</description></item><item><title/><link>https://www.yanxizhu.com/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Xshell 7、Xftp 7免费版本下载，官网每次下载懒得找，懒得注册，这里提供官网原版下载，官网下载地址
https://www.xshell.com/zh/free-for-home-school/
阿里网盘：
https://www.aliyundrive.com/s/ZV2jMWP4Fsr
百度网盘：
链接：https://pan.baidu.com/s/13Hx_HYbZFC4BGW56IlOdqA 提取码：xb2e
天翼网盘：
https://cloud.189.cn/t/ueABVvANryMn (访问码:w2se)
https://cloud.189.cn/t/Yjymuu3EF3Az (访问码:7it5)</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%88%9D%E8%AF%86rabbitmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%88%9D%E8%AF%86rabbitmq/</guid><description>RabbitMQ作用 异步处理、应用解耦、流量控制
概述 1、大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力
2、消息服务中两个重要概念：
消息代理（message broker）和目的地（destination） 当消息发送者发送 消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。
3、消息队列主要有两种形式的目的地
​ 3.1、队列（queue）：点对点消息通信（point-to-point）
​ 3.2、主题（topic）：发布（publish）/订阅（subscribe）消息通信
4、点对点式：
​ 4.1、消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获 取消息内容，消息读取后被移出队列
​ 4.2、消息只有唯一的发送者和接受者，但并不是说只能有一个接收者
5、发布订阅式：
​ 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个 主题，那么就会在消息到达时同时收到消息
6、JMS（Java Message Service）JAVA消息服务：
​ 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现
7、AMQP（Advanced Message Queuing Protocol）
​ 7.1、高级消息队列协议，也是一个消息代理的规范，兼容JMS
​ 7.2、RabbitMQ是AMQP的实现
8、Spring支持
​ 8.1、spring-jms提供了对JMS的支持
​ 8.2、spring-rabbit提供了对AMQP的支持
​ 8.3、需要ConnectionFactory的实现来连接消息代理
​ 8.4、提供JmsTemplate、RabbitTemplate来发送消息
​ 8.5、@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息 代理发布的消息
​ 8.6、@EnableJms、@EnableRabbit开启支持
9、Spring Boot自动配置
​ 9.1、JmsAutoConfiguration
​ 9.2、RabbitAutoConfiguration
10、市面的MQ产品
​ ActiveMQ、RabbitMQ、RocketMQ、Kafk
RabbitMQ概念 RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现
核心概念 Message
消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成， 这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可 能需要持久性存储）等。</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>博客一直使用firekylin搭建，最近看着typecho活跃度还可以，于是本周末用docker重新搭建了博客。
一、环境说明 操作系统：CentOS7.6
技术：Docker、MySQL、PHP、Nginx
使用工具：Xftp 7、Xshell 7、Notepad++
博客系统：Typecho
二、安装步骤 Docker环境搭建 Docker安装MySQL Docker安装PHP Docker安装Nginx 三、遇到问题 安装mysql、php、nginx时，映射文件路径错误，导致安装好后，找不到文件。
Nginx配置时映射路径错误、80端口自动转发443端口，导致http访问一直追加路径。
证书路径放置错误。
Typecho初始化安装时，提示&amp;quot;对不起，无法连接数据库，请先检查数据库配置再继续进行安装&amp;quot;。
四、解决方案 通过docker log 容器，查看日志，一步步解决。 添加异常提示代码：, $e-&amp;gt;getMessage() instal.php第56行，添加ob_start(); ip地址错误，默认localhost，docker安装时，需要改成公网ip或局域网ip。 未创建typecho数据库。 Nginx配置文件:
server { listen 443 ssl http2 reuseport; server_name yanxizhu.com www.yanxizhu.com; root /var/www/html/yanxizhu.com; index index.php; ssl on; ssl_certificate /etc/nginx/conf.d/自己证书.crt; ssl_certificate_key /etc/nginx/conf.</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>循环依赖解决方案
1、查看日志，是哪个地方提示循环依赖。
2、取消自动注入
3、通过容器获取
4、构造方法赋值
例如：
public class MyRabbitConfig { //取消自动注入 // @Autowired RabbitTemplate rabbitTemplate; //通过构造解决循环依赖。(RabbitTemplate rabbitTemplate)：是从springboot容器自动注入的 public MyRabbitConfig(RabbitTemplate rabbitTemplate){ this.rabbitTemplate=rabbitTemplate; }</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid><description>一、创建仓库 注意：仓库名称、路径、选择语言、添加.gitignore、添加开源许可证、选择分支模型。
二、拉取项目 三、创建微服务模块-记账管理微服务 选择微服务必要组件
创建好第一个记账微服务后，项目结构。
然后安装上述步骤，依次创建出其它微服务模块。
各微服务共同点：
1、都导入了必备的spring web，OpenFeign
2、每一个服务，包名：com.yanxizhu.ifamily.xxxxx(booking/firend/。。。服务名)
3、模块名:ifamily-xxxxx(booking/fired/&amp;hellip;&amp;hellip;.服务名)
实例的包名：com.yanxizhu.ifamily.booking
模块名：ifamily-booking
四、设置总项目聚合各微服务 一、随便复制一个微服务的pom文件，粘贴到总项目中。
本次项目，如，复制ifamily-booking微服务中的pom.xml到总项目ifamily中。
二、修改总项目中的pom.xml文件。
1、修改模块名、项目名、描述
修改前：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily-booking&amp;lt;/artifactId&amp;gt;&amp;lt;!--1、模块名修改为总项目名--&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily-booking&amp;lt;/name&amp;gt;&amp;lt;!--2、修改为总项目名--&amp;gt; &amp;lt;description&amp;gt;家庭管理-记账服务&amp;lt;/description&amp;gt;&amp;lt;!--3、修改为聚合服务，把其它微服务聚合起来--&amp;gt; 修改后：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;聚合服务&amp;lt;/description&amp;gt; 2、删除服务依赖
&amp;lt;parent&amp;gt;&amp;lt;!--删除父引用--&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.4&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; 3、删除多余的依赖：
4、添加类型，为pom
&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; 5、聚合其他微服务模块
&amp;lt;modules&amp;gt;&amp;lt;!--聚合其他微服务--&amp;gt; &amp;lt;module&amp;gt;ifamily-booking&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; 最终的pom文件内容如下：</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</guid><description>1、 RabbitMQ Simulator RabbitMQ模拟器，可用于模拟MQ消息的收发消费情况。使用下面的绘图区域来表示您的消息传递拓扑。 将消息元素从左侧的工具箱拖到画布上。 要连接节点，请按住 ALT 键（或 SHIFT 键）并从源节点拖动以将其连接到目标节点。 官网地址 http://tryrabbitmq.com
2、 draw.io draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等 官网地址 http://draw.io
3、 PuTTY PuTTY 是一个 SSH 和 telnet 客户端，最初由 Simon Tatham 为 Windows 平台开发。 PuTTY 是开源软件，提供源代码，由一群志愿者开发和支持。 官网地址 https://www.putty.org/
4、 WinSCP WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。 官网地址 https://winscp.net
5、 FastStone Capture FastStone Capture 是一款功能强大、轻巧但功能齐全的截图工具和屏幕录像机以及编辑共计。编辑工具包括注释（文本、箭头线、高光）、调整大小、裁剪、锐化、水印、应用边缘效果等等。其他功能包括图像扫描、全局热键、自动文件名生成、支持外部编辑器、颜色选择器、屏幕放大镜、屏幕十字准线和屏幕标尺等功能。 官网地址 https://www.faststone.org
6、 potplayer 一款功能强大、界面美观、简洁的视频播放器。 官网地址 https://potplayer.daum.net
7、 notepad++ Notepad++ 是一个免费的（如“言论自由”和“免费啤酒”）源代码编辑器和支持多种语言的记事本替代品。 在 MS Windows 环境中运行，其使用受 GNU 通用公共许可证管理。 官网地址 https://notepad-plus-plus.</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</guid><description>接口幂等性 1、什么是幂等性 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用；比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条&amp;hellip;，这就没有保证接口的幂等性。
2、哪些情况需要防止 用户多次点击按钮 用户页面回退再次提交 微服务互相调用，由于网络问题，导致请求失败。feign触发重试机制其他业务情况
3、什么情况下需要幂等 天然幂等的：以SQL为例，有些操作是。
SELECT*FROM table WHERid=？ 无论执行多少次都不会改变状态，是天然的幂等。
UPDATE tab1 SET col1=1WHERE col2=2 无论执行成功多少次状态都是一致的，也是幂等操作。
delete from user where userid=1 多次操作，结果一样，具备幂等性
insert into user（userid，name）values（1，a） 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。
不是幂等的
UPDATE tab1 SET col1=col1+1WHERE col2=2 每次执行的结果都会发生变化，不是幂等的。
insert into user（userid，name）values（1，a） 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。
4、幂等解决方案 一、token机制 1、服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。
2、然后调用业务接口请求时，把token携带过去，一般放在请求头部。 3、服务器判断token是否存在redis中，存在表示第一次请求，然后删除token，继续执行业务。
4、如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。
危险性： 1、先删除token 还是后删除token； （1）先删除可能导致，业务确实没有执行，重试还带上之前token，由于防重设计导致，请求还是不能执行。 （2）后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别人继续重试，导致业务被执行两边 （3）我们最好设计为先删除token，如果业务调用失败，就重新获取token 再次请求。 2、Token获取、比较和删除必须是原子性 （1）redis.get（token）、token.equals、redis.delltoken）如果这两个操作不是原子，可能导致，高并发下，都get 到同样的数据，判断都成功，继续业务并发执行
（2）可以在redis 使用lua脚本完成这个操作
if redis. call(&amp;#34;get&amp;#39;, KEYS[1])==ARGV[1] then return redis. call(&amp;#39; del&amp;#34;, KEYS[1]) else return 0 end 二、各种锁机制 1、数据库悲观锁</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</guid><description>create a new repository on the command line. push an existing repository from the command line. import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project.
create a new repository on the command line git init git add README.md git commit -m &amp;#34;first commit&amp;#34; git branch -M main git remote add origin https://github.com/willxwu/xxx.git git push -u origin main push an existing repository from the command line git remote add origin https://github.</description></item><item><title/><link>https://www.yanxizhu.com/posts/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</guid><description>异步与线程池 1、初始化线程的4种方式 1）、继承Thread 2）、实现Runnable接口 3）、实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常） 4）、线程池
方式1和方式2：主进程无法获取线程的运算结果。不适合当前场景。
方式3：主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。 方式4：通过如下两种方式初始化线程池
Executors.newFiexed ThreadPool(3); //或者 new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,TimeUnit unit, workQueue,threadFactory,handler); 方式1、继续Thread /** * @description: 继承Thread * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/10 21:06 * @version: 1.0 */ public class MyThread { public static void main(String[] args) { System.out.println(&amp;#34;启动main方法开始&amp;#34;); OneMyThread oneMyThread = new OneMyThread(); oneMyThread.start(); System.out.println(&amp;#34;结束main方法&amp;#34;); } public static class OneMyThread extends Thread{ @Override public void run() { System.</description></item></channel></rss>