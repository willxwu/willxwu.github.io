<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on willxwu</title><link>https://willxwu.github.io/posts/</link><description>Recent content in Posts on willxwu</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 28 Sep 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker安装</title><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85/</guid><description>一、环境准备 备份原yum 源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup CentOS设置新yum 源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 使用阿里云Docker Yum源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 生成缓存
yum makecache 卸载旧版本Docker
yum remove docker docker-common docker-selinux 二、安装Docker CE 安装需要的依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2 安装
yum install docker-ce -y 启动docker
sudo systemctl start docker 设置开机启动
sudo systemctl enable docker 配置Docker 镜像加速
mkdir -p /etc/docker 在新建目录下新建daemon.json，内容如下:
{ &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://bpavu6gm.mirror.aliyuncs.com&amp;#34;] } 重新加载配置文件
systemctl daemon-reload 重启docker
systemctl restart docker</description></item><item><title>Docker安装PHP</title><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85php/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85php/</guid><description>Docker安装PHP 拉取PHP镜像
docker pull php:7.4-fpm 运输PHP容器
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 进入PHP容器
docker exec -it php /bin/bash PHP扩展安装(非必须)
docker-php-ext-install pdo_mysql 设置随Docke启动
docker update --restart=always php 注意：自己映射路径/mydata/nginx/html。</description></item><item><title>Docker安装RabbitMQ</title><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85rabbitmq/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85rabbitmq/</guid><description>Docker安装RabbitMQ 运行RabbitMQ容器 第一次运行没有RabbitMQ镜像，会自动下载。
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management 说明：
4369, 25672 (Erlang发现&amp;amp;集群端口) 5672, 5671 (AMQP端口) 15672 (web管理后台端口) 61613, 61614 (STOMP协议端口) 1883, 8883 (MQTT协议端口) https://www.rabbitmq.com/networking.html
设置随docker启动 docker update --restart=always rabbitmq 访问RabbitMQ 通过ip地址加15672端口即可访问，初始账号密码guest</description></item><item><title>docker安装redis</title><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85redis/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85redis/</guid><description>docker安装redis 一、docker拉取redis镜像 docker pull redis 二、创建实例并启动 创建映射配置文件路径
mkdir -p /mydata/redis/conf touch /mydata/redis/conf/redis.conf 创建启动
docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \ -d redis redis-server /etc/redis/redis.conf redis 自描述文件： https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf
三、使用redis 镜像执行redis-cli 命令连接 docker exec -it redis redis-cli 四、设置随docker启动redis自动启动 docker update --restart=always redis 更多配置，请参考redis官网文档，https://redis.io/documentation。</description></item><item><title>Docker常用命令</title><link>https://willxwu.github.io/posts/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>一、镜像 查看docker容器镜像
docker images 拉去容器镜像
docker pull 容器 删除容器镜像
docker rmi 容器 二、容器 安装容器，-d后台运行，-v映射路径, -name容器名称, -link链接外部容器，-p 端口号映射，-e设置密码
docker run -d -v /mydata/nginx/html:/var/www/html -p 9000:9000 --link mysql:mysql --name php php:7.4-fpm 启动容器
docker start 容器 关闭容器
docker stop 容器 重启容器
docker restart 容器 查看运行容器
docker ps 查看所有容器
docker ps -s 删除容器
docker rm 容器 查询当前容器
docker container ls -all 删除未启动容器映射
docker container rm 容器 查看容器映射信息
docker inspect 容器 | grep Mounts -A 20 进入容器内部</description></item><item><title/><link>https://willxwu.github.io/posts/1%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/1%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE/</guid><description>Oracle 权限、视图、约束 一、数据库权限 1、查看用户所属角色 select * from user_role_privs; 2、查询角色权限 CONNECT：仅连接权限
select * from dba_sys_privs where grantee=&amp;#39;CONNECT&amp;#39; 查看RESOURCE权限：
select * from dba_sys_privs where grantee=&amp;#39;RESOURCE&amp;#39; DBA角色权限查看
select * from dba_sys_privs where grantee=&amp;#39;DBA&amp;#39; 3、用户授权 例如：授予scoot拥有dba的权限
grant dba to scott; 二、视图 1、创建视图 Create view 视图名称as 查询语句 create view v_emp1 as select ename,job from emp; 2、修改视图 create or replace view 始图名称 as 新的查询数据； create or replace view vemp as select empno,ename,job from EMP t; 注意与创建视图的不同：多了一个or replace</description></item><item><title/><link>https://willxwu.github.io/posts/atomic%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/atomic%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.atomic.AtomicInteger; /** * @description: Atomic使用 * @date: 2022/3/19 10:14 * @version: 1.0 */ public class AtomicDemo { public static void main(String[] args) { ////通过synchronized、volatile实现 // demo demo = new demo(); // for(int i=0;i&amp;lt;10;i++){ // new Thread(demo).start(); // } //使用AtomicInteger实现 demo2 demo = new demo2(); for(int i=0;i&amp;lt;10;i++){ new Thread(demo).start(); } } //通过synchronized、volatile实现 public static class demo implements Runnable{ private volatile int num=0; @Override public void run() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.</description></item><item><title/><link>https://willxwu.github.io/posts/cenotos%E7%8E%AF%E5%A2%83nacos%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/cenotos%E7%8E%AF%E5%A2%83nacos%E5%AE%89%E8%A3%85/</guid><description>CenotOS环境Nacos安装，设置开机自启动 1、下载 nacos下载地址：https://github.com/alibaba/nacos/releases
2、安装 进入nacos所在目录，执行如下命令
tar -zxvf nacos-server-2.0.3.tar.gz -C /usr/local/ 3、单机启动 修改/usr/local/nacos/bin目录下startup.sh启动文件设置单机启动，修改export MODE=&amp;ldquo;cluster&amp;quot;值为standalone
export MODE=&amp;#34;standalone&amp;#34; 4、启动测试 进入/usr/local/nacos/bin目录下，执行启动命令
./startup.sh 启动失败，查看/usr/local/nacos/logs下start.out日志文件，报错如下：
/usr/local/java/jdk-11.0.10/bin/java -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Dnacos.member.list= -Xlog:gc*:file=/usr/local/nacos/logs/nacos_gc.log:time,tags:filecount=10,filesize=102400 -Dloader.path=/usr/local/nacos/plugins/health,/usr/local/nacos/plugins/cmdb -Dnacos.home=/usr/local/nacos -jar /usr/local/nacos/target/nacos-server.jar --spring.config.additional-location=file:/usr/local/nacos/conf/ --logging.config=/usr/local/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288 Error: Could not find or load main class Caused by: java.lang.ClassNotFoundException: 5、解决方案 进入/usr/local/nacos/bin/目录，修改启动文件startup.sh，修改内容如下：
x JAVA_OPT_EXT_FIX=&amp;#34;-Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext&amp;#34; √ JAVA_OPT=&amp;#34;${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext&amp;#34; x echo &amp;#34;$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}&amp;#34; √ echo &amp;#34;$JAVA ${JAVA_OPT}&amp;#34; x echo &amp;#34;$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}&amp;#34; &amp;gt; ${BASE_DIR}/logs/start.out 2&amp;gt;&amp;amp;1 &amp;amp; x nohup &amp;#34;$JAVA&amp;#34; &amp;#34;$JAVA_OPT_EXT_FIX&amp;#34; ${JAVA_OPT} nacos.</description></item><item><title/><link>https://willxwu.github.io/posts/centos%E5%AE%89%E8%A3%85sentinel%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%90%AF%E5%8A%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/centos%E5%AE%89%E8%A3%85sentinel%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%90%AF%E5%8A%A8/</guid><description>CentOS安装Sentinel设置自启动 1、下载 下载地址https://github.com/alibaba/Sentinel/releases
2、安装 提前创建好安装路径、Jar包存放文件夹、脚本执行文件夹、日志存放文件夹
mkdir /usr/local/ sentinel mkdir /usr/local/sentinel jar mkdir /usr/local/sentinel sh mkdir /usr/local/sentinel log 将sentinel-dashboard-1.8.6.jar执行Jar包上传至jar文件夹
3、脚本 编写脚本sentinel.sh，按照自己路径、版本号调整，存放到上面新建的sh文件夹中。脚本如下：
#!/bin/bash #这里可替换为你自己的执行程序，其他代码无需更改 SENTINEL_NAME=sentinel-dashboard-1.8.6.jar #使用说明，用来提示输入参数 usage() { echo &amp;#34;Usage: sh sentinel.sh [start|stop|restart|status]&amp;#34; exit 1 } #检查程序是否在运行 is_exist(){ pid=`ps -ef|grep $SENTINEL_NAME|grep -v grep|awk &amp;#39;{print $2}&amp;#39; ` #如果不存在返回1，存在返回0 if [ -z &amp;#34;${pid}&amp;#34; ]; then return 1 else return 0 fi } #启动方法 start(){ is_exist if [ $? -eq &amp;#34;0&amp;#34; ]; then echo &amp;#34;${SENTINEL_NAME} is already running.</description></item><item><title/><link>https://willxwu.github.io/posts/centos%E7%8E%AF%E5%A2%83jdk11%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/centos%E7%8E%AF%E5%A2%83jdk11%E5%AE%89%E8%A3%85/</guid><description>CentOS环境JDK11安装 1、下载 JDK11下载地址：https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html
2、路径 创建jdk安装文件夹
mkdir /usr/local/java 3、安装 进入下载的jdk所在目录，执行安装命令。
tar -zxvf jdk-11.0.10_linux-x64_bin.tar.gz -C /usr/local/java/ 4、环境配置 修改系统环境文件/etc/profile，在最后加上java环境变量配置信息。
export JAVA_HOME=/usr/local/java/jdk-11.0.10 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 5、连接 创建软连接
ln -s /usr/local/java/jdk-11.0.10/bin/java /usr/bin/java 6、验证 java -version 输出结果：
java version &amp;#34;11.0.10&amp;#34; 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode)</description></item><item><title/><link>https://willxwu.github.io/posts/chatgpt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/chatgpt/</guid><description>OpenAI&amp;rsquo;s services are not available in your country.
chatGpt注册，OpenAI&amp;rsquo;s services are not available in your country.解决方法。
1、chatGpt注册 打开chatpgt官网https://chat.openai.com/auth/login，点击Sign up注册，跳转至注册页面。
2、邮箱验证 最好使用gmail、outlook海外邮箱，注册。打开邮箱链接，即可验证。
3、重新登录 提示设置用户姓名
4、手机号验证 使用国内手机号会提示“OpenAI&amp;rsquo;s services are not available in your country.”
5、OpenAI&amp;rsquo;s services are not available in your country 解决方案：
5.1、使用公共接码号码，但是基本都被使用过了。
5.2、使用虚拟外海号码。
6、虚拟外海号码 1、注册账号 打开官网https://sms-activate.org/注册，最好使用海外邮箱Gmail、Outlook。
2、账号充值 切换成中文，选择“充值”。
选择支付宝充值
选择充值1美元即可，大约6.46人民币。
3、获取号码 根据需求选择需要使用的服务类型、选择号码国家。这里注册chatgpt，直接搜索OpenAI即可。
选择要使用的国家号码，这里选择的印度。
填写要使用的数量，然后点后面的购物车后，右边会显示号码和一会接收到的验证码。
复制号码到chatGpt注册时，验证手机号的地方，一会就可以看到验证码了。
后面就可以直接注册成功chatgpt了。</description></item><item><title/><link>https://willxwu.github.io/posts/completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</guid><description>通过线程池性能稳定，也可以获取执行结果，并捕获异常。但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。因此我们可以使用completableFuture 异步编排方案。
比如：一个业务场景，需要同时获取多个数据，如果同步线程挨个执行，则需要时间为所有线程执行时间的总和。
如果我们使用异步线程执行，所需时间则为耗时最长那个异步线程的执行时间。
如果多个异常线程之间还存在依赖关系，比如线程3需要线程1的执行结果，线程6依赖线程3、线程2，那这个问题怎么解决呢。那就可以使用completableFuture 异步编排方案实现。
注意：completableFuture 是jdk1.8之后添加的一个功能。
CompletableFuture接口:
public class CompletableFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, CompletionStage&amp;lt;T&amp;gt; { public interface Future&amp;lt;V&amp;gt; { 以前用到的FutureTask就是用到的Future可以得到返回结果
public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; { public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } Future可以得到返回结果
CompletableFuture随便一个方法，都接受一个Function
public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; applyToEither( CompletionStage&amp;lt;? extends T&amp;gt; other, Function&amp;lt;? super T, U&amp;gt; fn) { return orApplyStage(null, other, fn); } @FunctionalInterface public interface Function&amp;lt;T, R&amp;gt; { Function是一个@FunctionalInterface，所以对Lambda使用要熟悉。</description></item><item><title/><link>https://willxwu.github.io/posts/copyonwritearraylist%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/copyonwritearraylist%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86/</guid><description>package com.yanxizhu; import java.util.*; /** * @description: synchronizedList遍历错误 * @date: 2022/3/19 11:30 * @version: 1.0 */ public class ConCurrentHashMapTest { public static void main(String[] args) { conCurrentDemo conCurrentDemo = new conCurrentDemo(); for(int i=0;i&amp;lt;5;i++){ new Thread(conCurrentDemo).start(); } } public static class conCurrentDemo implements Runnable{ //并发线程安全，修改报错 private static List&amp;lt;String&amp;gt; list = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;()); static { list.add(&amp;#34;apple&amp;#34;); list.add(&amp;#34;xiaomi&amp;#34;); list.add(&amp;#34;huawei&amp;#34;); } @Override public void run() { Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); list.add(&amp;#34;iphone&amp;#34;); } } } } 线程安全报错：</description></item><item><title/><link>https://willxwu.github.io/posts/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.CountDownLatch; /** * @date: 2022/3/19 11:09 * @version: 1.0 */ public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); myCountDownlatch myCountDownlatch = new myCountDownlatch(countDownLatch); long start = System.currentTimeMillis(); for(int i=0;i&amp;lt;5;i++){ new Thread(myCountDownlatch).start(); } countDownLatch.await(); long end = System.currentTimeMillis(); System.out.println(&amp;#34;耗时：&amp;#34;+(end-start)); } public static class myCountDownlatch implements Runnable{ private CountDownLatch countDownLatch; public myCountDownlatch(CountDownLatch countDownLatch){ this.countDownLatch = countDownLatch; } @Override public void run() { synchronized (this){ try{ for(int i =0;i&amp;lt;500;i++){ if(i % 2==0){ System.</description></item><item><title/><link>https://willxwu.github.io/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/dbcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid><description>使用dbcp连接池，进行数据库的CRUD，涉及jar包：commons-dbcp2-2.8.0.jar（连接池包）、commons-pool2-2.9.0.jar（dbcp依赖该包）、commons-logging-1.2.jar（接口日志包）、mysql-connector-java-5.1.37-bin.jar（数据库连接驱动）、commons-dbutils-1.7.jar（基本CRUD操作）
DbcpUtils数据库连接池配置：
package learn.javase.dbcppool; import org.apache.commons.dbcp2.BasicDataSource; /** * 利用DBCP链接数据库 * @author Jole * */ public class DbcpUtils { private static BasicDataSource dataSource = new BasicDataSource(); static { //必配参数 dataSource.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource.setUrl(&amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;); dataSource.setUsername(&amp;#34;root&amp;#34;); dataSource.setPassword(&amp;#34;11111&amp;#34;); //可配参数 dataSource.setInitialSize(10); dataSource.setMaxIdle(8); dataSource.setMinIdle(2); } public static BasicDataSource getConnecton() { return dataSource; } } 利用DbcpUtils进行数据库的CRUD操作：
package learn.javase.dbcppool; import java.sql.SQLException; import java.util.List; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.ArrayListHandler; /** * 利用DBCP数据库连接池增加、查询 * @author Jole * */ public class DbcpUtilsDemo { private static QueryRunner qr = new QueryRunner(DbcpUtils.</description></item><item><title/><link>https://willxwu.github.io/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/dbutils%E6%95%B0%E6%8D%AE%E5%BA%93curd/</guid><description>通过读取properties获取链接数据库信息，利用apache开源数据库操作工具包DBUtils进行数据库CRUD操作。
properties文件：
driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test user=root password=11111 通过dbutils自定义获取数据库连接对象:
package learn.javase.jdbc; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.util.Properties; public class JdbcUtils{ private static Connection conn; private static String driverClass; private static String url; private static String user; private static String password; static { try { getReadConfig(); Class.forName(driverClass); conn = DriverManager.getConnection(url, user, password); }catch(Exception e) { new RuntimeException(&amp;#34;链接数据库失败！&amp;#34;); } } private static void getReadConfig() throws Exception{ InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&amp;#34;jdbc.properties&amp;#34;); Properties pro = new Properties(); pro.</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker-%E5%AE%89%E8%A3%85es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker-%E5%AE%89%E8%A3%85es/</guid><description>Docker 安装ES
一、下载镜像文件，存储和检索数据
docker pull elasticsearch:7.4.2 二、创建实例
创建文件，用于映射
mkdir -p /mydata/elasticsearch/config mkdir -p /mydata/elasticsearch/data echo &amp;#34;http.host: 0.0.0.0&amp;#34; &amp;gt;&amp;gt; /mydata/elasticsearch/config/elasticsearch.yml 设置权限
chmod -R 777 /mydata/elasticsearch/ 三、启动配置镜像
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \ -e &amp;#34;discovery.type=single-node&amp;#34; \ -e ES_JAVA_OPTS=&amp;#34;-Xms64m -Xmx512m&amp;#34; \ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \ -d elasticsearch:7.4.2 以后再外面装好插件重启即可；
特别注意： -e ES_JAVA_OPTS=&amp;quot;-Xms64m -Xmx256m&amp;quot; \ 测试环境下，设置ES 的初始内存和最大内存，否则导 致过大启动不了ES</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85jenkins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85jenkins/</guid><description>Docker安装Jenkins jdk安装 下载jdk解压到个人安装目录
/mydata/jdk/jdk-11.0.10 maven安装 下载maven解压到个人安装目录
/mydata/maven/apache-maven-3.8.5 修改mavne配置文件setting.xml，设置本地仓库目录
&amp;lt;localRepository&amp;gt;/mydata/maven/repo&amp;lt;/localRepository&amp;gt; 添加阿里云镜像，在mirrors节点下增加以下内容
&amp;lt;mirrors&amp;gt; &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt; &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/repositories/central/&amp;lt;/url&amp;gt; &amp;lt;/mirror&amp;gt; &amp;lt;/mirrors&amp;gt; 开启Docker Remote API 关闭防火墙 或者 开启防火墙的端口 #关闭防火墙 systemctl stop firewalld.service # 禁止firewall开机启动 systemctl disable firewalld.service # 或者允许固定端口 firewall-cmd --zone=public --add-port=2375/tcp --permanent firewall-cmd --reload Docker环境下安装Jenkins 拉取最新的Jenkins的docker镜像
docker pull jenkins/jenkins:lts 启动Jenkins容器
docker run -p 10240:8080 -p 10241:50000 --name jenkins \ -u root \ -v /mydata/jenkins_home:/var/jenkins_home \ -v /mydata/maven/apache-maven-3.8.5:/maven/apache-maven-3.8.5 \ -v /mydata/jdk/jdk-11.0.10/:/jdk/jdk-11.0.10 \ -v /mydata/maven/repo:/mydata/maven/repo \ -d jenkins/jenkins:lts 注意：自己的目录和端口是否相同，不同请求修改。</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</guid><description>Docker安装Jenkins自动部署SpringBoot项目 根据之前文章《使用Docker安装好Jenkins》为前提搭建好Jenkins，不明白请看https://www.yanxizhu.com/index.php/archives/138/。
环境说明：jenkins为docker部署，Docker+Jenkins+Gitee+JDK11+Maven3.8.5。
以后每次改动代码，push提交到giee码云后会自动部署，不用手动点击部署。
一、全局工具配置 【首页】-【系统管理】-【全局工具配置】
我之前启动jenkins容器映射参数如下，根据自己映射路径自行修改。
docker run -p 10240:8080 -p 10241:50000 --name jenkins \ -u root \ -v /mydata/jenkins_home:/var/jenkins_home \ -v /mydata/maven/apache-maven-3.8.5:/maven/apache-maven-3.8.5 \ -v /mydata/jdk/jdk-11.0.10/:/jdk/jdk-11.0.10 \ -v /mydata/maven/repo:/mydata/maven/repo \ -v /usr/bin/docker:/usr/bin/docker \ -v /var/run/docker.sock:/var/run/docker.sock \ -d jenkins/jenkins:lts 上面很重要，注意。
jdk配置
jdk11 路径
/jdk/jdk-11.0.10 maven配置
maven3.8.5 路径
/maven/apache-maven-3.8.5 git配置
Default 路径
/usr/bin/git docker配置
docker 路径
/usr/bin 注意点：
1、jenkins容器里面自带git，可通过命令查看路径。
2、注意自己jdk、mavn、docker安装路径。
查看jenkins自带git路径命令：
which git 二、插件安装 【首页】-【系统管理】-【插件管理】
插件1：
Publish Over SSH 插件2：
Gitee Plugin 如果插件安装慢，可以修改源，请参考修改方案，https://www.</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85kibana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85kibana/</guid><description>Docker安装Kibana
一、拉取镜像，可视化检索数据
docker pull kibana:7.4.2 二、启动运行容器
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.1.10:9200 -p 5601:5601 \ -d kibana:7.4.2 注意：更改自己的ip，es端口，以及和es版本号对应。</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85mysql/</guid><description>安装前提，已经搭建好Docker环境，关于docker安装可参考我另一篇文章《Docker安装》
一、Docker安装MySQL 拉取Docker镜像
docker pull mysql:5.7 运行MySQL容器,参数说明见-说明1
docker run -p 3306:3306 --name mysql \ -v /mydata/mysql/log:/var/log/mysql \ -v /mydata/mysql/data:/var/lib/mysql \ -v /mydata/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=密码 \ -d mysql:5.7 二、MySQL配置 修改MySQL配置文件,my.cnf内容见-说明2
vi /mydata/mysql/conf/my.cnf 容器的mysql 命令行工具连接
docker exec -it mysql mysql -uroot -p 注意：会提示输入密码，也就是上面2运行容器时配置的密码
设置root 远程访问
grant all privileges on *.* to &amp;#39;root&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;密码&amp;#39; with grant option; 刷新MySQL配置
flush privileges; 重启MySQL容器
docker restart mysql 设置启动Docker是启动MySQL容器
docker update --restart=always mysql 说明1: -p 3306:3306：将容器的3306 端口映射到主机的3306 端口</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%AE%89%E8%A3%85nginx/</guid><description>一、Docker安装Nginx 拉取Nginx镜像
docker pull nginx:1.10 随便启动一个nginx 实例，只是为了复制出配置
docker run -p 80:80 --name nginx -d nginx:1.10 拷贝容器内的配置文件
docker container cp nginx:/etc/nginx . 重命名文件夹
mv nginx conf 移动配置文件到/mydata/nginx下
mv conf /mydata/nginx/ 终止原容器
docker stop nginx 删除原容器
docker rm nginx 运行Nginx容器,参数见-说明1
docker run -d -p 80:80 -p 443:443 --name nginx -v /mydata/nginx/html:/var/www/html -v /mydata/nginx/conf/conf.d:/etc/nginx/conf.d -v /mydata/nginx/logs:/var/log/nginx --link php:phpfpm --name nginx nginx:1.10 设置随Docker启动
docker update --restart=always nginx 二、Nginx配置 https协议SSL-443配置，在/mydata/nginx/conf/conf.d下新建配置文件yanxizhu.com.conf，内容如下：
server { listen 443 ssl http2 reuseport; server_name yanxizhu.</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E5%BC%80%E5%90%AFremote-api%E8%AE%BF%E9%97%AE-2375%E7%AB%AF%E5%8F%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E5%BC%80%E5%90%AFremote-api%E8%AE%BF%E9%97%AE-2375%E7%AB%AF%E5%8F%A3/</guid><description>Docker开启Remote API访问 方法一 1、修改/usr/lib/systemd/system/docker.service配置，在[Service]部分ExecStart后面添加配置。
-H tcp://0.0.0.0:2375 修改后如下：
[Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always 2、重新加载配置文件
systemctl daemon-reload systemctl restart docker 方法二 修改配置
sudo vim /etc/default/docker 加入下面配置
DOCKER_OPTS=&amp;#34;-H tcp://0.0.0.0:2375&amp;#34; 重新加载配置文件</description></item><item><title/><link>https://willxwu.github.io/posts/docker/docker%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker/docker%E7%AC%94%E8%AE%B0/</guid><description>容器：一种打包技术。
docker：打包技术的一种技术实现。
一、基础知识 基础命令 查看docker相关信息
docker versoin 查看docker环境信息
docker info 查看命令帮助
docker --help image镜像 image是一个只读文件，里面包含文件系统、源码、可文件、依赖、工具等一些运行application所需的文件，可以理解成一个模板。docker image具有分层的概念。
container容器 一个运行中的“docker image”。是指是复制image并在image最上层加上一层读写的层。基于同一个image可以创建多个container。
image获取方式 1、自己制作
2、从registry拉取，比如docker hub
创建容器 查看容器帮助命令
docker container --help 当没有拉取镜像时，会自动拉取。
查看当前运行了那些容器：
docker container ls id:唯一的id。
image：使用的镜像。
command：执行的命令
created：创建时间，这里是2分钟之前。
status：状态
ports：端口协议
names: 容器名称，不设置时，随机产生一个。
创建容器：
docker container run 镜像命令 例如：创建nginx容器
dockekr container run nginx 注意：此时是在窗口运行，ctrl+c会停止运行容器。
关闭容器 docker stop 容器名称或者容器id 例如：关闭nginx
查看容器信息：
docker container list 关闭容器：
docker container 7b51 查看容器 查看运行中的容器
docker container list 查看创建过或者使用过的容器</description></item><item><title/><link>https://willxwu.github.io/posts/docker%E9%83%A8%E7%BD%B2kafka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/docker%E9%83%A8%E7%BD%B2kafka/</guid><description>Docker部署Kafka 一、拉取镜像 docker pull wurstmeister/zookeeper docker pull wurstmeister/kafka 二、启动zookpeer docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper 三、启动kafka docker run -d --name kafka \ -p 9092:9092 \ -e KAFKA_BROKER_ID=0 \ -e KAFKA_ZOOKEEPER_CONNECT=192.168.56.10:2181 \ -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.56.10:9092 \ -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka 注意修改自己ip地址
四、测试 1、进入kafka容器 docker exec -it kafka bash 2、进入kafak脚本目录 cd /opt/kafka_2.13-2.8.1/bin 注意修改自己kafka版本
3、创建主题 kafka-topics.sh --create --zookeeper 192.168.56.10:2181 --replication-factor 1 --partitions 1 --topic topic_1 这里创建了一个topic_1主题。
4、添加消息 生产者发送消息
kafka-console-producer.sh --broker-list 192.168.56.10:9092 --topic topic_1 此时进入发送消息界面：</description></item><item><title/><link>https://willxwu.github.io/posts/es6%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/es6%E8%AF%AD%E6%B3%95/</guid><description>ES6语法 一、let &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; // { // //var 声明的变量往往会跨域 // //let 声明的变量有严格局部作用域 // var a = 1; // let b = 2; // } // console.log(a); //1 // console.log(b); //Uncaught ReferenceError: b is not defined // //var 可以声明多次 // //let 只能声明一次 // var m = 3; // var m = 4; // let n = 5; // // let n=5; // console.</description></item><item><title/><link>https://willxwu.github.io/posts/executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>Executors线程池 package com.yanxizhu; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1.</description></item><item><title/><link>https://willxwu.github.io/posts/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /** * @description: FutureTask可用于闭锁 * @date: 2022/3/19 11:48 * @version: 1.0 */ public class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { myFutureTask myFutureTask = new myFutureTask(); FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(myFutureTask); new Thread(futureTask).start(); //必须等线程执行完，才执行下面的代码，因此FutureTask可用于闭锁 Integer integer = futureTask.get(); System.out.println(&amp;#34;integer=&amp;#34;+integer); System.out.println(&amp;#34;=======================&amp;#34;); } public static class myFutureTask implements Callable&amp;lt;Integer&amp;gt;{ @Override public Integer call() throws Exception { int i=1; for(;i&amp;lt;1000000;i++){ i++; } return i; } } }</description></item><item><title/><link>https://willxwu.github.io/posts/html%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/html%E5%AD%A6%E4%B9%A0/</guid><description>1、HTML基本格式 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; html：根标签，只有一个（网页所有内容都应该写在根标签里面）
head：子标签，用来设置头部内容
body：子标签，网页主体,所有要显示的内容放这里面
title：
网页的标题标签，也就是网页显示名字。
搜索引擎检索页面时，会首先检索titlte中的内容。
元素：一个完整的标签&amp;lt;&amp;gt;&amp;lt;/&amp;gt;
标签&amp;lt;&amp;gt;
2、HTML后缀名 将编写好的文件保存为.html网页格式文件
显示文件格式名
3、HTML注释 &amp;lt;！-- 这是一个注释的格式，可以直接换行 继续写注释。 --&amp;gt; 注释中的内容，不会显示在页面。
可以写注释来对代码进行描述，便于后期的维护。要养成良好的编写注释习惯。
4、标签属性 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello &amp;lt;font color=&amp;#34;red&amp;#34;&amp;gt;World&amp;lt;/font&amp;gt; ！&amp;lt;/h1&amp;gt; &amp;lt;!-- 这是一个注释，不会显示在网页中。 --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 属性只能在开始标签中设置
属性名 =&amp;ldquo;属性值&amp;rdquo;
怎么知道有哪些属性，可以参考W3C
5、文档申明 主要用于申明网页版本最新为html5 html5的文档申明，申明当前的网页是按照HTML5页标准编写的一定要放在网页的最上边，不申明，则会导致有些浏览器有些页面无法正常显示，所以为了避免，一定要写文档申明. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;HTML入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello &amp;lt;font color=&amp;#34;red&amp;#34;&amp;gt;World&amp;lt;/font&amp;gt; ！&amp;lt;/h1&amp;gt; &amp;lt;!-- 这是一个注释，不会显示在网页中。 --&amp;gt; &amp;lt;h1&amp;gt;怎么知道有哪些属性？&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;可以参考&amp;lt;a href=&amp;#34;http://www.w3school.com.cn/&amp;#34;&amp;gt;W3C&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 6、进制 二进制</description></item><item><title/><link>https://willxwu.github.io/posts/iptables-failed-iptables--wait-t-nat-a-docker-p-tcp-d-00--dport-10241-j-dnat--to-destination-172/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/iptables-failed-iptables--wait-t-nat-a-docker-p-tcp-d-00--dport-10241-j-dnat--to-destination-172/</guid><description>iptables failed: iptables &amp;ndash;wait -t nat -A DOCKER -p tcp -d 0/0 &amp;ndash;dport 10241 -j DNAT &amp;ndash;to-destination 172.17.0.5:50000 ! -i docker0: iptables: No chain/target/match by that name.
docker启动Jenkins报错：
iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 10241 -j DNAT --to-destination 172.17.0.5:50000 ! -i docker0: iptables: No chain/target/match by that name. 解决办法：重启docker
systemctl restart docker</description></item><item><title/><link>https://willxwu.github.io/posts/j.u.c%E4%B9%8Baqs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/j.u.c%E4%B9%8Baqs/</guid><description>AQS J.U.C之AQS，底层由线程队列实现。AbstractQueuedSynchronizer简称AQS，JUC的核心。
使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。 利用了一个int类型表示状态。 使用方法是继承。 子类通过继承并通过实现它的方法管理其状态{acquire和release}的方法操纵状态。 可以同时实现排它锁和共享锁模式（独占、共享）。
AQS主要同步组件 CountDownLatch
Semaphore
CyclicBarrier
ReentrantLock
Condition
FutureTask
依次介绍 1、CountDownLatch-闭锁 可以完成类似阻塞的功能。一个线程或多个线程等待，直到其它线程完成。使用场景，程序执行需要某个条件执行完后，才执行。
示例一 package com.yanxizhu.demo.concurrency.aqs; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @description: CountDownLatch,实现线程阻塞，等待执行完再执行程序打印 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/25 20:24 * @version: 1.0 */ @Slf4j @ThreadSafety public class CountDownLatchDemo { private static final int threadNum = 500; public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/java-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java-io/</guid><description>将自己看作为程序，将数据输出到文件中，称之为输出。 从文件读取数据到程序，称为输出。
JAVA流操作主要分为字节流、字符流。
字节流鼻祖：InputStream\OutpuStream
字符流鼻祖:Reader\Writer
File 1、File常用方法 package learn.javase; import java.io.File; /** * File常用操作 * @author Jole * */ public class FileDemo01 { public static void main(String[] args) { File file = new File(&amp;#34;H://&amp;#34;); //此抽象路径名表示的文件或目录的名称；如果路径名的名称序列为空，则返回空字符串 System.out.println(file.getName()); //返回文件大小 System.out.println(file.length()); //返回绝对路径 System.out.println(file.getAbsolutePath()); //绝对路径名 System.out.println(file.getAbsoluteFile()); //父目录 System.out.println(file.getParentFile()); //是否存在 System.out.println(file.exists()); //是否是目录 System.out.println(file.isDirectory()); //返回路径下的文件或文件夹 System.out.println(file.list()); for(String path : file.list()) { //获取路径 System.out.println(path); } //可用的文件系统根 System.out.println(&amp;#34;listRoots:&amp;#34;+file.listRoots()); for(File f : file.listFiles()) { System.out.println(&amp;#34;111&amp;#34;+f); System.out.println(f.list()); System.out.println(f.length()); System.out.println(&amp;#34;111&amp;#34;+f.listRoots()); } } } 2、实例 遍历所有文件</description></item><item><title/><link>https://willxwu.github.io/posts/java8/ava8-completablefuture%E5%B8%B8%E7%94%A8apirunafterbothapplytoeitheraccepteither-runaftereither-allofanyof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/ava8-completablefuture%E5%B8%B8%E7%94%A8apirunafterbothapplytoeitheraccepteither-runaftereither-allofanyof/</guid><description>AVA8-CompletableFuture常用API：runAfterBoth、applyToEither、acceptEither 、runAfterEither 、allOf、anyOf 1、runAfterBoth ：2个CompletableFuture都执行完后,再执行其它操作 package com.example.study.java8.completableFutures.api; import java.util.concurrent.CompletableFuture; public class CompletableFutureAction2 { public static void main(String[] args) throws InterruptedException { //API-- 1、runAfterBoth: 2个都执行完后,再执行其它操作 CompletableFuture.supplyAsync(() -&amp;gt; { System.out.println(Thread.currentThread().getName() + &amp;#34;this is runing 1......&amp;#34;); return 1; }) .runAfterBoth(CompletableFuture.supplyAsync(() -&amp;gt; { System.out.println(Thread.currentThread().getName() + &amp;#34;this is runing 2......&amp;#34;); return 2; }), () -&amp;gt; System.out.println(&amp;#34;done&amp;#34;)); //为了防止主线程结束后，守护线程被关闭，模拟修改10000毫秒 Thread.sleep(10000); } } 输出结果：
ForkJoinPool.commonPool-worker-5this is runing 2...... ForkJoinPool.commonPool-worker-19this is runing 1...... done 2、 applyToEither：其中一个CompletableFuture执行完，就将结果传给另一个Fuction package com.example.study.java8.completableFutures.api; import java.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/collector-interface%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/collector-interface%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>Collector interface源码分析 源码 public interface Collector&amp;lt;T, A, R&amp;gt; { Supplier&amp;lt;A&amp;gt; supplier(); BiConsumer&amp;lt;A, T&amp;gt; accumulator(); Function&amp;lt;A, R&amp;gt; finisher(); BinaryOperator&amp;lt;A&amp;gt; combiner(); Set&amp;lt;Characteristics&amp;gt; characteristics(); } 说明： 1.T is the generic type of the items in the stream to be collected. 2.A is the type of the accumulator, the object on which the partial result will be accumulated during the collection process. 3.R is the type of the object (typically, but not always, the collection) resulting from the collect operation.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid><description>JAVA8-CompletableFuture基本用法 针对&amp;lt;实现一个异步基于事件回调的Future程序&amp;gt; 用CompletableFuture进行改进。
代码示例：
package com.example.study.java8.completableFutures; import java.util.Optional; import java.util.Random; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; /** * CompletableFuture 基本用法 */ public class CompletableFutureInAction1 { private final static Random RANDOM = new Random(System.currentTimeMillis()); public static void main(String[] args) throws ExecutionException, InterruptedException { //实际开发中，一般不直接new，而是使用工厂创建 // CompletableFuture&amp;lt;Void&amp;gt; voidCompletableFuture = CompletableFuture.runAsync(); CompletableFuture&amp;lt;Double&amp;gt; completableFuture = new CompletableFuture&amp;lt;&amp;gt;(); new Thread(()-&amp;gt;{ double value = get(); completableFuture.complete(value); }).start(); //不会阻塞程序执行 System.out.println(&amp;#34;===========no====block====..&amp;#34;); //1、后面获取程序执行结果 // Optional.ofNullable(completableFuture.get()).ifPresent(System.out::println); //2、执行完后，通过回调自动返回结果 completableFuture.whenComplete((v,t)-&amp;gt;{ Optional.ofNullable(v).ifPresent(System.out::println); Optional.ofNullable(t).ifPresent(x-&amp;gt;x.printStackTrace()); }); } private static double get(){ try { Thread.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-collectors-api-groupingbyconcurrentjoiningmappingmaxbyminby/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-collectors-api-groupingbyconcurrentjoiningmappingmaxbyminby/</guid><description>JAVA8-Collectors API: groupingByConcurrent、joining、mapping、maxby、minby# 前置数据
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、groupingByConcurrent 返回map为ConcurrentMap,按类型分组 public static void testGroupingByConcurrentWithFunction() { System.out.println(&amp;#34;testGroupingByConcurrentWithFunction&amp;#34;); ConcurrentMap&amp;lt;Dish.Type, List&amp;lt;Dish&amp;gt;&amp;gt; collect = menu.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-collectors-api-partitioningbyreducingsummarizinglongsummarizingintsummarizingdouble/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-collectors-api-partitioningbyreducingsummarizinglongsummarizingintsummarizingdouble/</guid><description>JAVA8-Collectors API: partitioningBy、reducing、summarizingLong、summarizingInt、summarizingDouble 前置数据：
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、partitioningBy 分组 public static void testPartitioningByWithPredicate() { System.out.println(&amp;#34;testPartitioningByWithPredicate&amp;#34;); Map&amp;lt;Boolean, List&amp;lt;Dish&amp;gt;&amp;gt; collect = menu.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-collectors-api-summingdoublesumminginttestsumminglongtocollectiontoconcurrentmaptolisttosettomap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-collectors-api-summingdoublesumminginttestsumminglongtocollectiontoconcurrentmaptolisttosettomap/</guid><description>JAVA8-Collectors API:summingDouble、summingInt、testSummingLong、toCollection、toConcurrentMap、toList、toSet、toMap 前置数据
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、summingDouble public static void testAveragingDouble(){ System.out.println(&amp;#34;testAveragingDouble&amp;#34;); //用reduce聚合求和 Optional.ofNullable(menu.stream().map(Dish::getCalories).reduce(Integer::sum)).get().ifPresent(System.out::println); //用collectors averagingDouble求平均值 Optional.ofNullable(menu.stream().collect(averagingDouble(Dish::getCalories))).ifPresent(System.out::println); } 输出结果：</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-collectors-api-%E8%AE%A1%E7%AE%97%E8%81%9A%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-collectors-api-%E8%AE%A1%E7%AE%97%E8%81%9A%E5%90%88/</guid><description>JAVA8-Collectors API:averaging、collectingAndThen、counting、groupingBy 前置数据
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、averagingDouble 求平均值 public static void testAveragingDouble(){ System.out.println(&amp;#34;testAveragingDouble&amp;#34;); //用reduce聚合求和 Optional.ofNullable(menu.stream().map(Dish::getCalories).reduce(Integer::sum)).get().ifPresent(System.out::println); //用collectors averagingDouble求平均值 Optional.ofNullable(menu.stream().collect(averagingDouble(Dish::getCalories))).ifPresent(System.out::println); } 输出结果：</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-completablefuture%E5%B8%B8%E7%94%A8api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-completablefuture%E5%B8%B8%E7%94%A8api/</guid><description>JAVA8-CompletableFuture常用API：thenApply、handle、thenRun、thenAccept、thenCompose、thenCombine、thenAcceptBoth 1、thenApply package com.example.study.java8.completableFutures.api; import java.util.Optional; import java.util.concurrent.CompletableFuture; /** * CompletableFuture常用API: thenApply、handle */ public class CompletableFutureAtion1 { public static void main(String[] args) throws InterruptedException { //API-- 1、thenApply //模拟其它 异步 逻辑操作然后返回结果1 CompletableFuture.supplyAsync(() -&amp;gt; 1) .thenApply(i -&amp;gt; Integer.sum(i, 10)) //thenApply 将结果加10 .whenComplete((v, t) -&amp;gt; Optional.ofNullable(v).ifPresent(System.out::println)); //同步执行打印结果 // .whenCompleteAsync() //异步操作，可以将结果在进行其它逻辑异步操作 //whenComplete VS whenCompleteAsync //为了防止主线程结束后，守护线程被关闭，模拟修改10000毫秒 Thread.sleep(10000); } } 输出结果：
11 对比 whenComplete VS whenCompleteAsync：whenCompleteAsync异步操作，可以将结果在进行其它逻辑异步操作。
2、handle package com.example.study.java8.completableFutures.api; import java.util.Optional; import java.util.concurrent.CompletableFuture; /** * CompletableFuture常用API: thenApply、handle */ public class CompletableFutureAtion1 { public static void main(String[] args) throws InterruptedException { //API- 2、handle CompletableFuture.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-completablefuture%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9Cjoin%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-completablefuture%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9Cjoin%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</guid><description>JAVA8-CompletableFuture流水线工作，join多个异步任务详解 需求：根据商品id，将每个商品价格翻2倍？
代码示例 package com.example.study.java8.completableFutures; import java.util.Arrays; import java.util.List; import java.util.Random; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.stream.Stream; import static java.util.stream.Collectors.toList; /** * 根据商品id，将每个商品价格翻2倍。CompletableFuture高并发执行。 */ public class CompletableFutureInAction4 { private final static Random RANDOM = new Random(System.currentTimeMillis()); public static void main(String[] args) { //防止主线程执行完后，守护线程也关闭 ExecutorService executorService = Executors.newFixedThreadPool(2, r -&amp;gt; { Thread thread = new Thread(r); thread.setDaemon(false); return thread; }); //5个商品ID List&amp;lt;Integer&amp;gt; productIDs = Arrays.asList(1, 2, 3, 4, 5); //通过CompletableFuture查询5个商品价格 Stream&amp;lt;CompletableFuture&amp;lt;Double&amp;gt;&amp;gt; completableFutureStream = productIDs.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-date-api-localdate-localtime-instant-duration-period/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-date-api-localdate-localtime-instant-duration-period/</guid><description>JAVA8-Date and Time API： LocalDate, LocalTime, Instant, Duration, Period 旧API问题 1、代码不清晰，一下看不出要转换的日期。
**2、Date日期中还包含了时间 **
3、多线程情况下会报错。
代码重现：
package com.example.study.java8.datetime; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateTest { public static void main(String[] args) throws ParseException { //122格林威治时间 11月 23日期 //问题：不能清晰表示日期 Date date = new Date(122, 11, 23); System.out.println(date); //多线程情况下会出现一些问题： //30个线程，每个线程下循环100次，执行时间格式转换。 SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyyMMdd&amp;#34;); for (int i = 0; i &amp;lt; 30; i++) { new Thread(() -&amp;gt; { for (int j = 0; j &amp;lt; 100; j++) { Date parseDate = null; try { parseDate = sdf.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-default%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-default%E6%96%B9%E6%B3%95/</guid><description>JAVA8-default、static default方法 1.8之前出现的问题:开发了一个接口，后面实现该接口的实现类，都需要实现接口中定义的方法。1.8之后接口中使用default定义新增的方法后，其实现类可以不用实现该方法。
例如Collection接口中新增了对stream的操作方法：stream()
public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; { default Stream&amp;lt;E&amp;gt; stream() { return StreamSupport.stream(spliterator(), false); } } 其实现类就可以不用再实现stream()方法，这样对于版本兼容就比较好了。
static 定义的方法 可以通过接口直接调用该方法，例如：
public interface Function&amp;lt;T, R&amp;gt; { static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() { return t -&amp;gt; t; } } 注意：接口中有default定义的方法实现了，但并不是抽象类。
接口：可以被多个类实现。
抽象类：继承了一个抽象类，就不能再继承另一个抽象类，因为类是单继承。
实列 自己用default实现一个接口
package com.example.study.java8.method; /** * default使用 */ public class DefaultAction { public static void main(String[] args) { A a = ()-&amp;gt;10; System.out.println(a.size()); System.out.println(a.isEmpty()); } public interface A{ int size(); //判断容器是否为空 default boolean isEmpty(){ return size()==0; } } } 输出结果：</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-fork-join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-fork-join/</guid><description>JAVA8-Fork Join Fork：将一个任务拆分成多个线程执行。 Join：将每个现场结果join，最后得到结果。
范例：求数组总和 前置数据：
public static int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 1、原始实现方式 public static int calc() { int result = 0; for (int i = 0; i &amp;lt; data.length; i++) { result += data[i]; } return result; } 原始实现方式调用：
System.out.println(&amp;#34;result=&amp;gt; &amp;#34; + calc()); 2、RecursiveTask实现 RecursiveTask有返回值。
package com.example.study.java8.forkjoin; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; import java.util.concurrent.RecursiveTask; @Data @AllArgsConstructor @NoArgsConstructor @ToString public class AccumulatorRecursiveTask extends RecursiveTask&amp;lt;Integer&amp;gt; { private int start; private int end; private int[] data; private int LIMIT=3; public AccumulatorRecursiveTask(int start, int end, int[] data) { this.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</guid><description>JAVA8-JDK自带Future,Callable,ExecutorService 代码示例：
package com.example.study.java8.funture; import java.util.List; import java.util.concurrent.*; /** * 和自定义Future中block一样会卡住 */ public class FutureInAction2 { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { //创建一个单线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); //返回一个future，里面的操作可能还没完成，但不影响后续的操作。 Future&amp;lt;String&amp;gt; future = executorService.submit(() -&amp;gt; { try { Thread.sleep(10000L); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (InterruptedException e) { return &amp;#34;I&amp;#39;m error&amp;#34;; } }); //没有结果会抛出，中断异常 String value = future.get(); System.out.println(value); //关闭进程 executorService.shutdown(); //shutdownNow关闭进程，但是会返回有那些进程还没有执行完。 List&amp;lt;Runnable&amp;gt; runnables = executorService.shutdownNow(); } } 输出结果：</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</guid><description>Stream parallel 并行执行 范例：求1~100000000的和，执行10次，看时间效率。 代码 package com.example.study.java8.collector; import java.util.function.Function; import java.util.stream.LongStream; import java.util.stream.Stream; /** * Stream parallel并行执行 * 实列：求10次，1~100000000的和，看时间效率。 */ public class ParallelProcessing { public static void main(String[] args) { //获取电脑CPU核数 System.out.println(&amp;#34;当前电脑CPU核数= &amp;#34; + Runtime.getRuntime().availableProcessors()); System.out.println(&amp;#34;The best process time(normalAdd)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::normalAdd, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream1)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream1, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream2)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream2, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream3)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream3, 100_000_000) + &amp;#34; MS&amp;#34;); System.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>Stream基本使用及特点 Stream说明 Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错。
1、可连续操作：
filter, map, and limit can be connected together to form a pipeline. 2、操作中断
collect causes the pipeline to be executed and closes it. 使用范例： package com.example.study.java8.streams; import java.util.*; import java.util.stream.Stream; import static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; /** * Stream使用 * Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错 * You can see two groups of operations: * 1、可连续操作 *  filter, map, and limit can be connected together to form a pipeline. * 2、操作中断 *  collect causes the pipeline to be executed and closes it.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</guid><description>JAVA8-多线程Future设计模式原理,自定义实现一个Future程序。 自定义实现Future，理解设计模式原理。
Future模式实现 自定义代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 自定义模拟future，理解Future的使用。 */ public class FutureInAction { public static void main(String[] args) throws InterruptedException { Funture&amp;lt;String&amp;gt; funture = invoke(() -&amp;gt; { try { //模拟操作计算很长时间 Thread.sleep(10000); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (Exception e) { e.printStackTrace(); return &amp;#34;Error&amp;#34;; } }); //操作计算很长时间，还没操作计算完成，只返回了future，虽然此时返回值为null，但是可以接着执行官其它操作,不会阻塞后续操作。 System.out.println(funture.get()); System.out.println(funture.get()); System.out.println(funture.get()); //知道操作计算完成后，将值返回 while (!funture.isDone()) { Thread.sleep(10); } System.out.println(funture.get()); } private static &amp;lt;T&amp;gt; Funture&amp;lt;T&amp;gt; invoke(Callable&amp;lt;T&amp;gt; callable) { AtomicReference&amp;lt;T&amp;gt; result = new AtomicReference&amp;lt;&amp;gt;(); AtomicBoolean finished = new AtomicBoolean(false); Thread t = new Thread(() -&amp;gt; { T value = callable.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/</guid><description>JAVA8-实现一个异步基于事件回调的Future程序 前面2个例子（JAVA8-多线程Future设计模式原理,自定义实现一个Future程序、JAVA8-JDK自带Future,Callable,ExecutorService）+该例子，是为了学习CompletableFuture，理解其原理。
自定义Future程序代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 实现一个异步基于事件回调的Future程序 */ public class FutureInAction3 { public static void main(String[] args) { Future&amp;lt;String&amp;gt; future = invoke(() -&amp;gt; { try { Thread.sleep(10000L); return &amp;#34;I&amp;#39;m finished.&amp;#34;; } catch (InterruptedException e) { return &amp;#34;I&amp;#39;m Error.&amp;#34;; } }); //注册一个事件 future.setCompletable(new Completable&amp;lt;String&amp;gt;() { @Override public void completable(String s) { System.out.println(s); } @Override public void excetion(Throwable cause) { System.out.println(&amp;#34;Error&amp;#34;); cause.printStackTrace(); } }); //下面就可以执行其它逻辑了。。。 System.out.println(&amp;#34;。。。。。。。。。&amp;#34;); System.out.println(future.get()); System.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/java8-%E8%87%AA%E5%AE%9A%E4%B9%89collector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/java8-%E8%87%AA%E5%AE%9A%E4%B9%89collector/</guid><description>自定义Collector 实现Collector接口 package com.example.study.java8.collector; import java.util.*; import java.util.function.BiConsumer; import java.util.function.BinaryOperator; import java.util.function.Function; import java.util.function.Supplier; import java.util.stream.Collector; /** * 自定义Collector * T:元素类型 * List&amp;lt;T&amp;gt;:要创建的类型 * List&amp;lt;T&amp;gt;:最后要返回的类型 */ public class ToListCollector&amp;lt;T&amp;gt; implements Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; { private void log(final String log) { System.out.println(Thread.currentThread().getName()+&amp;#34;-&amp;#34;+log); } //一定时可变的supplier，不是固定值 @Override public Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; supplier() { log(&amp;#34;supplier&amp;#34;); return ArrayList::new; } //要进行的操作 @Override public BiConsumer&amp;lt;List&amp;lt;T&amp;gt;, T&amp;gt; accumulator() { log(&amp;#34;accumulator&amp;#34;); return List::add; } //将结果整合 @Override public BinaryOperator&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; combiner() { log(&amp;#34;combiner&amp;#34;); return (list1,list2)-&amp;gt;{ list1.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</guid><description>JVA8-自定义Spliterator 需求说明：将一段话按换行符分割成多个执行，并输出。
package com.example.study.java8.forkjoin; import java.util.Objects; import java.util.Spliterator; import java.util.function.Consumer; import java.util.stream.Stream; import java.util.stream.StreamSupport; /** * 自定义Spliterator * 实列：将一段话按换行符分割成多个执行，并输出。 */ public class SpliteratorInAction { //需要处理的数据 private static String text = &amp;#34;The tryAdvance method feeds the Consumer with the Character in the String at the current index\n&amp;#34; + &amp;#34;position and increments this position. The Consumer passed as argument is an internal Java class\n&amp;#34; + &amp;#34;forwarding the consumed Character to the set of functions that have to be applied to it while\n&amp;#34; + &amp;#34;traversing the stream, which in this case is only a reducing function, namely, the accumulate method\n&amp;#34; + &amp;#34;of the WordCounter class.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/lambda%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/lambda%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</guid><description>Lambda方法推导详细解析 什么情况下可以进行方法推导? 类的方法（静态方法）
对象的方法
构造方法
自定义函数式接口
范例： package com.example.study.java8.InterfaceFunction; import java.util.Arrays; import java.util.Comparator; import java.util.List; import java.util.function.BiFunction; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Supplier; /** * 方法推导 * 什么情况下可以进行方法推导： * 1、类的方法（静态方法） * 2、对象的方法 * 3、构造方法 */ public class MethodReferenceUsageDemoOne { public static void main(String[] args) { //方法推导，范例一：类的方法 //原始写法 Consumer&amp;lt;String&amp;gt; consumer = s-&amp;gt; System.out.println(s); genericityConsumer(consumer, &amp;#34;hello&amp;#34;); //1、进化一 genericityConsumer(s-&amp;gt;System.out.println(s), &amp;#34;world&amp;#34;); //2、进化二 genericityConsumer(System.out::println, &amp;#34;nice&amp;#34;); System.out.println(&amp;#34;===========================&amp;#34;); //方法推导，范例二：类的方法 List&amp;lt;Apple&amp;gt; list = Arrays.asList(new Apple(&amp;#34;red&amp;#34;, 10) , new Apple(&amp;#34;red&amp;#34;, 60) , new Apple(&amp;#34;blue&amp;#34;, 40) , new Apple(&amp;#34;black&amp;#34;, 30) , new Apple(&amp;#34;green&amp;#34;, 80) , new Apple(&amp;#34;blue&amp;#34;, 90) , new Apple(&amp;#34;green&amp;#34;, 60) , new Apple(&amp;#34;green&amp;#34;, 50) , new Apple(&amp;#34;red&amp;#34;, 20)); System.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>Lambda表达式 一、lambda语法 参数列表 lambda body部分
(o1,o2)-&amp;gt;o1.getWeight().compareTo(o2.getWeight());
二、 合法lamdba表达式 1、s -&amp;gt; s.length(); 或者 (String s) -&amp;gt; s.length();
2、apple -&amp;gt; apple.getColor().equals(&amp;ldquo;great&amp;rdquo;); 或者 (Apple apple) -&amp;gt; apple.getColor().equals(&amp;ldquo;great&amp;rdquo;);
3、(int x, int y) -&amp;gt; {
System.out.println(x);
System.out.println(y);
};
4、() -&amp;gt; 12;
5、()-{};
6、()-&amp;gt;“hello” 或者 ()-&amp;gt;{return &amp;ldquo;hello&amp;rdquo;}
三、语法总结 语法一、（参数列表） -&amp;gt; 表达式
语法二、（参数列表） -&amp;gt; {语句;}
有效lambda表达式 1、() -&amp;gt; {}
2、() -&amp;gt; &amp;ldquo;hello&amp;rdquo; 或者 ()-&amp;gt;{reurn &amp;ldquo;hello&amp;rdquo;}
3、(String str) -&amp;gt; {return &amp;ldquo;hello&amp;rdquo;} 或者 (String str) -&amp;gt; &amp;ldquo;hello&amp;rdquo;;
无效lambda表达式 (integer i)-&amp;gt;{return &amp;ldquo;错误示范&amp;rdquo;+i}</description></item><item><title/><link>https://willxwu.github.io/posts/java8/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</guid><description>Lambda表达式用法 用户范例 package com.example.study.java8.InterfaceFunction; /** * lambda表达式用法 */ public class LambdaUsage { public static void main(String[] args) { Runnable runnable1 = ()-&amp;gt; System.out.println(&amp;#34;hello&amp;#34;); Runnable runnable2 = new Runnable() { @Override public void run() { System.out.println(&amp;#34;hello&amp;#34;); } }; process(runnable1); process(runnable2); process(()-&amp;gt; System.out.println(&amp;#34;hello&amp;#34;)); } public static void process(Runnable runnable){ runnable.run(); } } 学习目标 一、Predicate：诊断，返回boolean类型
@FunctionalInterface
public interface Predicate {
/** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); 二、Consumer：消费者，没有返回类型</description></item><item><title/><link>https://willxwu.github.io/posts/java8/optional-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/optional-api/</guid><description>Optional API 一、Optional创建方式 前置条件： Insurance对象：
public class Insurance { private String name; public String getName() { return name; } } 1、empty 特点：使用get()方法时会抛出异常：No value present
范例：
Optional&amp;lt;Insurance&amp;gt; emptyOptional = Optional.&amp;lt;Insurance&amp;gt;empty(); 使用get（）获取结果：抛出异常
emptyOptional.get(); 输出结果:
Exception in thread &amp;#34;main&amp;#34; java.util.NoSuchElementException: No value present at java.base/java.util.Optional.get(Optional.java:148) 2、of 特点：使用get（）,不会抛异常
范例：
Optional&amp;lt;Insurance&amp;gt; ofInsurance = Optional.of(new Insurance()); ofInsurance.get(); 3、ofNullable 特点：上面两者综合，为null是掉empty，不为空调of。
3.1、为null时，调get()抛出异常 范例：
Optional&amp;lt;Insurance&amp;gt; ofNullableOptionalNull = Optional.ofNullable(null); ofNullableOptionalNull.get(); 输出结果：
Exception in thread &amp;#34;main&amp;#34; java.util.NoSuchElementException: No value present 3.2、不为null时，调get()不报错 范例：</description></item><item><title/><link>https://willxwu.github.io/posts/java8/stream-%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/stream-%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F/</guid><description>Stream数据类型 1、mapToInt、mapToLong、mapToDouble ## 可以将包装类拆箱成基本数据类型，节约内存空间 ## 范例：
方式一：reduce实现
//方式一：reduce实现 List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); list.stream().reduce(Integer::sum).ifPresent(System.out::println); 方式二：mapToInt
//方式二：mapToInt list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); IntStream mapToInt = list.stream().mapToInt(i -&amp;gt; i.intValue()); int sum = mapToInt.sum(); System.out.println(sum); 方式三：mapToInt后用reduce实现
//方式三：mapToInt后用reduce实现 list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); IntStream intStream = list.stream().mapToInt(i -&amp;gt; i.intValue()); int reduce = list.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/stream%E5%B8%B8%E8%A7%81api%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/stream%E5%B8%B8%E8%A7%81api%E4%BD%BF%E7%94%A8/</guid><description>二、Stream API：filter、distinct、skip、limit 被操作数据
List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); 1、filter 过滤 范例：
//filter 过滤 List&amp;lt;Integer&amp;gt; filterResult = list.stream().filter(i -&amp;gt; i % 2 == 0).collect(toList()); filterResult.stream().forEach(System.out::println); 2、distinct 去重 范例：
//distinct 去重 List&amp;lt;Integer&amp;gt; distinctResult = list.stream().distinct().collect(toList()); distinctResult.stream().forEach(System.out::println); 3、skip 截断 范例：
//skip 截断(跳过前面几个,超过长度，直接返回空) List&amp;lt;Integer&amp;gt; skipResult = list.stream().skip(5).collect(toList()); skipResult.stream().forEach(System.out::println); 4、limit 查询几条 范例：
//limit 查询几条 List&amp;lt;Integer&amp;gt; limitResult = list.stream().limit(3).collect(toList()); limitResult.stream().forEach(System.out::println); 二、Stream API：Map 1、map 数据处理 被操作数据
List&amp;lt;Integer&amp;gt; list = Arrays.</description></item><item><title/><link>https://willxwu.github.io/posts/java8/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAstream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java8/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAstream/</guid><description>创建Stream 创建Stream方式： 创建Stream的方式 1、通过Collection 2、通过values 3、通过Arrays 4、通过file 5、通过iterate创建,无限的创建 6、通过Generate创建 7、自定义Supplier，创建Stream 使用范例 1、Collection创建，输出值顺序与之前放入值顺序一致。 范例：
/** * 通过Collection创建Stream，数据顺序和放入顺序一致 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByCollection(){ List&amp;lt;String&amp;gt; list = Arrays.asList(new String(&amp;#34;Hello&amp;#34;), new String(&amp;#34;world&amp;#34;), new String(&amp;#34;please&amp;#34;)); return list.stream(); } 2、values创建,输出值顺序与之前放入值顺序一致。 范例：
/** * 通过values创建Stream，顺序一直 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByValues(){ return Stream.of(&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;,&amp;#34;please&amp;#34;); } 3、Arrays创建,输出值顺序与之前放入值顺序一致。 范例：
/** * 3、通过Arrays创建，顺序一致 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByArrays(){ return Arrays.stream(new String[]{&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;,&amp;#34;please&amp;#34;}); } 4、File创建 范例：
/** * 4、通过file创建 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByFile(){ Path path = Paths.</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C/</guid><description>利用JAVA原生JDBC进行数据库的CRUD操作。简单记录一下。
package learn.javase.jdbc; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Scanner; import java.sql.PreparedStatement; import java.sql.Connection; /** * jdbc使用 * @author Jole * */ public class MyDriver { public static void main(String[] args) throws ClassNotFoundException, SQLException{ //1.注册驱动 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); //2.获取数据库连接对象 String url = &amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;; String user = &amp;#34;root&amp;#34;; String password = &amp;#34;111111&amp;#34;; Connection conn = DriverManager.getConnection(url, user, password); // System.out.println(conn); //3.获取连接平台的执行对象 // Statement st = conn.createStatement(); //4.执行sql,返回行数 //executeUpdate():增删改 //String sql = &amp;#34;insert into user(user_id,user_name,user_password) values(&amp;#39;1320442338427273213&amp;#39;,&amp;#39;zss&amp;#39;,&amp;#39;12&amp;#39;)&amp;#34;; //int n = st.</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%8F%8D%E5%B0%84/</guid><description>获取反射对象的3种方法。通过反射创建对象、通过反射获取有参、无参、公有、私有构造方法。通过反射获取公有、私有成员变量并修改之。通过反射获取成员方法，并调用。通过反射泛型擦除，存值。通过读取配置文件运行反射方法。
package learn.javase.mycalss; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; /** * 一、获取class的三种方式 * * 二、获取公有构造方法 * 注意： * 1、被反射的类必须是有空参数的构造器 * 2、构造方法必须是public的才能反射获取 * * 三、获取所有构造方法 * * @author Jole * */ public class ClassDemo { public static void main(String[] args) throws Exception{ // 方式1、.getClass() Person p = new Person(); Class c = p.getClass(); System.out.println(c); //方式2、类名.class Class c3 = Person.class; System.out.println(c3); //方式3、Class.forName(类全名); Class c2 = Class.forName(&amp;#34;learn.javase.mycalss.Person&amp;#34;); System.out.println(c2); Class personClass = Class.</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%9F%BA%E7%A1%80%E4%B8%80/</guid><description>总结一下JAVA基础知识如：注释、关键字、标识符、数据类型、变量、数据类型转换等基础语法。初学者可参考看看。
1、程序注释 单行注释：
//xxxxxx 多行注释：
/* xxxxxx */ 文档注释：
/** xxxxxx */ 2、关键字 关键字：是被Java语言赋予特殊含义，具有专门用途的单词。所有的Java关键词，都是小写。关键词比较多，不用刻意去背，以后用多了自己就记住了。
3、标识符 Java中除了关键字以外基本上都是标识符。我们自己定义的词，比如自己定义的HelloWorld。
标志符命名规则：
标志符组成：字母、数字、下划线、美元符号 字母：a~z、A~Z 数字：0-9 下划线：_ 美元符号：$ 注意：不能数字开头，不能是关键字，严格区分大小写，不限制长度起名时，尽量达到见名知意。
4、数据类型 数据类型分为基本数据类型和引用数据类型。
A、基本数据类型：4类8种（4类展开后共8种基本类型），基本数据类型是JAVA中内置的类型。
第一类：整型
字节
byte 1个字节 二进制位数：8 -128～127 短整型
short 2个字节 二进制位数：16 包装类：java.lang.Short 最小值：Short.MIN_VALUE=-32768 （-2的15此方） 最大值：Short.MAX_VALUE=32767 （2的15次方-1） 整型
int 4个字节 二进制位数：32 包装类：java.lang.Integer 最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方） 最大值：Integer.MAX_VALUE= 2147483647 （2的31次方-1） 长整型
long 8个字节 二进制位数：64 包装类：java.lang.Long 最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方） 最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1） 第二类：浮点型
单精度
float 4个字节 二进制位数：32 包装类：java.lang.Float 最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方） 最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1） 注意：必须已“F”结尾，java才认为是float类型，否则默认认为是double类型。</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid><description>JAVA流程控制语句JAVA中非常重要的基础知识点务必完全理解掌握，总结记录一下之前学习笔记。JAVA流程控制语句是编程的基础知识，主要是为了更好的组织代码的执行流程，下面将详细介绍java流程控制语句。
一、选择结构if if条件语句分为三种格式。
if语句
如果满足某种条件就执行。
if语句格式：
if（条件）{ 语句的执行体 } 条件：结果必须是布尔类型 1==1 true || false 执行体：当id条件为true的时候，执行大括号中的语句，否则什么都不做。
例如：
/** * if语句例子 */ public class IfDemo { public static void main(String[] args) { // TODO Auto-generated method stub int i = 5; if(i==5) { System.out.println(&amp;#34;if中的条件是true&amp;#34;); i++; } System.out.println(&amp;#34;i=&amp;#34;+i); } } 注意：if()括号后面没有分号&amp;quot;;&amp;quot;
if&amp;hellip;else语句
如果满足某种条件，就执行某种处理，否则就执行另一种处理。
if &amp;hellip; else语法格式：
if(条件){ if的执行体 }else{ else的执行体 } 当if中的条件为true时，执行if的执行体，为false时，执行else的执行体。
例如：
** * if ... else 语句 * */ public class IfElseDemo { public static void main(String[] args) { int i = 13; if(i%2==0) { System.</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>进程：CPU为每个应用程序分配的独立空间，一个进程可能有多个线程。进程为线程中的摸个执行任务程序，多个进程之间可以进行共享数据。而JAVA的线程则是由JVM进程分配的，main方法所在线程，则成为主线程。
〇、线程状态 正常情况线程执行步骤：新建-》运行-》死亡
当CPU资源不够时，CUP分配给各个线程的资源可能不同(貌似有点像是线程在抢资源，实际是CPU分配资源给每个线程)。 因此就会出现线程的阻塞、休眠、等待3个状态。其中阻塞状态，当cpu资源够时，阻塞状态的线程可能恢复到运行状态，而休眠、等待的线程也可能进入运行状态。休眠、等待状态可能转换成阻塞状态，但是阻塞状态不会变成休眠、等待状态。
一、多线程的实现 0、线程常用方法 package learn.javase.threads; /** * 继承Thread创建线程，设置线程名称、获取线程名称 * @author Jole * */ public class ThreadDemo01 { public static void main(String[] args) { MyThreadsDemo mt = new MyThreadsDemo(); mt.setName(&amp;#34;Hi&amp;#34;); mt.start(); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName()); } } 线程实现方式主测试类：
package learn.javase.threads; public class MyThreadsDemo extends Thread{ public MyThreadsDemo() { super(&amp;#34;Google&amp;#34;); } public void run() { for(int i=0;i&amp;lt;5;i++) { try { Thread.sleep(1000); System.out.println(i); }catch(Exception e) { System.out.println(e.getMessage()); } } } } 线程测试主类：</description></item><item><title/><link>https://willxwu.github.io/posts/java%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E5%BC%82%E5%B8%B8/</guid><description>异常 Throwable Throwable类是所有错误跟异常类的超类.
Exception Exception异常类及其子类都是继承自Throwable类，用来表示java中可能出现的异常，并且合理的处理这些异常。
RuntimeException RuntimeException类是运行异常类，继承自Exception类，它以及它的子类只能在运行过程中存在，当出现时，只能修改源代码，此异常无法处理。
特点：
方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常
运行时期异常一旦发生,需要程序人员修改源代码
Error Error类是与Exception的平级的类，用来表示Java中存在的严重错误，只能通过修改代码来解决问题。
区别 Exception与Error区别：
Exception是指程序在编译或者运行时出现的某种异常问题，我们可以对异常进行某种处理，如果不处理异常的话，程序将会停止运行。
Error是指程序在运行时出现的严重问题，无法处理，程序将会停止运行，Error通常都是系统级别的问题，都是虚拟机jvm所在系统发生的，只能通过修改源代码解决问题。
异常的产生 运行或编译时产生异常。 创建异常类的对象。 声明异常类。 将异常类对象传给调用者（main()方法）处理。 调用者无法处理，再将异常类对象传给jvm虚拟机。 jvm虚拟机将异常类的信息（名称、详细信息、异常所处的位置）打印在屏幕上，并且停止程序的运行。 抛出异常throw 在java中，提供了一个throw关键字，用来抛出一个指定的异常。
使用方法：
1.创建一个异常对象。封装一些提示信息
2.将这个异常告知调用者
使用格式：throw new 异常类名（参数）；
声明异常throws 声明异常格式：
修饰符 返回值类型 方法名称 （参数）throws 异常1名称，异常2名称{
}
捕获异常try&amp;hellip;catch&amp;hellip;finally
捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理
语句格式：
ry { //需要被检测的语句。 }catch(异常类 变量) { //参数。 //异常的处理语句。 }finally { //一定会被执行的语句。 } try：该代码块中编写可能产生异常的代码。
catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。
finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。
捕获异常的组合方式 try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放。 try catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。 一个try 多个catch组合: 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 try finally 组合: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。 package learn.</description></item><item><title/><link>https://willxwu.github.io/posts/java%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/java%E6%95%B0%E7%BB%84/</guid><description>JAVA数组重点掌握知识，以后肯定会用到的，可以了解一下底层原理。数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。
数组 数组定义格式：
数据类型[] 数组名(变量名) = new 数据类型[元素个数或数组长度]; 实例：
public class ArrayDemo01 { public static void main(String[] args) { int[] x = new int[100]; } } 注意：数组定长，一但定义长度为100，在使用时大小就是100了。不变量。
数组特点：定长、引用类型。
JVM java程序运行时，操作系统会给jvm虚拟机分配一块内存。JVM又会将这块内存，进行划分管理。
JVM内存划分：JVM对自己的内存进行了划分，分成5个区域。
1、寄存器：内存和CPU之间。 2、本地方法栈：JVM调用操作系统中的功能。 3、方法和数据共享：运行时其class文件，进入的地方。 4、方法栈：所有的方法运行的时候，进入的内存。 5、堆：存储的是容器和对象。 开发人员主要关心：方法和数据共享、方法栈、堆。
数组内存划分 首先，运行class文件，所以先进入方法区。 运行main方法，在方法栈中运行，但是main用不了那么多，所以方法栈中会分配一块给main方法是用。 执行数组，一个容器，所以JVM在堆内存，开空间，存储数组容器。 JVM会将该地址，给定义的数组变量arr（相当于arr引用了这个地址），所以数组是引用类型。 每次运行，JVM分配的地址是不同的。 当main方法运行完了，arr变量就没了，然后new int[3]也就没了 ，JVM垃圾回收机制，会自动帮我们回收，不用我们去处理了。 堆空间太大，怎么找到这个容器呢，所以每个数组，在内存中，都有自己的内存地址，也就是数组元素的首地址，第一个数据的地址。
注意：arr引用类型，保存的数据，实际上是内存中的地址。
数组元素的访问 数组是一个容器，存储到数组中的每个元素，都有自己的自动编号/下标（专业名词：索引）。
访问数组存储的元素，必须依赖索引。
访问公式：数组名[索引]
public class ArrayDemo02 { public static void main(String[] args) { int[] arr = new int[3]; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); } } 一初始化时，数组里面就有了默认值。</description></item><item><title/><link>https://willxwu.github.io/posts/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</guid><description>JDK1.8的新特性 一、接口的默认方法 Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：
代码如下：
interface Formula{ double calculate(int a); default double sqrt(int a){ return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下： Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0
文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt（a*100）。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注：在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，Java8的这个在语义上有差别。
二、Lambda表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下：
List names=Arrays.asList（&amp;ldquo;peterF&amp;rdquo;，&amp;ldquo;anna&amp;rdquo;，&amp;ldquo;mike&amp;rdquo;，&amp;ldquo;xenia&amp;rdquo;）； Collections.sort（names，new Comparator）{@Override public int compare（String a，String b）{ return b.compareTo（a）；}}）；
只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java8中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式： 代码如下： Collections.sort（names，（String a，String b）-&amp;gt;{return b.compareTo（a）；}）；
看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下： Collections.sort（names，（String a，String b）-&amp;gt;b.compareTo（a）；
对于函数体只有一行代码的，你可以去掉大括号0以及return关键字，但是你还可以写得更短点：
代码如下： Collections.sort（names，（a，b）&amp;gt;b.compareTo（a）；
Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：
三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？
每一个lambda表达式都对应一个类型，通常是接口类型。 而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@Functionallnterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。
示例如下：
代码如下： @Functionallnterface interface Converter&amp;lt;F，T&amp;gt;{T convert（F from）；}Converter&amp;lt;String，Integer&amp;gt;converter= from）-&amp;gt;Integer.</description></item><item><title/><link>https://willxwu.github.io/posts/k8s%E9%83%A8%E7%BD%B2%E7%BC%96%E6%8E%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/k8s%E9%83%A8%E7%BD%B2%E7%BC%96%E6%8E%92/</guid><description>初识k8s 简介： Kubernetes 简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。 中文官网：https://kubernetes.io/zh/ 中文社区：https://www.kubernetes.org.cn/ 官方文档：https://kubernetes.io/zh/docs/home/ 社区文档：http://docs.kubernetes.org.cn/
部署方式的进化 https://kubernetes.io/zh/docs/concepts/overview/
功能 架构 整体主从方式 Master 节点架构 kube-apiserver 对外暴露K8S 的api 接口，是外界进行资源操作的唯一入口。
提供认证、授权、访问控制、API 注册和发现等机制。
etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes 所有集 群数据的后台数据库。 Kubernetes 集群的etcd 数据库通常需要有个备份计划
kube-scheduler 主节点上的组件，该组件监视那些新创建的未指定运行节点的Pod，并选择节点 让Pod 在上面运行。 所有对k8s 的集群操作，都必须经过主节点进行调度
kube-controller-manager 在主节点上运行控制器的组件 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维 护正确数量的Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入Service 与Pod)。 服务帐户和令牌控制器（Service Account &amp;amp; Token Controllers）: 为新的命名 空间创建默认帐户和API 访问令牌
Node 节点架构 kubelet 一个在集群中每个节点上运行的代理。它保证容器都运行在Pod 中。 负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；
kube-proxy 负责为Service 提供cluster 内部的服务发现和负载均衡；
容器运行环境(Container Runtime) 容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、containerd、cri-o、rktlet 以及任 何实现Kubernetes CRI (容器运行环境接口)。</description></item><item><title/><link>https://willxwu.github.io/posts/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</guid><description>K8S集群部署
一、虚拟机搭建 通过Oracle VM VirtualBox，Vagrant搭建三台虚拟机。
1、修改Vagrantfile文件，批量创建3台虚拟机，内容如下：该文件是放在个人用户名文件夹下的。
Vagrant.configure(&amp;#34;2&amp;#34;) do |config| (1..3).each do |i| config.vm.define &amp;#34;k8s-node#{i}&amp;#34; do |node| # 设置虚拟机的Box node.vm.box = &amp;#34;centos/7&amp;#34; config.vm.box_url = &amp;#34;https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box&amp;#34; # 设置虚拟机的主机名 node.vm.hostname=&amp;#34;k8s-node#{i}&amp;#34; # 设置虚拟机的IP node.vm.network &amp;#34;private_network&amp;#34;, ip: &amp;#34;192.168.56.#{99+i}&amp;#34;, netmask: &amp;#34;255.255.255.0&amp;#34; # 设置主机与虚拟机的共享目录 # node.vm.synced_folder &amp;#34;~/Documents/vagrant/share&amp;#34;, &amp;#34;/home/vagrant/share&amp;#34; # VirtaulBox相关配置 node.vm.provider &amp;#34;virtualbox&amp;#34; do |v| # 设置虚拟机的名称 v.name = &amp;#34;k8s-node#{i}&amp;#34; # 设置虚拟机的内存大小 v.memory = 2048 # 设置虚拟机的CPU个数 v.cpus = 4 end end end end 注意一个细节，如果一次卡在文件复制过程中，检查是否复制了全部个人目录下数据。如果是请修改Vagrantfile文件：
C:\Users\自己用户名\.vagrant.d\boxes\centos-VAGRANTSLASH-7\0\virtualbox\Vagrantfile Vagrant.configure(&amp;#34;2&amp;#34;) do |config| config.</description></item><item><title/><link>https://willxwu.github.io/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/keytool%E8%AF%81%E4%B9%A6%E5%AF%BC%E5%85%A5/</guid><description>最近项目对接时，中间B2B服务切换了域名，导致现有项目调用接口地址需要进行切换为https，同时需要安装SSL证书，这里记录一下JAVA工具keytool导入证书的过程。
一、问题点 切换域名后加上https，未导入证书报错:
[ERROR] - [2022-02-25 08:49:40.861] - [http-nio-9999-exec-1] - [DealParamAction.java:needConfirmAction:133] - no confirm method, call actual method = getNSDDtailByInterface [INFO ] - [2022-02-25 08:50:04.483] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:04.484] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:445] - Retrying request [INFO ] - [2022-02-25 08:50:25.487] - [http-nio-9999-exec-1] - [HttpMethodDirector.java:executeWithRetry:439] - I/O exception (java.net.ConnectException) caught when processing request: Connection timed out: connect [INFO ] - [2022-02-25 08:50:25.</description></item><item><title/><link>https://willxwu.github.io/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</guid><description>Map集合的2种循环方式。一种是通过map.entrySet()。
另一种是map.keySet()。 所有的集合都可以通过迭代器Iterator，进行遍历。
package learn.javase; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set; /** * 重要 * 遍历map的两种方式map.entrySet() map.keySet() * @author Jole * */ public class MapDemo { public static void main(String[] args) { Map&amp;lt;Integer ,String &amp;gt; map = new HashMap(); map.put(1, &amp;#34;111&amp;#34;); map.put(2, &amp;#34;2222&amp;#34;); //方式一 entrySet() Set&amp;lt;Map.Entry &amp;lt;Integer, String&amp;gt;&amp;gt; sets = map.entrySet(); //获取值1，通过for for(Map.Entry &amp;lt;Integer, String&amp;gt; entry : sets) { System.out.println(&amp;#34;ssss:&amp;#34;+entry); System.out.println(&amp;#34;key:&amp;#34;+entry.getKey()+&amp;#34;value:&amp;#34;+entry.getValue()); } //获取值2，通过iterator Iterator &amp;lt;Map.Entry &amp;lt;Integer, String&amp;gt;&amp;gt; itt = sets.</description></item><item><title/><link>https://willxwu.github.io/posts/maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>maven依赖冲突解决方案 1、找到项目pom文件。
2、快捷键打开依赖图。
ctlr+alt+shift+u 3、红色表示冲突。
4、右键exclude排除。</description></item><item><title/><link>https://willxwu.github.io/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/maven%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>使用maven的好处： 大型项目的好处，建立一个父项目，各组或部门可以模块开发，不用拉取整个项目进行开发。
创建maven项目说明： maven项目结构： Maven常用命令： 1、一键构建项目命令:
mvn tomcat:run 注意：该命令使用的是tomcat插件进行运行的，不需要单独安装配置tomcat。
2、清理编译好后的文件（target文件夹及里面所有的文件）：
mvn clean 3、编译并运行了main里面的代码（只编译main主文件里面的java代码，test里面的java代码不编译不编译）：
mvn compile 4、编译并运行了test里面的代码(只编译test里面的java代码，main里面的java代码不编译)：
mvn test 5、打包，并将包放到tager文件夹下面。打成war或jar名称由POM文件里面的这3个标签值决定： 例如打包成这个名字:HelloWorld-0.0.2-SNAPASHOT.war HelloWorld &amp;ndash;打成包的名字 0.0.2-SNAPASHOT &amp;ndash;版本 war &amp;ndash;什么类型的包
mvn package 6、把项目发布到本地仓库
mvn install 同时运行了mvn compile、mvn test、mvn package、mvn install、mvn deploy命令。
7、jar或war包发布到私服上
mvn deploy maven生命周期有三种： 1、clean生命周期：clean 2、default生命周期：compile、test、package、install、deploy命令 3、site生命周期:site(生成项目的文档说明)
不同的生命周期，命令可以同时运行。
maven依赖范围： complie
provided:编译（complie）时需要、测试时也需要、运行时不需要，打包时不需要
runtime：例如：数据库驱动包
test：编译时不需要，测试时需要、运行时不需要
maven添加插件： 常见问题： 出现该提示表示jdk安装有问题，重新安装即可。
maven整体模型也就是上面说的内容： 版本冲突解决原则：
1、路径近者原则（比如2个坐标中有不同版本的相同的jar包，自己在加入要使用的版本的这个名称的坐标）
2、第一声明有限原则（比如2个坐标，谁排在pom.xml文件的前面就用谁的）
3、排除原则.（将名字和组织加入到exclusion中） 4、版本锁定 谁先传递锁定的版本，就用这个。 可以同时锁定多个版本
锁定版本里面使用${sprint.verion}
注意上面锁定了，坐标里面的version就没有了，可以去除，就算不去除也没有了。</description></item><item><title/><link>https://willxwu.github.io/posts/mycat%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/mycat%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85/</guid><description>MyCat 一、基础知识 1、分布式系统 ​ 分布式系统是指其组件分布在网络上，组件之间通过传递消息进行通信和动作协调的系统。它的核心理念是让多台服务器协同工作，完成单台服务器无法处理的任务，尤其是高并发或者大数据量的额任务。它的特点是：
​ **透明性：**分布式系统对于用户是透明的，一个分布式系统在用户面前的表现就像一个传统的单处理机分时系统，可用用户不必了解其内部结构就能使用;
​ **扩展性：**分布式系统的最大特点是可扩展性，它能够根据需求的增加而扩展，可以通过横向扩展使集群的整体性能得到线性提升，也可以通过纵向扩展单台服务器的性能使服务器集群的性能得到提升;
​ **可靠性：**分布式系统不允许单点失效的问题存在，它的基本思想是，如果一台机器坏了，则其他机器能够接替它进行工作，具有持续服务的特性;
​ **高性能：**高性能才是设计分布式系统的初衷.
​ 分布式系统的缺点：
​ 1、在节点通信部分的开销比较大，线程安全问题也变得复杂，需要在保证数据完整性的同时兼顾性能
​ 2、过分依赖网络，网络信息的丢失和饱和将会抵消分布式系统的大部分优势
​ 3、有潜在的数据安全和网络安全等安全性问题。
2、分布式数据库 ​ 随着技术的发展，各个行业所产生的数据量呈爆炸式增长，动辄就达到数百TB或者PB的级别，已经远远超过了传统单机数据库的处理能力，因此分布式数据库已经成为了最最迫切的需求。
​ 分布式数据库是指数据在物理上分步而在逻辑上集中管理的数据库系统。物理上分步是指分布式数据库的数据分步在物理位置不同并由网络连接的节点或站点上；逻辑上集中是指各数据库节点之间在逻辑上是一个整体，并由统一的数据库管理系统管理，不同的节点分步可以跨不同的机房、城市甚至国家。
​ 分布式数据库的特点:
​ **透明性：**用户不必关系数据的逻辑分区和物理位置分步的细节，也不必关系重复副本的一致性问题，同时不必关系在局部场地上数据库支持哪种数据模型，对于开发工程师而言，当数据库从一个场地移到另一个场地时必须改写应用程序，使用起来如果一个数据库。
​ **数据冗余性：**分布式数据库通过冗余实现系统的可靠性、可用性，并改善其性能。多个节点存储数据副本，当某一个节点的数据遭到破坏时，冗余的副本可保证数据的完整性；当工作的节点受损害时，可通过心跳等机制进行切换，系统整体不被破坏。还可以通过热点数据的就近分步原则减少网络通信的消耗，加快访问速度，改善性能。
​ **易于扩展性：**在分布式数据库中能够方便地通过水平扩展提高系统的整体性能，也能够通过垂直扩展来提高性能，扩展并不需要修改系统程序。
​ **自治性：**各节点上的数据由本地的DBMS管理，具有自治处理能力，完成本场地的应用或局部应用
​ 分布式数据库还具有经济、性能优越、响应速度更快、灵活的体系结构、易于继承现有系统等特点。
3、分布式数据库的实现原理 ​ 分布式数据库具有逻辑整体性、物理分布式，正是因为其物理分布性才使得分布式数据库的实现变得更加复杂，因为数据划分后存储在不同的节点上，而为了保证可靠性，需要存储多个副本，所以产生了数据复制的问题。为了保证良好的性能，分布式数据库必须易于扩展，具体来讲分布式数据库应有4个优势：数据分片及复制管理、具有事务的可靠性存取、良好的性能、易于扩展，所以分布式数据库在设计上需要实现数据库数据库的目录管理、数据分片、分布式查询处理、分布式并发控制、分布式锁管理、分布式存储、分布式网络架构、分布式安全管理等。
​ 1、分布式数据库的目录管理
​ 分布式数据库的目录存放着系统元数据及数据库的元数据的全部信息，这些数据的存在是为了正确、有效地访问数据。数据的增删改查操作都需要用到目录，用户授权、安全管理及并发控制等也都需要用到目录，目录结构的合理性直接影响数据库的性能。目录一般包括各级的描述、访问方法的描述、关于数据库的统计数据和一致性信息等，系统根据这些信息将用户查询转换为物理数据库上的查询，选择一条最佳的存取路径进行事务管理及安全性、完整性检查等。
​ 分布式数据库的目录课分为全局目录、分布式目录、全局与本地混合目录。
​ 2、数据分片
​ 当数据库过于庞大，尤其是写入过于频繁且很难由一台主机支撑时，我们还是会面临扩展瓶颈。我们将存放在同一个数据库实例中的数据分散存放到多个数据库实例上，进行多台设备存取以提高性能，在切分数据的同时可以提高系统整体的可用性。
​ 数据分片是指将数据全局地划分为相关的逻辑片段，有水平切分、垂直切分、混合切分三种类型。
​ **水平切分：**按照某个字段的某种规则分散到多个节点库中，每个节点中包含一部分数据。可以将数据的水平切分简单理解为按照数据行进行切分，就是将表中的某些行却分到一个节点，将另外某些行切分到其他节点，从分布式的整体来看它们是一个整体的表
​ **垂直切分：**一个数据库由很多表构成，每个表对应不同的业务，垂直切分是指按照业务将表进行分类并分不到不同的节点上，垂直拆分简单明了，拆分规则明确，应用程序模块清晰、明确、容易整合，但是某个表的数据量达到一定程度后扩展起来比较困难。
​ **混合切分：**水平切分和垂直切分的结合
​ 3、分布式查询处理
​ 分布式查询处理的任务就是把一个分布式数据库上的高层次查询映射为在本地数据库上的操作，查询的解析必须拆分为代数查询的关系运算序列，将要查询的数据定位到各节点，使得查询在各节点进行，最后通过网络通信的操作汇聚查询结果。
​ 4、分布式并发控制
​ 并发控制是分布式事务管理的基本任务之一，其目的是保证分布式数据库中的多个事务并发高效、正确的执行。并发控制用来保证事务的可串行性，也就是说事务的并发执行等价于它们按某种次序的串行执行，从而为用户提供并发的透明性。进行并发控制的方法主要有三种：加锁并发控制、时间戳控制、乐观并发控制。加锁并发控制应用广泛，但是容易发生死锁；时间戳控制消除了死锁，一旦发生冲突变回重启而不是等待，需要有全局的统一时钟；乐观并发控制对于冲突较少的系统较为合适，对于冲突多的系统则效率低下。
4、OLTP和OLAP ​ 在互联网时代，海量数据的存储和访问成为系统设计与使用的瓶颈，对于海量数据处理，按照使用场景，主要分为两种类型：联机事务处理（OLTP）和联级分析处理（OLAP）。</description></item><item><title/><link>https://willxwu.github.io/posts/mycat%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/mycat%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid><description>MyCat的安装及使用 一、MyCat的安装 1、环境准备 ​ 本次课程使用的虚拟机环境是centos6.5，首先准备四台虚拟机，安装好mysql，方便后续做读写分离和主从复制。
192.168.85.111 node01 192.168.85.112 node02 192.168.85.113 node03 192.168.85.114 node04 ​ 安装jdk
​ 使用rpm的方式直接安装jdk，配置好具体的环境变量
2、安装 ​ 从官网下载需要的安装包，并且上传到具体的虚拟机中，我们在使用的时候将包上传到node01这台虚拟机，由node01充当MyCat。
​ 下载地址为：http://dl.mycat.org.cn/1.6.7.5/2020-4-10/
解压文件到/usr/local文件夹下
tar -zxvf Mycat-server-1.6.7.5-release-20200422133810-linux.tar.gz -C /usr/local 配置环境变量
vi /etc/profile 添加如下配置信息： export MYCAT_HOME=/usr/local/mycat export PATH=$MYCAT_HOME/bin:$PATH:$JAVA_HOME/bin 当执行到这步的时候，其实就可以启动了，但是为了能正确显示出效果，最好修改下MyCat的具体配置，让我们能够正常进行访问。
3、配置MyCat ​ 进入到/usr/local/mycat/conf目录下，修改该文件夹下的配置文件
1、修改server.xml文件
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!-- - - Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); - you may not use this file except in compliance with the License. - You may obtain a copy of the License at - - http://www.</description></item><item><title/><link>https://willxwu.github.io/posts/mysql-5.7.33-winx64.zip%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/mysql-5.7.33-winx64.zip%E5%AE%89%E8%A3%85/</guid><description>mysql-5.7.33-winx64.zip安装 一、解压到安装目录 二、编写配置文件my.ini 将编写好的配置文件放到mysql-5.7.33-winx64根目录下。
配置文件如下：
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = D:\\tools\mysql-5.7.33-winx64 # 设置mysql数据库的数据的存放目录 datadir = D:\\tools\mysql-5.7.33-winx64\data # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 注意：
**1、修改自己安装路径 **
2、使用管理员权限执行下面的安装命令
三、执行安装脚本 使用管理员权限打开cmd命令工具，进入D:\tools\mysql-5.7.33-winx64\bin目录。执行安装：
1、初始化，生成data文件夹. （建议使用，不设置root密码）
mysqld --initialize-insecure 或者 mysqld --initialize（不建议使用，生成一个随机的root密码） 2、安装MySql服务 mysqld -install 3、启动服务 net start mysql 4、设置mysql密码 使用空密码进入mysql数据库，设置密码。
set password for root@localhost = password(&amp;#39;helloworld&amp;#39;); 5、环境变量配置 打开电脑环境变量配置
系统环境，PATH环境变量下，新增bing目录
D:\tools\mysql-5.7.33-winx64\bin</description></item><item><title/><link>https://willxwu.github.io/posts/mysql%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/mysql%E4%BC%98%E5%8C%96/</guid><description>索引 一、全表扫描 没有使用索引的时候，数据的查询需要进行多次IO读写，这样的性能较差——全表扫描的过程。
二、索引 为数据库的某个字段创建索引，相当是为这个字段的内容创建了一个目录。通过这个目录可以快速的实现数据的定位，也就是通过索引能够快速的找到某条数据所在磁盘的位置。
三、索引存放位置 InnoDB存储引擎的表：将索引和数据存放在同一个文件里。（为什么？有什么优势？）*ibd MyISAM存储引擎的表：索引和数据分开两个文件来存储。 索引：*.MYI； 数据：MYD 四、索引分类 1、主键索引：主键自带索效果，也就意味着通过主键来查询表中的记录，性能是非常好的。
2、普通索引：为普通列创建的索引。
索引名一般格式: **idx_字段名** create index 索引名 on 表明(字段); 例子： create index idx_participant_ on cal_resource_permission(participant_); 3、唯一索引：就像是唯一列，列中的数据是唯一的。比普通索引的性能要好。
唯一索引名称：idx_unique_列明 create unique index 唯一索引名称 on 表明(列名); 例子： create unique index idx_unique_resource_id_ on cal_resource_permission(resource_id_); 4、联合索引（组合索引）：一次性为表中的多个字段一起创建索引,最左前缀法则（如何命中联合索引中的索引列）。注意：一个联合索引建议不要超过5个列
格式：联合索引名一般格式: idx_字段1_字段2_字段3 create index 联合索引名 on 表明(字段1,字段2,字段3); 例子： create index idx_resource_scope_type on cal_resource_permission(resource_id_,scope_,type_id_); 5、全文索引：进行查询的时候，数据源可能来自于不同的字段或者不同的表。比如去百度中查询数据，yanxizhu，来自于网页的标题或者网页的内容。
MyISAM存储引擎支持全文索引。
在实际生产环境中，并不会使用MySQL提供的MyISAM存储引擎的全文索引功能来是实现全文查找。而是会使用第三方的搜索引擎中间件比如ElasticSearch（比较多）、Solr。
索引使用的数据结构 使用索引查找数据性能很快，避免了全表扫描的多次磁盘IO读写。但是我们发现，使用索引实际上也需要在索引中查找数据，而且数据量是一样的，那么凭什么索引就能快呢？这就跟索引使用了哪种数据结构支持快速查找。
什么叫数据结构：存放数据的结构。比如：数组、链表、栈、堆、队列等等这些概念。
一、线性表 线性的维护数据的顺序。对于线性表来说，有两种数据结构来支撑：
线性顺序表：相邻两个数据的逻辑关系和物理位置是相同的。
线性链式表：相邻两个数据的逻辑关系和物理存放位置没有关系。数据是有先后的逻辑关系，但是数据的物理存储位置并不连续。
线性链式表又分为单项链表和双向链表：
单向链表：能够通过当前结点找到下一个节点的位置，以此来维护链表的逻辑关系
结点结构：数据内容+下一个数据的指针
双向链表：能够通过当前结点找到上一个或下一个节点的位置，双向都可找。
结点结构：上一个数据的指针+数据内容+下一个数据的指针。</description></item><item><title/><link>https://willxwu.github.io/posts/nacos%E6%8C%81%E4%B9%85%E5%8C%96mysql%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/nacos%E6%8C%81%E4%B9%85%E5%8C%96mysql%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>Nacos持久化MySQL问题-解决方案 一、说明 环境说明：
MySQL：CentOS环境通过Docker部署的MySQL5.7
Nacos：2.0.3
原始配置：
### If use MySQL as datasource: # spring.datasource.platform=mysql ### Count of DB: # db.num=1 ### Connect URL of DB: # db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;amp;connectTimeout=1000&amp;amp;socketTimeout=3000&amp;amp;autoReconnect=true&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC # db.user.0=nacos # db.password.0=nacos 二、问题 启动nacos持久化MySQL报错：
/usr/local/java/jdk-11.0.10/bin/java -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=true -Dnacos.member.list= -Xlog:gc*:file=/usr/local/nacos/logs/nacos_gc.log:time,tags:filecount=10,filesize=102400 -Dloader.path=/usr/local/nacos/plugins/health,/usr/local/nacos/plugins/cmdb -Dnacos.home=/usr/local/nacos -jar /usr/local/nacos/target/nacos-server.jar --spring.config.additional-location=file:/usr/local/nacos/conf/ --logging.config=/usr/local/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288 ,--. ,--.&amp;#39;| ,--,: : | Nacos 2.0.3 ,`--.&amp;#39;`| &amp;#39; : ,---. Running in stand alone mode, All function modules | : : | | &amp;#39; ,&amp;#39;\ .</description></item><item><title/><link>https://willxwu.github.io/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</guid><description>&lt;p>第一步骤：下载nexus私服软件nexus-2.12.0-01-bundle&lt;/p>
&lt;p>第二不：安装&lt;/p>
&lt;p>进入nexus解压目录进入到bin目录:&lt;/p>
&lt;p>1、安装:执行nexus.bat install&lt;/p>
&lt;p>2、启动:nexus.bat start&lt;/p>
&lt;p>第三步：查看访问路径&lt;/p>
&lt;p>进入config目录，打开nexus.properties即可看到端口号，项目命令nexus。&lt;/p>
&lt;p>第四步：浏览器打开http://127.0.0.1:8081/nexus/&lt;/p>
&lt;p>默认登录账号:admin/admin123&lt;/p></description></item><item><title/><link>https://willxwu.github.io/posts/nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>Nginx反向代理微服务配置 一、本地域名服务访问过程 二、正向代理和反向代理 三、Nginx+Windows搭建域名访问环境 1、修改C:\Windows\System32\drivers\etc下hosts文件，映射本地域名和192.168.56.10ip关系。 每次通过记事本修改很麻烦，可以通过SwitchHosts软件修改。
192.168.56.10 family.com 2、现在就可以通过family.com域名访问了。 想要访问部署在服务器上的其它端口应用也可以通过域名访问，比如：搭建的kibana是5601端口，通过域名http://family.com:5601/即可访问了(kibana时部署在56.10服务器上的)
四、nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39; &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39; &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } Nginx配置文件说明：
1、全局块:
配置影响nginx全局的指令。如：用户组、nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成wordker process数等。
2、events块：
配置影响nginx服务器或用户的网络链接。如：每个进程的最大连接数，选取那种事件驱动模型处理链接请求，是否允许同时接收多个网络链接，开启多个网络链接序列化等。
3、http块：
可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，是否使用sendfile传输文件，链接超时事件，单链接请求数等。
​ http块里面又包含：
​ **3.</description></item><item><title/><link>https://willxwu.github.io/posts/nginx%E9%85%8D%E7%BD%AEjenkins%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A443-ssl%E8%AE%BF%E9%97%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/nginx%E9%85%8D%E7%BD%AEjenkins%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A443-ssl%E8%AE%BF%E9%97%AE/</guid><description>nginx配置jenkins二级域名，以及443 SSL访问 新增配置文件
server { listen 443; #listen 80; server_name jenkins.yanxizhu.com; #error_page 404/404.html; ssl_certificate /etc/nginx/conf.d/jenkins.yanxizhu.com_bundle.crt; ssl_certificate_key /etc/nginx/conf.d/jenkins.yanxizhu.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; error_page 497 https://$host$request_uri; #Location配置 location / { proxy_set_header X-Rea $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://xx.xxx.xx.xx:10240; proxy_set_header X-Forwarded-Proto $scheme; } access_log /var/log/nginx/jenkins.yanxizhu.com.log; } server { listen 80; server_name jenkins.yanxizhu.com; rewrite ^(.*) https://jenkins.yanxizhu.com$1 permanent; } 注意：自己的端口以及ip地址和域名，以及域名解析配置、SSL证书名字根据自己的修改。</description></item><item><title/><link>https://willxwu.github.io/posts/nginx%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/nginx%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</guid><description>Nginx配置优化 1、隐藏nginx版本信息 #不显示nginx版本 server_tokens off 2、Buffers缓存 另一个很重要的参数为buffer，如果buffer太小，Nginx会不停的写一些临时文件，这样会导致磁盘不停的去读写。
client_body_buffer_size 10K; client_header_buffer_size 1k; client_max_body_size 8m; large_client_header_buffers 2 1k; client_body_buffer_size:允许客户端请求的最大单个文件字节数 client_header_buffer_size:用于设置客户端请求的Header头缓冲区大小，大部分情况1KB大小足够 client_max_body_size:设置客户端能够上传的文件大小，默认为1m large_client_header_buffers:该指令用于设置客户端请求的Header头缓冲区大小 3、开启Gzip压缩 #开启Gzip压缩 gzip on; #压缩等级 1-9 等级越高，压缩效果越好，节约宽带，但CPU消耗大 gzip_comp_level 2; #最小压缩文件大小 gzip_min_length 1000; #根据某些头部决定是否压缩， gzip_proxied expired no-cache no-store private auth; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_types text/plain application/x-javascript text/xml text/css application/xml; #是否传输gzip压缩标志 gzip_vary on; 4、开启高效传输模式 #开启高效传输模式。 sendfile on; #该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输&amp;#39;效率&amp;#39; tcp_nopush on; #该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的&amp;#39;实时性&amp;#39; tcp_nodelay on; 5、FastCGI配置 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。
#为FastCGI缓存指定一个文件路径、目录结构等级、关键字区域存储时间和非活动删除时间。 fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m; #指定连接到后端FastCGI的超时时间。 fastcgi_connect_timeout 300; #指定向FastCGI传送请求的超时时间，这个值是已经完成两次握手后向FastCGI传送请求的超时时间。 fastcgi_send_timeout 300; #指定接收FastCGI应答的超时时间，这个值是已经完成两次握手后接收FastCGI应答的超时时间。 fastcgi_read_timeout 300; #用于指定读取FastCGI应答第一部分需要用多大的缓冲区，这个值表示将使用1个64KB的缓冲区读取应答的第一部分（应答头），可以设置为fastcgi_buffers选项指定的缓冲区大小。 fastcgi_buffer_size 64k; #指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求。如果一个PHP脚本所产生的页面大小为256KB，那么会为其分配4个64KB的缓冲区来缓存；如果页面大小大于256KB，那么大于256KB的部分会缓存到fastcgi_temp指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于硬盘。一般这个值应该为站点中PHP脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为256KB，那么可以把这个值设置为“16 16k”、“4 64k”等。 fastcgi_buffers 4 64k; #默认值是fastcgi_buffers的两倍。 fastcgi_busy_buffers_size 128k; #表示在写入缓存文件时使用多大的数据块，默认值是fastcgi_buffers的两倍。 fastcgi_temp_file_write_size 128k; #表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502错误的发生，但是开启缓存也会引起很多问题，要视具体情况而定。 fastcgi_cache TEST; #用来指定应答代码的缓存时间，实例中的值表示将200和302应答缓存一个小时，将301应答缓存1天，其他应答均缓存1分 fastcgi_cache_valid 200 302 1h; fastcgi_cache_valid 301 1d; fastcgi_cache_valid any 1m; 6、超时配置 #客户端连接超时时间，单位是秒 keepalive_timeout 60; #客户端请求头读取超时时间 client_header_timeout 10; #设置客户端请求主体读取超时时间 client_body_timeout 10; #响应客户端超时时间 send_timeout 10; 7、expires缓存配置 #对于图片，通常过期时间可以设置为一个月 location ~ \.</description></item><item><title/><link>https://willxwu.github.io/posts/openfeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/openfeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>openFeign远程调用丢失请求头
feign在远程调用之前要构造请求，调用会经过很多拦截器。丢失请求头原因，是远程调用重新构建了request请求，新的request没有请求头headr。
解决方案：定义一个feign的拦截器
先来看一下feign远程调用类SynchronousMethodHandler
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package feign; import feign.InvocationHandlerFactory.MethodHandler; import feign.Logger.Level; import feign.Request.Options; import feign.codec.Decoder; import feign.codec.ErrorDecoder; import java.io.IOException; import java.util.Iterator; import java.util.List; import java.util.concurrent.CompletableFuture; import java.util.concurrent.CompletionException; import java.util.concurrent.TimeUnit; import java.util.stream.Stream; final class SynchronousMethodHandler implements MethodHandler { private static final long MAX_RESPONSE_BUFFER_SIZE = 8192L; private final MethodMetadata metadata; private final Target&amp;lt;?&amp;gt; target; private final Client client; private final Retryer retryer; private final List&amp;lt;RequestInterceptor&amp;gt; requestInterceptors; private final Logger logger; private final Level logLevel; private final feign.</description></item><item><title/><link>https://willxwu.github.io/posts/oracle-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/oracle-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</guid><description>Oracle 存储过程和函数 函数一般是工具性的东西。
存储过程一般是一些操作。
一、Oracle 自定义函数 语法：
Create function 函数名称 return 返回值类型 as Begin ... End 函数名称; 示例：统计t_book记录数
create or replace function getbookCount return number as begin declare bookNum number; begin select count(*) into bookNum from t_book; return bookNum; end; end getbookCount; 函数调用 set serveroutput on begin dbms_output.put_line(&amp;#39;t_book表有：&amp;#39; || getbookCount() || &amp;#39;条记录&amp;#39;); end; 输出结果：
带参数的函数 示例：
create or replace function getBookSum(table_name varchar2) return number as begin declare sumCount number; count_sql varchar2(200); begin count_sql:=&amp;#39;select count(*) from &amp;#39; || table_name; execute immediate count_sql into sumCount; return sumCount; end; end getBookSum; 带参函数调用 set serveroutput on begin dbms_output.</description></item><item><title/><link>https://willxwu.github.io/posts/oracle-%E6%B8%B8%E6%A0%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/oracle-%E6%B8%B8%E6%A0%87/</guid><description>一、游标 使用游标，我们可以对具体操作数据，比如查询的结果，对行，列数据进行更加细致的处理。以及对其他DML 操作进行判断等操作；类似一个数据集合。
1、语法 declare cursor 游标名称 is 查询的sql; 示例：
declare cursor cu_book is select bookname,price from t_book; 注意：游标默认是关闭的。
2、打开右边 open 游标名； 示例：
open cu_book; 3、关闭游标 close 游标名; 示例：
close cu_book; 4、游标循环 fetch 游标名 into 临时值1,临时值2...; 循环将游标中的字段保存到临时值中。
5、判断游标是否还有记录 游标名%found 二、示例 set serverout on; --定义游标哦 declare cursor cu_book is select bookname,price from t_book; b_name varchar(20); b_price number; begin open cu_book; --打开游标 fetch cu_book into b_name,b_price; --循环游标取值 while cu_book%found loop --如果游标里面还有值就循环处理其它逻辑 dbms_output.put_line(&amp;#39;书名：&amp;#39; || b_name || &amp;#39;价格&amp;#39; || b_price); fetch cu_book into b_name,b_price; end loop; close cu_book; end; 输出结果：</description></item><item><title/><link>https://willxwu.github.io/posts/oracle-%E8%A7%A6%E5%8F%91%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/oracle-%E8%A7%A6%E5%8F%91%E5%99%A8/</guid><description>Oracle 触发器 具备某些条件，由数据库自动执行的一些DML 操作行为。
一、语句触发器 语句触发器针对整个表，作用整个表操作。一般用于权限判断之类的。常用行触发器。
语法结构
Create trigger 触发器名称 Before/after 触发动作 On 作用对象 触发器谓词：INSERTING、UPDATING、DELETING
示例1： 向t_book插入数据之前判断，用户是否有权限执行查询操作。
创建语句触发器：
create trigger tr_book before insert on t_book begin if user!=&amp;#39;hello&amp;#39; then raise_application_error(-20001,&amp;#39;权限不足&amp;#39;); end if; end; 执行插入数据：
insert into t_book values(6,&amp;#39;ooo&amp;#39;,2,68,&amp;#39;男&amp;#39;); 提示结果：
修改触发器：
create or replace trigger tr_book before insert on t_book begin if user!=&amp;#39;SCOTT&amp;#39; then raise_application_error(-20001,&amp;#39;权限不足&amp;#39;); end if; end; 重新执行插入数据即可插入。
insert into t_book values(6,&amp;#39;ooo&amp;#39;,2,68,&amp;#39;男&amp;#39;); 查询结果：
注意：多个可以用or连接
示例：
create or replace trigger tr_book before insert or update or delete on t_book begin if user!</description></item><item><title/><link>https://willxwu.github.io/posts/oracle%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/oracle%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description>一、Oracle 表空间 一个数据库可以有多个表空间，一个表空间里可以有多个表。表空间就是存多个表的物理空间； 可以指定表空间的大小位置等。
创建表空间
create tablespace ts1 datafile &amp;#39;C:\tablespace\ts1.dbf&amp;#39; size 50M; 自动扩展大小
create tablespace ts2 datafile &amp;#39;C:\tablespace\ts2.dbf&amp;#39; size 50M autoextend on next 10M; 设置最大空间
create tablespace ts3 datafile &amp;#39;C:\tablespace\ts3.dbf&amp;#39; size 50M autoextend on next 10M maxsize 1024M; 更改用户默认表空间
alter database default tablespace ts1; 表空间改名
alter tablespace ts1 rename to tss1; 删除表空间
drop tablespace ts2 including contents and datafiles; 二：虚拟表dual 表 Dual 表是sys 用户下的一张虚表；提供一些运算和日期操作时候用到；
例如，查询系统日期时间
select sysdate from dual; 三、序列 序列作为数据库里的对象，主要作用是生成唯一的主键值；</description></item><item><title/><link>https://willxwu.github.io/posts/oracle%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/oracle%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid><description>一、Oracle控制语句 1、编写语句 --写了才会输出 set serverout on; --开始语句 begin --这里面开始写语句块 dbms_output.put_line(&amp;#39;Hello&amp;#39;); --注意&amp;#34; ; &amp;#34;不要完了 --控制语句结束 end; --在对话框执行时，需要输入/ 2、执行语句 3、定义变量 -只定义变量 declare 变量名 数据类型; --定义变量并赋值 declare 变量名 数据类型:赋值; 示例：
--写了才会输出 set serverout on; --定义变量price并赋值，注意不是在语句块里面定义 declare price number:=100; --开始语句 begin --这里面开始写语句块 dbms_output.put_line(&amp;#39;Hello&amp;#39;||price); --注意&amp;#34; ; &amp;#34;不要完了 --控制语句结束 end; --在对话框执行时，需要输入/ 注意：可以一次定义多个变量，不用每次都写declare。
示例：
set serverout on; --定义多个变量 declare price number:=100; productName varchar(20):=&amp;#39;notebook&amp;#39;; begin -- 凭借符号|| dbms_output.put_line(price || productName); end; 4、赋值 定义变量并赋值
--定义变量price并赋值100，注意不是在语句块里面定义 declare price number:=100; 5、查询结果赋值 into：将查询结果赋值给定义的变量</description></item><item><title/><link>https://willxwu.github.io/posts/pstree%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/pstree%E5%AE%89%E8%A3%85/</guid><description>pstree安装 1、在 Mac OS上
brew install pstree 2、在 Fedora/Red Hat/CentOS
yum -y install psmisc 3、在 Ubuntu/Debian
apt-get install psmisc ps显示各进程关系，列入：查看nginx进程关系。
ps aux | grep nginx 像一棵树一样展示。</description></item><item><title/><link>https://willxwu.github.io/posts/rabbitmqy%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/rabbitmqy%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid><description>RabbitMQ运行机制 AMQP 中的消息路由
AMQP 中消息的路由过程和 Java 开 发者熟悉的 JMS 存在一些差别， AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布 到 Exchange 上，消息最终到达队列 并被消费者接收，而 Binding 决定交 换器的消息应该发送到那个队列
Exchange 类型 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、 fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接 看另外三种类型：
Direct Exchange
消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器 就将消息发到对应的队列中。路由键与队 列名完全匹配，如果一个队列绑定到交换 机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发 “dog.puppy”，也不会转发“dog.guard” 等等。它是完全匹配、单播的模式
Fanout Exchange
每个发到 fanout 类型交换器的消息都 会分到所有绑定的队列上去。fanout 交 换器不处理路由键，只是简单的将队列 绑定到交换器上，每个发送到交换器的 消息都会被转发到与该交换器绑定的所 有队列上。很像子网广播，每台子网内 的主机都获得了一份复制的消息。 fanout 类型转发消息是最快的</description></item><item><title/><link>https://willxwu.github.io/posts/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>RabbitMQ延时队列（实现定时任务） 场景： 比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 常用解决方案： spring的 schedule 定时任务轮询数据库 缺点： 消耗系统内存、增加了数据库的压力、存在较大的时间误差 解决：rabbitmq的消息TTL和死信Exchange结合
消息的TTL（Time To Live)
• 消息的TTL就是消息的存活时间。 • RabbitMQ可以对队列和消息分别设置TTL。 • 对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的 设置。超过了这个时间，我们认为这个消息就死了，称之为死信。 • 如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队 列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的 TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者x- message-ttl属性来设置时间，两者是一样的效果。
Dead Letter Exchanges（DLX）
• 一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信） • 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不 会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false • 上面的消息的TTL到了，消息过期了。 • 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上 • Dead Letter Exchange其实就是一种普通的exchange，和创建其他 exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。 • 我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列
• 手动ack&amp;amp;异常消息统一放在一个队列处理建议的两种方式 • catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费 • 给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败
延时队列实现
SpringBoot中使用延时队列 • 1、Queue、Exchange、Binding可以@Bean进去 • 2、监听消息的方法可以有三种参数（不分数量，顺序） • Object content, Message message, Channel channel • 3、channel可以用来拒绝消息，否则自动ack；</description></item><item><title/><link>https://willxwu.github.io/posts/reentrantlock%E4%B8%8E%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/reentrantlock%E4%B8%8E%E9%94%81/</guid><description>锁分为Synchronized和锁Lock。
ReentrantLock与锁 ReentrantLock(可重入锁)与Synchronized(同步锁)的区别：
可重入性：区别不大，都是通过计数器，当计数器下降为0时，锁释放。
锁的实现：Synchronized依赖JVM，ReentrantLock基于JDK实现。(类似Synchronized是操作系统实现，ReentrantLock是敲代码实现),ReentrantLock可通过看源码明白实现，Synchronized依赖JVM就看不到实现原理。
性能的区别：优化之前Synchronized比ReentrantLock性能差很多，优化后Synchronized引入偏向锁、轻量级锁也就是自旋锁后，2者性能差不多了。差不多时，官方推荐Synchronized。
功能的区别：Synchronized的使用方便简洁，隐式获取锁释放锁，ReentrantLock需要手动获取锁，释放锁，如果忘记容易出现死锁，所以最好再finally中释放锁。锁的颗粒度和灵活度很明显ReentrantLock优于Synchronized。
ReentrantLock独有的功能：
ReentrantLock可指定公平锁、非公平锁，而Synchronized只能时非公平锁。公平锁：先等待的先获取锁，反之亦然。 提供了一个Condition类，可以分组唤醒需要唤醒的线程，Synchronized要么随机唤醒，要么全部唤醒。 提供能够中断等待锁的线程的机制，lock.lockInterruptibly()，lockInterruptibly是一种自旋锁，通过循环来调用CAS来加锁，性能比较好，就是因为不会进入内核阻塞状态。 使用场景：必须实现上面3个功能时，就必须用了。
代码示例一 ReentrantLock实现累加，注意与synchronized的不用用法
package com.yanxizhu.demo.concurrency.lock; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: ReentrantLock锁实现计数，注意使用synchroized怎么实现的 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/25 23:09 * @version: 1.0 */ @Slf4j public class ReentrantLockDemo { //定义锁 private static Lock lock = new ReentrantLock(); //定义锁用户数 private static final int totalThread = 5000; //定义并发线程数 private static final int concurrentThread = 200; //定义总和 private static int count = 0; public static void main(String[] args) throws Exception{ //定义线程池 ExecutorService executorService = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: ReentrantLock * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 12:37 * @version: 1.0 */ public class LockDemo { public static void main(String[] args) { titck titck = new titck(); new Thread(titck,&amp;#34;线程1&amp;#34;).start(); new Thread(titck,&amp;#34;线程2&amp;#34;).start(); new Thread(titck,&amp;#34;线程3&amp;#34;).start(); } public static class titck implements Runnable{ Lock lock = new ReentrantLock(); private int titck = 100; @Override public void run() { while(true){ lock.lock(); try{ if(titck&amp;gt;0){ try { Thread.</description></item><item><title/><link>https://willxwu.github.io/posts/resttemplate%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/resttemplate%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate使用 一、依赖注入 @Bean // 开启负载均衡 @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } 二、调用服务 String url =&amp;#34;http://provider/getHi&amp;#34;; String respStr = restTemplate.getForObject(url, String.class); 三、get 请求 1、getForEntity getForEntity方法的返回值是一个ResponseEntity，ResponseEntity是Spring对HTTP请求响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、响应消息体等。
&amp;lt;200,Hi,[Content-Type:&amp;#34;text/plain;charset=UTF-8&amp;#34;, Content-Length:&amp;#34;8&amp;#34;, Date:&amp;#34;Fri, 10 Apr 2020 09:58:44 GMT&amp;#34;, Keep-Alive:&amp;#34;timeout=60&amp;#34;, Connection:&amp;#34;keep-alive&amp;#34;]&amp;gt; 2、返回Map 调用方
String url =&amp;#34;http://provider/getMap&amp;#34;; ResponseEntity&amp;lt;Map&amp;gt; entity = restTemplate.getForEntity(url, Map.class); System.out.println(&amp;#34;respStr: &amp;#34; + entity.getBody() ); 生产方
@GetMapping(&amp;#34;/getMap&amp;#34;) public Map&amp;lt;String, String&amp;gt; getMap() { HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(&amp;#34;name&amp;#34;, &amp;#34;500&amp;#34;); return map; } 3、返回对象(getForEntity) 调用方</description></item><item><title/><link>https://willxwu.github.io/posts/scannerrandom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/scannerrandom/</guid><description>Java的两个引用输入类型Scanner、Random类，Scanner用于接收键盘输入，Random用户产生随机数。引用类型也就是Sun公司为我们写好的类，我们直接使用就可以了。
1、引用数据类型的使用 导入包：知道用的这个类，在jdk的那个目录那个文件下。 创建对象：格式， 类 对象 = new 类型(); 如何使用: 对象.类的方法() 引用数据类型的使用与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式，如下：
数据类型 变量名 = new 数据类型(); 每种引用数据类型都有其方法，我们可以调用该类型实例的方法。
变量名.方法名(); 2、Scanner类 Scanner类是引用数据类型的一种，我们可以使用该类来完成用户键盘录入，获取到录入的数据。
导包
import java.util.Scanner; 创建对象实例
Scanner sc = new Scanner(System.in); 调用方法
//用来接收控制台录入的数字 int i = sc.nextInt(); //用来接收控制台录入的字符串 String s = sc.next(); Scanner使用Demo：
package java_learn_code; //导入包，指明类所在的的文件见，关键字import import java.util.Scanner; /** * 引用数据类型,使用步骤：1、导入包 。2、创建对象 3、通过对象调用方法 * @author Jole * Scanner的使用，所在目录java文件见-util文件夹 */ public class ScannerDemo { public static void main(String[] args) { System.out.print(&amp;#34;请输入整数内容：&amp;#34;); //类型 变量名 = new 类型(); //创建出scanner,类变量 Scanner scan = new Scanner(System.</description></item><item><title/><link>https://willxwu.github.io/posts/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>ScheduledThreadPool线程调度 package com.yanxizhu; import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</guid><description>首先知道Shiro架构有3个主要概念：Subject、SecurityManager和Realms。
Shiro基础架构图 ：
基础架构说明： Subject: As we’ve mentioned in our Tutorial, the Subject is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a Subject can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software. Subject instances are all bound to (and require) a SecurityManager.</description></item><item><title/><link>https://willxwu.github.io/posts/showdoc-ssl-https-nginx%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/showdoc-ssl-https-nginx%E9%85%8D%E7%BD%AE/</guid><description>Docker安装ShowDoc ssl https nginx配置 一、docker安装showdoc 1、拉取镜像 # 中国大陆镜像安装命令（安装后记得执行docker tag命令以进行重命名）
docker pull registry.cn-shenzhen.aliyuncs.com/star7th/showdoc docker tag registry.cn-shenzhen.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest 2、创建showdoc数据目录 mkdir -p /mydata/showdoc/showdoc_data/html chmod -R 777 /mydata/showdoc/showdoc_data 3、启动容器 docker run -d --name showdoc --user=root --privileged=true -p 4999:80 \ -v /mydata/showdoc/html:/var/www/html/ star7th/showdoc 4、设置随容器启动 docker update --restart=always showdoc 此时旧可以通过IP+port访问了，注意，端口放行，云服务器白名单开启。
二、showdoc配置https、ssl、nginx配置 nginx https、ssl配置如下：
server { listen 443 ssl; server_name doc.yanxizhu.com; client_max_body_size 1000m; ssl on; ssl_certificate /etc/nginx/conf.d/key/doc.yanxizhu.com_bundle.crt; ssl_certificate_key /etc/nginx/conf.d/key/doc.yanxizhu.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.</description></item><item><title/><link>https://willxwu.github.io/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/socket%E7%BC%96%E7%A8%8Btcp%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description>通过Java Socket编程，实现多线程文件上传。主要涉及ServerScoket服务端、Socket客户端、IO流操作、多线线程。
客户端：
package learn.javase.Update; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; /** * 利用TCP的Socket\ServerSocket客户端向服务器上传文件 * 客户端 * @author Jole * */ public class UpClent { public static void main(String[] args) throws IOException{ Socket socket = new Socket(&amp;#34;127.0.0.1&amp;#34;,8888); OutputStream out = socket.getOutputStream(); //读取本地文件，并通过out输出流，发送给服务端 File file = new File(&amp;#34;J:&amp;#34;+File.separator+&amp;#34;wxhandbook-master.zip&amp;#34;); FileInputStream in = new FileInputStream(file); byte[] data = new byte[1024]; int len =0; while((len=in.read(data))!=-1) { out.write(data, 0, len); } socket.</description></item><item><title/><link>https://willxwu.github.io/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/socket%E7%BC%96%E7%A8%8Budp%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9/</guid><description>通过Socket网络编程，UDP实现简单聊天。主要涉及DatagramSocket进行数据传输、DatagramPacket进行数据包封装，2个类。
发送端:
package learn.javase.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.util.Scanner; /** * 控制台输入；实现聊天。 * 发送方 * @author Jole * */ public class UdpSend { public static void main(String[] args) throws Exception{ Scanner scan = new Scanner(System.in); InetAddress ia = InetAddress.getByName(&amp;#34;192.168.1.4&amp;#34;); DatagramSocket socket = new DatagramSocket(); while(true) { String chatInfo = scan.nextLine(); byte[] info = chatInfo.getBytes(); DatagramPacket pack = new DatagramPacket(info, info.length, ia, 6000); socket.send(pack); } } } 接收端：</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88mq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88mq/</guid><description>SpringBoot整合RabbitMQ 1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2、配置rabbitmq 通过RabbitProperties.properties配置文件配置链接
rabbitmq: host: 192.168.56.10 virtual-host: / port: 5672 publisher-confirm-type: correlated publisher-returns: true template: mandatory: true 重点： #开启发送端确认机制，发送到Broke的确认 publisher-confirm-type: correlated #开启时消息发送到队列的消息确认机制 publisher-returns: true #只要抵达队列，以异步发送优先回调我们这个Returnconfirm template: mandatory: true 3、开启Rabbit 启动类添加@EnableRabbit注解
@EnableRabbit @SpringBootApplication public class FamilyBookingApplication { public static void main(String[] args) { SpringApplication.run(FamilyBookingApplication.class, args); } } 4、Rabbit使用 现在RabbitAutoConfiguration就生效了，就有了组件RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate
5、使用测试 1、创建Exchange、Queue、Binding 使用AmqpAdmin创建。
通过创建各交换机构造方法，找到对应接口的实现，传入参数即可创建Exchange。
public DirectExchange(String name, boolean durable, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments) @Autowired AmqpAdmin amqpAdmin; /** * 创建Exchange交换机 */ @Test public void craeteChage() { /** * public DirectExchange(String name, boolean durable, boolean autoDelete, Map&amp;lt;String, Object&amp;gt; arguments) */ DirectExchange directExchange = new DirectExchange(&amp;#34;Family-Hello-Exchange&amp;#34;,true,false); amqpAdmin.</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88quartz-scheduler%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88quartz-scheduler%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>SpringBoot整合定时任务和异步任务 一、定时任务 SpringBoot整合quartz-scheduler，执行定时任务。
1、开启定时任务 @EnableScheduling 2、开启一个定时任务 @Scheduled 3、编写cron表达式 cron表达式格式请参考官方文档
4、实例 package com.yanxizhu.ifamily.booking.controller.scheduler; import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * SpringBoot整合Scheduling定时任务 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/15 20:26 * @version: 1.0 */ @Slf4j @Component @EnableScheduling public class MyScheduler { /** * cron表达式 */ @Scheduled(cron = &amp;#34;1/3 1/1 * * * ? &amp;#34;) public void sayHell(){ log.info(&amp;#34;Hello&amp;#34;); } } 5、定时任务总结 1、@EnableScheduling 开启一个定时任务
2、@Scheduled 开启一个定时任务
3、编写定时规则，也就是cron表达式。
6、注意事项 spring中6位组成，不允许第7位的年。 在周几的位置，1-7代表周一到周日，MON-SUN 定时任务不应该阻塞，默认时阻塞的，应该以异步任务执行。 7、解决方案 解决定时任务阻塞问题：使用异步+定时任务</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88redis/</guid><description>适合当如缓存场景： 即时性、数据一致性要求不高的。 访问量大且更新频率不高的数据(读多，写少) 承担持久化工作。
读模式缓存使用流程: 凡是放入缓存中的数据，我们应该指定过期时间，使其可以再系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。
解决分布式缓存中本地缓存导致数据不一致问题，可以使用redis中间件解决。
springboot整合redis 1、引入springboot整合的start：pom文件引入依赖
&amp;lt;!--redis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 引入依赖之后就会有RedisAutoConfiguration，里面可以看的到redis的配置文件Redis.Properties.
@Configuration( proxyBeanMethods = false ) @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&amp;#34;redisTemplate&amp;#34;} ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { return new StringRedisTemplate(redisConnectionFactory); } } Redis.Properties文件里面包含了redis的配置信息：
@ConfigurationProperties( prefix = &amp;#34;spring.</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid><description>Springboot整合seata分布式事务 一、创建seata日志表 -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 二、安装事务协调器（seata-server） 1、下载地址
2、导入依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-seata&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 3、启动seata服务器
4、seata文件说明
registry.conf：注册中心配置。
这里执行注册中西为nacos。type = &amp;ldquo;nacos&amp;rdquo;，</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88sentinel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88sentinel/</guid><description>SpringBoot整合Sentinel 1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2、下载安装Sentinel可视化控制台 下载自己引入sentinel对应的核心包版本，下载地址：https://github.com/alibaba/Sentinel/releases
运行Sentinel可视化控制台
java -jar sentinel-dashboard-1.8.1.jar 注意自己的版本。
打开http://127.0.0.1:8080/，默认账号密码sentinel
3、微服务配置sentinel application.yml
spring: cloud: sentinel: transport: port: 8719 dashboard: localhost:8080 port: 8719端口随意，只要不被占用，用于各微服务与控制台通讯。
4、查看监控信息 启动微服务，随意访问一个接口，Sentinel控制台即可看到实施监控信息。
5、启用相关功能 可在Sentinel控制台调整相应功能。默认所有流控设置都是保存在内存中，重启服务就没有了。
6、添加监控图标 引入审计start，sentinel会自动根据spring-boot-starter-actuator监控。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 开启监控图标
management.endpoints.web.exposure.include=* 7、自定义流控返回提示信息 import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.alibaba.fastjson.JSON; import com.yanxizhu.common.utils.R; import org.springframework.context.annotation.Configuration; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @description: Sentinel流控信息提示自定i * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/13 20:14 * @version: 1.0 */ @Configuration public class MySentinelConfig implements BlockExceptionHandler { @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception { R r = R.</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88sleuth+zipkin-%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88sleuth+zipkin-%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</guid><description>SpringBoot整合Sleuth+Zipkin 服务链路追踪 一、整合 Sleu 1、服务提供者与消费者导入依赖 &amp;lt;!--整合 Sleut:服务提供者与消费者导入依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2、打开 debug 日志 logging: level: org.springframework.cloud.openfeign: debug org.springframework.cloud.sleuth: debug 3、发起一次远程调用，观察控制台 DEBUG [user-service,541450f08573fff5,541450f08573fff5,false] user-service：服务名
541450f08573fff5：是 TranceId，一条链路中，只有一个 TranceId
541450f08573fff5：是 spanId，链路中的基本工作单元 id
false：表示是否将数据输出到其他服务，true 则会把信息输出到其他可视化的服务上观察
二、整合 zipkin 可视化观察 1、docker 安装 zipkin 服务器 docker run -d -p 9411:9411 openzipkin/zipkin 设置随docker启动
docker update --restart=always 容器名称 2、导入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.8.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 因为spring-cloud-starter-zipkin中引入了spring-cloud-starter-sleuth，因此上面的spring-cloud-starter-sleuth可以不用引入。
3、添加 zipkin 相关配置 spring: application: name: ifamily-booking zipkin: base-url: http://127.0.0.1:9411/ # zipkin 服务器的地址 # 关闭服务发现，否则 Spring Cloud 会把 zipkin 的 url 当做服务名称 discoveryClientEnabled: false sender: type: web # 设置使用 http 的方式传输数据 sleuth: sampler: probability: 1 # 设置抽样采集率为 100%，默认为 0.</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88springcache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88springcache/</guid><description>SpringBoot整合SpringCache 1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2、引入redis依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 配置redis地址密码等等，可参考springboo整合redis
3、默认配置 自动配置
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.springframework.boot.autoconfigure.cache; import java.util.List; import java.util.stream.Collectors; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.ObjectProvider; import org.springframework.boot.autoconfigure.AutoConfigureAfter; import org.springframework.boot.autoconfigure.condition.ConditionalOnBean; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration; import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration; import org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration; import org.springframework.boot.autoconfigure.orm.jpa.EntityManagerFactoryDependsOnPostProcessor; import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.cache.CacheManager; import org.springframework.cache.interceptor.CacheAspectSupport; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.</description></item><item><title/><link>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88springsession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot/springboot%E6%95%B4%E5%90%88springsession/</guid><description>springboot整合SpringSession
1、引入依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2、springboot配置 application.properties配置：保存类型
spring.session.store-type=redis # Session store type. session过期时间：
server.servlet.session.timeout= # Session timeout. If a duration suffix is not specified, seconds is used. 其它配置信息可参考官网：
spring.session.redis.flush-mode=on_save # Sessions flush mode. spring.session.redis.namespace=spring:session # Namespace for keys used to store sessions. 连接信息配置：
spring.redis.host=localhost # Redis server host. spring.redis.password= # Login password of the redis server. spring.redis.port=6379 # Redis server port. 3、开启springSession 主类加上注解@EnableRedisHttpSession
@EnableRedisHttpSession 4、使用 注意：
1、需要保存到redis中的数据必须序列化。</description></item><item><title/><link>https://willxwu.github.io/posts/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>Springboot同一Server类方法调用事务解决方案 1、引入springboot-aop start &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 主要是使用里面的动态代理
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.7&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 2、开启动态代理 @EnableAspectJAutoProxy(exposeProxy = true) @EnableDiscoveryClient @SpringBootApplication public class FamilyBookingApplication { public static void main(String[] args) { SpringApplication.run(FamilyBookingApplication.class, args); } } @EnableAspectJAutoProxy(exposeProxy = true)：
开启aspectj动态代理功能。以后所有的动态代理都是aspectj对象暴露代理对象。
3、本类互调用代理对象调用 @Service(&amp;#34;userService&amp;#34;) public class UserServiceImpl implements userService { @Transactional public void a(){ UserService userService = (UserService)AopContext.currentProxy(); userService.b(); userService.c(); } @Transactional public void b(){ } @Transactional public void c(){ } }</description></item><item><title/><link>https://willxwu.github.io/posts/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/</guid><description>Springboot拦截器配置
1、拦截器配置，主要实现HandlerInterceptor接口 import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @description: 拦截器，配合FamilyWebConfig 配置使用 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/10 22:36 * @version: 1.0 */ @Component public class LoginUserInterceptor implements HandlerInterceptor { public static ThreadLocal&amp;lt;Object&amp;gt; objUser = new ThreadLocal&amp;lt;&amp;gt;(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object loginusr = request.getSession().getAttribute(&amp;#34;LOGIN_USR&amp;#34;); if(loginusr != null){ objUser.set(loginusr); //登录了才能访问 return true; }else{ //没登录，跳转去登录 return false; } } } 由于拦截器需要配合web配置使用，因此创建web配置。</description></item><item><title/><link>https://willxwu.github.io/posts/springboot%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/springboot%E6%B3%A8%E8%A7%A3/</guid><description>SpringBoot注解 某个对象创建完成后，执行这个方法
@PostConstruct</description></item><item><title/><link>https://willxwu.github.io/posts/ssh%E5%88%9B%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/ssh%E5%88%9B%E5%BB%BA/</guid><description>1. 设置Git用user name和email git config --global user.name &amp;#34;XXX&amp;#34; git config --global user.email &amp;#34;XXX@gmail.com&amp;#34; 2. 生成密钥 ssh-keygen -t rsa -C &amp;#34;XXX@gmail.com&amp;#34; 中间连续3次Enter键.
3. 测试SSH key是否设置成功 ssh -T git@github.com 出现下面提示直接输入yes.
The authenticity of host &amp;#39;github.com (192.30.253.113)&amp;#39; can&amp;#39;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes 输出如下，则表示通过.
Hi xxxx! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access. 使用时，会根据本地git密钥信息与git或者coding仓库密钥信息比对，本地上传时会提示登录。</description></item><item><title/><link>https://willxwu.github.io/posts/synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/synchronized/</guid><description>Atomic原子性提供了互斥访问。同一时刻只能由一个线程来操作。除了Atomic原子性，还有锁。
jdk提供的锁主要分2类 1、Synchronized：一种依赖JVM去实现锁的关键字，Synchronized，在这个对象作用的范围内，都是同一时刻，只能有一个线程去操作。注意是，作用对象的作用范围内。
2、另一种jdk代码层面的锁，jdk里面提供了一个Lock的接口，主要是依赖特殊的CPU指令，实现类中比较有代表性的是ReentrantLock。
Synchronized 一种同步锁，修改的对象主要有4种：
修饰代码块：大括号括起来的代码，也就是同步语句块，它的作用范围是大括号括起来的代码，作用对象是调用代码块的对象。 修饰方法：被称为同步方法，作用范围为整个方法，作用对象是也是调用该方法的对象。 修饰静态方法：作用范围整个静态方法，作用对象是这个类的所有对象。 修饰类：修饰内容是后面Synchronized括号括起来的部分，作用对象也是这个类的所有对象。 代码说明: 一、启用不同进程，同一对象调用，调用同一方法。 package com.yanxizhu.demo.concurrency.sync; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @description: Synchronized修饰代码块、修改方法，作用对象为调用对象 * 这里测试，同一对象，启动不同进程，调同一方法 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/20 22:44 * @version: 1.0 */ @Slf4j public class DemoSynchronizedOne { /** * 修饰代码块，大括号被称为 同步代码块， * 作用范围：代码块内 * 作用对象：调用代码块的对象 */ public void test1() { synchronized (this) { for (int i = 0; i &amp;lt; 10 ;i ++){ log.info(&amp;#34;test1 .</description></item><item><title/><link>https://willxwu.github.io/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/typora%E6%9C%80%E5%90%8E%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Typora最后免费版本下载
Typora收费后，开始保留最后一个免费版本Version0.11.18(beta)，欢迎食用。
阿里网盘：
「typora-update-x64-1117.exe」https://www.aliyundrive.com/s/Xez1W6kvWZv 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。
百度网盘：
链接：https://pan.baidu.com/s/1zaaqxIv99xX98Qemw9tLrw 提取码：utq4
天翼网盘:
https://cloud.189.cn/t/3yEJbavmieye (访问码:1oov)</description></item><item><title/><link>https://willxwu.github.io/posts/virtualbox%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/virtualbox%E4%BD%BF%E7%94%A8/</guid><description>一、virtualbox安装 1、下载 https://www.virtualbox.org/
2、在主板开启CPU虚拟化，自行百度
3、安装，直接下一步，选择安装路径。
二、安装虚拟机 1、下载虚拟系统CentOS7
https://app.vagrantup.com/boxes/search Vagrant官方镜像仓库
https://www.vagrantup.com/ Vagrant下载
2、初始化虚拟系统
打开安装好的virtualbox软件，打开window cmd窗口，运行下面命令，即可初始化一个CentOS7系统。初始化之后window用户文件夹夹会多出一个Vagrantfile文件。此时virtualbox界面就会多出一个CentOS系统了。
vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box 或 Vagrant init centos/7 3、启动虚拟机，初始root用户密码vagrant，此时看到virtualbox中的CentOS正在启动。
vagrant up 4、vagrant其他命令
使用vagrant用户链接至CentOS虚拟机，初始root用户密码vagrant。
vagrant ssh 上传文件
vagrant upload source [destination][name][id] 更多命令可以访问官网文档
5、设置固定ip，默认虚拟机ip是随机的，方式1-修改Vagrantfile，方式2-进入linx系统修改网卡配置信息,下面为修改Vagrantfile改ip：
config.vm.network &amp;#34;private_network&amp;#34;,ip:&amp;#34;192.168.10.1&amp;#34; 6、重启虚拟机
vagrant reload 7、启动，除了上面的3启动虚拟机，也可以在virtualbox界面选择虚拟机右键开启。
8、virtualbox界面还可以设置虚拟机内存大小等信息，更多设置可以查看官网。
9、开启ssh登录linux虚拟机。
10、进入虚拟机目录
cd /etc/sysconfig/network-scripts/ 配置网卡信息vi ifcfg-eth1修改网卡网关和dns：
# The contents below are automatically generated by Vagrant. Do not modify. NM_CONTROLLED=yes BOOTPROTO=none ONBOOT=yes IPADDR=192.168.56.10 NETMASK=255.255.255.0 GATEWAY=192.168.56.1 DNS1=114.114.114.114 DNS2=8.</description></item><item><title/><link>https://willxwu.github.io/posts/virtualbox%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/virtualbox%E5%AE%89%E8%A3%85/</guid><description>一、virtualbox安装 1、下载 https://www.virtualbox.org/
2、在主板开启CPU虚拟化，自行百度
3、安装，直接下一步，选择安装路径。
二、安装虚拟机 1、下载虚拟系统CentOS7
https://app.vagrantup.com/boxes/search Vagrant官方镜像仓库
https://www.vagrantup.com/ Vagrant下载
2、初始化虚拟系统
打开安装好的virtualbox软件，打开window cmd窗口，运行下面命令，即可初始化一个CentOS7系统。初始化之后window用户文件夹夹会多出一个Vagrantfile文件。此时virtualbox界面就会多出一个CentOS系统了。
Vagrant init centos/7 3、启动虚拟机，初始root用户密码vagrant，此时看到virtualbox中的CentOS正在启动。
vagrant up 4、vagrant其他命令
使用vagrant用户链接至CentOS虚拟机，初始root用户密码vagrant。
vagrant ssh 上传文件
vagrant upload source [destination][name][id] 更多命令可以访问官网文档
5、设置固定ip，默认虚拟机ip是随机的，方式1-修改Vagrantfile，方式2-进入linx系统修改网卡配置信息
config.vm.network &amp;#34;private_network&amp;#34;,ip:&amp;#34;192.168.10.1&amp;#34; 6、重启虚拟机
vagrant reload 7、启动，除了上面的3启动虚拟机，也可以在virtualbox界面选择虚拟机右键开启。
8、virtualbox界面还可以设置虚拟机内存大小等信息，更多设置可以查看官网。</description></item><item><title/><link>https://willxwu.github.io/posts/vue%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/vue%E5%AD%A6%E4%B9%A0/</guid><description>一、vue的基本使用 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;vue的基本使用&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!-- 模板语法--插值{{}} --&amp;gt; &amp;lt;!-- 优先加载template里面的内容，如果为空也加载#app，在加载#app --&amp;gt; &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;./node_modules/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { msg: &amp;#39;黄瓜&amp;#39; }, template: &amp;#39;&amp;lt;div&amp;gt;&amp;lt;h5&amp;gt;{{msg}}&amp;lt;/h5&amp;gt;&amp;lt;/div&amp;gt;&amp;#39; }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 二、vue指令 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;vue指令&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .box{ width: 300px; height: 300px; background-color: red; } .active{ background-color: green; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{msg}}&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;./node_modules/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var vm = new Vue({ el: &amp;#34;#app&amp;#34;, data:function(){ return{ msg: &amp;#39;vue指令&amp;#39;, msg2: &amp;#39;vue的3种{{}}插值，1、{{}} 2、v-text=&amp;#34;&amp;#34; 3\v-html=&amp;#34;&amp;#34;&amp;#39;, isShow: true, isActive: true, frut: [ {id:1,name:&amp;#34;苹果&amp;#34;,price:20}, {id:2,name:&amp;#34;火龙果&amp;#34;,price:40}, {id:3,name:&amp;#34;西瓜&amp;#34;,price:30}, {id:4,name:&amp;#34;荔枝&amp;#34;,price:60} ], person:{ name:&amp;#34;zhangsan&amp;#34;, age:30, sex:&amp;#34;boy&amp;#34; } } }, template: &amp;#39;&amp;lt;div&amp;gt;{{msg}} &amp;lt;p v-text=&amp;#34;msg&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p v-html=&amp;#34;msg2&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;div v-if=&amp;#34;isShow&amp;#34;&amp;gt;v-if的使用&amp;lt;/div&amp;gt; &amp;lt;div v-if=&amp;#34;Math.</description></item><item><title/><link>https://willxwu.github.io/posts/widnows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/widnows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Widnows常用命令 查看所有端口号情况
netstat -ano 搜索查看指定端口
netstat -ano|findstr 端口号 查看所有程序占用端口信息
tasklist 搜索指定端口被那个程序占用
tasklist|findstr 端口号</description></item><item><title/><link>https://willxwu.github.io/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/xshell-7xftp-7%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/</guid><description>Xshell 7、Xftp 7免费版本下载，官网每次下载懒得找，懒得注册，这里提供官网原版下载，官网下载地址
https://www.xshell.com/zh/free-for-home-school/
阿里网盘：
https://www.aliyundrive.com/s/ZV2jMWP4Fsr
百度网盘：
链接：https://pan.baidu.com/s/13Hx_HYbZFC4BGW56IlOdqA 提取码：xb2e
天翼网盘：
https://cloud.189.cn/t/ueABVvANryMn (访问码:w2se)
https://cloud.189.cn/t/Yjymuu3EF3Az (访问码:7it5)</description></item><item><title/><link>https://willxwu.github.io/posts/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</guid><description>线程安全策略
不可变对象 不可变对象需要满足的条件： 对象创建以后其状态就不能修改 对象所有域都是final类型 对象是正确创建的（在对象创建期间，this引用没有逸出）
一、final关键字 final关键字：可修饰类、方法、变量。
修饰类：不能被继承
修饰方法：
锁定方法不被继承类修改； 效率 修饰变量：基本数据类型变量、引用类型变量
代码示例
package com.yanxizhu.demo.concurrency.finals; import com.google.common.collect.Maps; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.Map; /** * @description: 不可变对象 final修饰 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/22 20:35 * @version: 1.0 */ @Slf4j @UnThreadSafety public class DemoFinal { //普通类型，final修饰后，修改直接提示错误 private final static Integer a =1; //普通类型，final修饰后，修改直接提示错误 private final static String b = &amp;#34;hello&amp;#34;; //final修饰后不能在执行新的对象 private final static Map&amp;lt;Integer, Integer&amp;gt; map = Maps.</description></item><item><title/><link>https://willxwu.github.io/posts/%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98%E5%BA%94%E8%AF%A5%E6%80%BB%E6%98%AF%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98%E5%BA%94%E8%AF%A5%E6%80%BB%E6%98%AF%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD/</guid><description>wait、notifyAll()、await()、signalAll() 为了避免虚假唤醒问题，应该总是使用在循环中 wait、notifyAll():
package com.yanxizhu; import java.util.function.Consumer; /* * 生产者和消费者案例 */ public class TestProductorAndConsumer { public static void main(String[] args) { Clerk clerk = new Clerk(); Productor pro = new Productor(clerk); Consumers cus = new Consumers(clerk); new Thread(pro, &amp;#34;生产者 A&amp;#34;).start(); new Thread(cus, &amp;#34;消费者 B&amp;#34;).start(); new Thread(pro, &amp;#34;生产者 C&amp;#34;).start(); new Thread(cus, &amp;#34;消费者 D&amp;#34;).start(); } } //店员 class Clerk{ private int product = 0; //进货 public synchronized void get(){//循环次数：0 while(product &amp;gt;= 1){//为了避免虚假唤醒问题，应该总是使用在循环中 System.</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%88%9D%E8%AF%86rabbitmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%88%9D%E8%AF%86rabbitmq/</guid><description>RabbitMQ作用 异步处理、应用解耦、流量控制
概述 1、大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力
2、消息服务中两个重要概念：
消息代理（message broker）和目的地（destination） 当消息发送者发送 消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。
3、消息队列主要有两种形式的目的地
​ 3.1、队列（queue）：点对点消息通信（point-to-point）
​ 3.2、主题（topic）：发布（publish）/订阅（subscribe）消息通信
4、点对点式：
​ 4.1、消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获 取消息内容，消息读取后被移出队列
​ 4.2、消息只有唯一的发送者和接受者，但并不是说只能有一个接收者
5、发布订阅式：
​ 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个 主题，那么就会在消息到达时同时收到消息
6、JMS（Java Message Service）JAVA消息服务：
​ 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现
7、AMQP（Advanced Message Queuing Protocol）
​ 7.1、高级消息队列协议，也是一个消息代理的规范，兼容JMS
​ 7.2、RabbitMQ是AMQP的实现
8、Spring支持
​ 8.1、spring-jms提供了对JMS的支持
​ 8.2、spring-rabbit提供了对AMQP的支持
​ 8.3、需要ConnectionFactory的实现来连接消息代理
​ 8.4、提供JmsTemplate、RabbitTemplate来发送消息
​ 8.5、@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息 代理发布的消息
​ 8.6、@EnableJms、@EnableRabbit开启支持
9、Spring Boot自动配置
​ 9.1、JmsAutoConfiguration
​ 9.2、RabbitAutoConfiguration
10、市面的MQ产品
​ ActiveMQ、RabbitMQ、RocketMQ、Kafk
RabbitMQ概念 RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现
核心概念 Message
消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成， 这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可 能需要持久性存储）等。</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>博客一直使用firekylin搭建，最近看着typecho活跃度还可以，于是本周末用docker重新搭建了博客。
一、环境说明 操作系统：CentOS7.6
技术：Docker、MySQL、PHP、Nginx
使用工具：Xftp 7、Xshell 7、Notepad++
博客系统：Typecho
二、安装步骤 Docker环境搭建 Docker安装MySQL Docker安装PHP Docker安装Nginx 三、遇到问题 安装mysql、php、nginx时，映射文件路径错误，导致安装好后，找不到文件。
Nginx配置时映射路径错误、80端口自动转发443端口，导致http访问一直追加路径。
证书路径放置错误。
Typecho初始化安装时，提示&amp;quot;对不起，无法连接数据库，请先检查数据库配置再继续进行安装&amp;quot;。
四、解决方案 通过docker log 容器，查看日志，一步步解决。 添加异常提示代码：, $e-&amp;gt;getMessage() instal.php第56行，添加ob_start(); ip地址错误，默认localhost，docker安装时，需要改成公网ip或局域网ip。 未创建typecho数据库。 Nginx配置文件:
server { listen 443 ssl http2 reuseport; server_name yanxizhu.com www.yanxizhu.com; root /var/www/html/yanxizhu.com; index index.php; ssl on; ssl_certificate /etc/nginx/conf.d/自己证书.crt; ssl_certificate_key /etc/nginx/conf.d/自己证书key.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; access_log /var/log/nginx/typecho_access.log main; if (!-e $request_filename) { rewrite ^(.*)$ /index.php$1 last; } location ~ .</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>1、(信号量)Semaphore+(闭锁)CountDownLatch+(常用源自类)AtomicInteger package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; /** * @description: 线程安全 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/19 20:05 * @version: 1.0 */ @Slf4j @ThreadSafety public class DemoSemaphoreAndCountDownLatchAndAtomic { //用户数量 private static final int clientsTotal = 5000; //并发数量 private static final int concurrencyTotal = 200; //累加总和 private static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/</guid><description>可见性 可见性：一个线程对主内存的修改可以及时的被其它线程观察到。
导致共享变量在线程间不可见的原因：
线程交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主存间及时更新 可见性-synchronized JMM关于synchronized的两条规定：
线程解锁前，必须把共享变量的最新值刷新到主内存 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意，加锁与解锁是同一把锁） 可见性-volatile volatile，通过加入内存屏障和禁止重排序优化来实现。
对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量 volatile写：
volatile读：
有序性 Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性.
可通过volatile、synchronized、Lock保证有序性。
有序性-happens-before原则 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作 线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize（）方法的开始 线程安全性-总结 原子性：Atomic包、CAS算法、synchronized、Lock 可见性：synchronized、volatile 有序性：happens-before</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/</guid><description>在线网站 一、数据结构 数据结构动态图 https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
二、绘图 1、Processon on https://www.processon.com/diagrams
2、diagrams https://app.diagrams.net/
三、RabbitMQ RabbitMQ路由 http://tryrabbitmq.com/
四、算法 1、raft算法 http://thesecretlivesofdata.com/raft/</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E8%AF%A6%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E8%AF%A6%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>安全发布对象 什么是安全发布？
发布对象：使一个对象能够被当前范围之外的代码所使用
代码示例
package com.yanxizhu.demo.concurrency.unSafePublish; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.Arrays; /** * @description: 安全发布,这个例子是线程不安全的 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/21 21:45 * @version: 1.0 */ @Slf4j @UnThreadSafety public class UnSafePublish { private String[] states = {&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}; public String[] getStates() { return states; } public static void main(String[] args) { UnSafePublish unSafePublish = new UnSafePublish(); log.info(&amp;#34;{}&amp;#34;, Arrays.toString(unSafePublish.getStates())); unSafePublish.getStates()[0] = &amp;#34;d&amp;#34;; log.info(&amp;#34;{}&amp;#34;, Arrays.toString(unSafePublish.getStates())); } } 运行结果：
21:48:00.633 [main] INFO com.</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%B9%B6%E5%8F%91%E5%8F%8Acas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%B9%B6%E5%8F%91%E5%8F%8Acas/</guid><description>计算机架构 CPU多级缓存 为什么需要CPU cache CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu-&amp;gt;cache-&amp;gt;memory）。
CPU cache有什么意义 1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问 2）空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问；
CPU 多级缓存一致性（MESI） CPU缓存4种状态 M：被修改状态，指该缓存行只被缓存在该CPU的缓存中，并且是被修改过的。因此与主存中的数据是不一致的，该缓存行中的内存需要再未来的某个时间点写会主存。这个时间点是允许其它CPU读取主存中相应的内存之前，当这里面的值被写会主存之后该缓存行的状态会变成E独享状态。
E：独享状态，指缓存行只被缓存在该CPU的缓存中，它是未被修改过的，是和主存的数据一致的，这个状态可以在任何时刻，当有其它CPU读取该内存时变成S共享状态。当CPU修改该缓存行内容时，状态变成M状态。
S：共享状态，意味该缓存行可能被多个CPU缓存，并且各CPU缓存中的数据与主存中的数据一致，当有一个CPU修改该缓存行时，其它CPU中该缓存行，是可以被作废的，变成I无效状态。
I：无效状态，代表缓存无效，可能有其它CPU修改了该缓存行。
引起CPU缓存状态变化的4种操作 local read：读本地缓存中的数据
local write：将数据写到本地的缓存里面
remote read：将主内中的数据读取到本地缓存中
remote write：将本地缓存中数据写到主存里面
MESI协议：CPU缓存数据有4种状态，引起CPU缓存转变的操作也有4种，因此本质就是要理解这16种操作状态的关系，可以通过下图表示：
重点理解 1、CPU缓存是为了减少CPU读写共享主存的次数。
2、除了I状态，其它三种状态都是可以被读取的。
3、只有再M和E状态才能写。
4、当为S状态时，必须将该缓存行变为无效状态，一般通过广播方式完成，此时不允许不同的CPU同时修改该缓存行，即使修改该缓存行不同位置的数据也是不允许的，这里主要解决缓存一致性的问题。
5、只有M和E状态可以写，如果是S状态需要变为I状态。
6、一个处于M装的缓存行，需要时刻监听所有试图读该缓存行，相对有主存的操作，这种操作必须将缓存行写会到主存，并将状态变为S状态之前，被延迟执行。
7、S状态的缓存行，监听所有试图将该缓存行无效或独享该缓存行的请求，并将缓存行变为无效。
8、处于E状态的缓存行，需要监听其它读该缓存行的操作，一旦有该缓存行的操作，那么该缓存行需要变为S状态。因此对于M和E状态的数据总是精确的，和缓存行的状态是真正一致的。S状态可能是非一致的。如果一个缓存将处于S状态的数据作废了，另一个缓存实际上可能已经独享了该缓存行，但是该缓存不会把缓存行升迁为E状态，因为其它不会广播该作废的通知，同样由于缓存没有缓存该COPY的数量，因此也无法确定自己是否独享了该缓存行。E状态更像一种投机的优化，因为当一个CPU想修改一个处于S共享状态的缓存行，总线事务需要将所有copy该缓存行缓存的值变成I状态才行。修改E状态的CPU缓存不需要总线事务。
JAVA内存模型抽象结构图 JAVA内存模型8个操作 8种同步操作 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中 同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） compareAndSetInt 举例一 package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>循环依赖解决方案
1、查看日志，是哪个地方提示循环依赖。
2、取消自动注入
3、通过容器获取
4、构造方法赋值
例如：
public class MyRabbitConfig { //取消自动注入 // @Autowired RabbitTemplate rabbitTemplate; //通过构造解决循环依赖。(RabbitTemplate rabbitTemplate)：是从springboot容器自动注入的 public MyRabbitConfig(RabbitTemplate rabbitTemplate){ this.rabbitTemplate=rabbitTemplate; }</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid><description>一、创建仓库 注意：仓库名称、路径、选择语言、添加.gitignore、添加开源许可证、选择分支模型。
二、拉取项目 三、创建微服务模块-记账管理微服务 选择微服务必要组件
创建好第一个记账微服务后，项目结构。
然后安装上述步骤，依次创建出其它微服务模块。
各微服务共同点：
1、都导入了必备的spring web，OpenFeign
2、每一个服务，包名：com.yanxizhu.ifamily.xxxxx(booking/firend/。。。服务名)
3、模块名:ifamily-xxxxx(booking/fired/&amp;hellip;&amp;hellip;.服务名)
实例的包名：com.yanxizhu.ifamily.booking
模块名：ifamily-booking
四、设置总项目聚合各微服务 一、随便复制一个微服务的pom文件，粘贴到总项目中。
本次项目，如，复制ifamily-booking微服务中的pom.xml到总项目ifamily中。
二、修改总项目中的pom.xml文件。
1、修改模块名、项目名、描述
修改前：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily-booking&amp;lt;/artifactId&amp;gt;&amp;lt;!--1、模块名修改为总项目名--&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily-booking&amp;lt;/name&amp;gt;&amp;lt;!--2、修改为总项目名--&amp;gt; &amp;lt;description&amp;gt;家庭管理-记账服务&amp;lt;/description&amp;gt;&amp;lt;!--3、修改为聚合服务，把其它微服务聚合起来--&amp;gt; 修改后：
&amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;聚合服务&amp;lt;/description&amp;gt; 2、删除服务依赖
&amp;lt;parent&amp;gt;&amp;lt;!--删除父引用--&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.4&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; 3、删除多余的依赖：
4、添加类型，为pom
&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; 5、聚合其他微服务模块
&amp;lt;modules&amp;gt;&amp;lt;!--聚合其他微服务--&amp;gt; &amp;lt;module&amp;gt;ifamily-booking&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; 最终的pom文件内容如下：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.yanxizhu.ifamily&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ifamily&amp;lt;/artifactId&amp;gt;&amp;lt;!--模块名修改为总项目名--&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;ifamily&amp;lt;/name&amp;gt;&amp;lt;!--修改为总项目名--&amp;gt; &amp;lt;description&amp;gt;聚合服务&amp;lt;/description&amp;gt;&amp;lt;!--修改为聚合服务，把其它微服务聚合起来--&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;&amp;lt;!--设置类型--&amp;gt; &amp;lt;modules&amp;gt;&amp;lt;!--聚合其他微服务--&amp;gt; &amp;lt;module&amp;gt;ifamily-booking&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;!</description></item><item><title/><link>https://willxwu.github.io/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</guid><description>1、 RabbitMQ Simulator RabbitMQ模拟器，可用于模拟MQ消息的收发消费情况。使用下面的绘图区域来表示您的消息传递拓扑。 将消息元素从左侧的工具箱拖到画布上。 要连接节点，请按住 ALT 键（或 SHIFT 键）并从源节点拖动以将其连接到目标节点。 官网地址 http://tryrabbitmq.com
2、 draw.io draw.io 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等 官网地址 http://draw.io
3、 PuTTY PuTTY 是一个 SSH 和 telnet 客户端，最初由 Simon Tatham 为 Windows 平台开发。 PuTTY 是开源软件，提供源代码，由一群志愿者开发和支持。 官网地址 https://www.putty.org/
4、 WinSCP WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。 官网地址 https://winscp.net
5、 FastStone Capture FastStone Capture 是一款功能强大、轻巧但功能齐全的截图工具和屏幕录像机以及编辑共计。编辑工具包括注释（文本、箭头线、高光）、调整大小、裁剪、锐化、水印、应用边缘效果等等。其他功能包括图像扫描、全局热键、自动文件名生成、支持外部编辑器、颜色选择器、屏幕放大镜、屏幕十字准线和屏幕标尺等功能。 官网地址 https://www.faststone.org
6、 potplayer 一款功能强大、界面美观、简洁的视频播放器。 官网地址 https://potplayer.daum.net
7、 notepad++ Notepad++ 是一个免费的（如“言论自由”和“免费啤酒”）源代码编辑器和支持多种语言的记事本替代品。 在 MS Windows 环境中运行，其使用受 GNU 通用公共许可证管理。 官网地址 https://notepad-plus-plus.</description></item><item><title/><link>https://willxwu.github.io/posts/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</guid><description>接口幂等性 1、什么是幂等性 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用；比如说支付场景，用户购买了商品支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条&amp;hellip;，这就没有保证接口的幂等性。
2、哪些情况需要防止 用户多次点击按钮 用户页面回退再次提交 微服务互相调用，由于网络问题，导致请求失败。feign触发重试机制其他业务情况
3、什么情况下需要幂等 天然幂等的：以SQL为例，有些操作是。
SELECT*FROM table WHERid=？ 无论执行多少次都不会改变状态，是天然的幂等。
UPDATE tab1 SET col1=1WHERE col2=2 无论执行成功多少次状态都是一致的，也是幂等操作。
delete from user where userid=1 多次操作，结果一样，具备幂等性
insert into user（userid，name）values（1，a） 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。
不是幂等的
UPDATE tab1 SET col1=col1+1WHERE col2=2 每次执行的结果都会发生变化，不是幂等的。
insert into user（userid，name）values（1，a） 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。
4、幂等解决方案 一、token机制 1、服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。
2、然后调用业务接口请求时，把token携带过去，一般放在请求头部。 3、服务器判断token是否存在redis中，存在表示第一次请求，然后删除token，继续执行业务。
4、如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。
危险性： 1、先删除token 还是后删除token； （1）先删除可能导致，业务确实没有执行，重试还带上之前token，由于防重设计导致，请求还是不能执行。 （2）后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别人继续重试，导致业务被执行两边 （3）我们最好设计为先删除token，如果业务调用失败，就重新获取token 再次请求。 2、Token获取、比较和删除必须是原子性 （1）redis.get（token）、token.equals、redis.delltoken）如果这两个操作不是原子，可能导致，高并发下，都get 到同样的数据，判断都成功，继续业务并发执行
（2）可以在redis 使用lua脚本完成这个操作
if redis. call(&amp;#34;get&amp;#39;, KEYS[1])==ARGV[1] then return redis. call(&amp;#39; del&amp;#34;, KEYS[1]) else return 0 end 二、各种锁机制 1、数据库悲观锁</description></item><item><title/><link>https://willxwu.github.io/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github/</guid><description>create a new repository on the command line. push an existing repository from the command line. import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project.
create a new repository on the command line git init git add README.md git commit -m &amp;#34;first commit&amp;#34; git branch -M main git remote add origin https://github.com/willxwu/xxx.git git push -u origin main push an existing repository from the command line git remote add origin https://github.</description></item><item><title/><link>https://willxwu.github.io/posts/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid><description>本地事务 一、事务的基本性质 数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation) 和持久性(Durabilily)，简称就是ACID；
原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败 一致性：数据在事务的前后，业务整体一致。(A向B转账，转账前后AB总金额一致) 隔离性：事务之间互相隔离。 持久性：一旦事务成功，数据一定会落盘在数据库。 单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易的整体回滚；
Business：我们具体的业务代码 Storage：库存业务代码；扣库存 Order：订单业务代码；保存订单 Account：账号业务代码；减账户余额 比如买东西业务，扣库存，下订单，账户扣款，是一个整体；必须同时成功或者失败 一个事务开始，代表以下的所有操作都在同一个连接里面；
二、事务的隔离级别 READ UNCOMMITTED（读未提交）
该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。
READ COMMITTED（读提交）
一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重 复读问题，Oracle 和SQL Server 的默认隔离级别。
REPEATABLE READ（可重复读）
该隔离级别是MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间 点的状态，因此，同样的select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的InnoDB 引擎可以通过next-key locks 机制（行锁的算法）来避免幻读。
SERIALIZABLE（序列化）
在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的InnoDB 引擎会给读操作隐式 加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。
三、事务的传播行为 PROPAGATION_REQUIRED
如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
PROPAGATION_SUPPORTS
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
PROPAGATION_MANDATORY
支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
PROPAGATION_REQUIRES_NEW
创建新事务，无论当前存不存在事务，都创建新事务。
PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。
四、SpringBoot 事务关键点 事务的自动配置
TransactionAutoConfiguration
事务的坑
在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到 代理对象的缘故。
解决</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</guid><description>异步与线程池 1、初始化线程的4种方式 1）、继承Thread 2）、实现Runnable接口 3）、实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常） 4）、线程池
方式1和方式2：主进程无法获取线程的运算结果。不适合当前场景。
方式3：主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。 方式4：通过如下两种方式初始化线程池
Executors.newFiexed ThreadPool(3); //或者 new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,TimeUnit unit, workQueue,threadFactory,handler); 方式1、继续Thread /** * @description: 继承Thread * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/10 21:06 * @version: 1.0 */ public class MyThread { public static void main(String[] args) { System.out.println(&amp;#34;启动main方法开始&amp;#34;); OneMyThread oneMyThread = new OneMyThread(); oneMyThread.start(); System.out.println(&amp;#34;结束main方法&amp;#34;); } public static class OneMyThread extends Thread{ @Override public void run() { System.out.println(&amp;#34;当前线程：&amp;#34;+Thread.currentThread().getId()); int i = 10/2; System.out.println(&amp;#34;运行结果：&amp;#34;+i); } } } 运行结果:</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%86%99%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%86%99%E6%B3%95/</guid><description>线程不安全的类与写法 线程不安全的类：类的对象可以同时被多个线程访问，比如抛出异常，逻辑错误。下面介绍一些常见的类。
StringBuilder StringBuilder线程不安全的类
代码示例
package com.yanxizhu.demo.concurrency.threadUnSafetyClass; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; /** * @description: 线程不安全的类：StringBuilder * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/24 9:01 * @version: 1.0 */ @Slf4j @UnThreadSafety public class DemoStringBuilder { //用户数量 private static final int clientsTotal = 5000; //并发数量 private static final int concurrencyTotal = 200; //累加总和 private static StringBuilder stringBuilder = new StringBuilder(); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/</guid><description>线程八锁 package com.yanxizhu; /* * 题目：判断打印的 &amp;#34;one&amp;#34; or &amp;#34;two&amp;#34; ？ * * 1. 两个普通同步方法，两个线程，标准打印， 打印? //one two * 2. 新增 Thread.sleep() 给 getOne() ,打印? //one two * 3. 新增普通方法 getThree() , 打印? //three one two * 4. 两个普通同步方法，两个 Number 对象，打印? //two one * 5. 修改 getOne() 为静态同步方法，打印? //two one * 6. 修改两个方法均为静态同步方法，一个 Number 对象? //one two * 7. 一个静态同步方法，一个非静态同步方法，两个 Number 对象? //two one * 8. 两个静态同步方法，两个 Number 对象? //one two * * 线程八锁的关键： * ①非静态方法的锁默认为 this, 静态方法的锁为 对应的 Class 实例 * ②某一个时刻内，只能有一个线程持有锁，无论几个方法。 */ public class TestThread8Monitor { public static void main(String[] args) { Number number = new Number(); Number number2 = new Number(); new Thread(new Runnable() { @Override public void run() { number.</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</guid><description>线程安全-同步容器 主要包括 ArrayList -&amp;gt; Vector，Stack
HashMap-&amp;gt;HashTable（key、value不能为null） Collections.synchronizedXXX（List、Set、Map）
都是使用Synchronized进行修饰的，性能不是特别好。可以使用并发容器代替。
注意：同步容器也可能是线程步安全的。
同步容器线程步安全，代码示例：
package com.yanxizhu.demo.concurrency.synContainer; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import java.util.Vector; /** * @description: 同步容器，也可能出现线程不安全情况 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/24 10:32 * @version: 1.0 */ @UnThreadSafety public class DemoVecotNo { private static final Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;&amp;gt;(); public static void main(String[] args) { //一直循环 while(true) { //向vector容器放入值 for(int i=0; i &amp;lt;10; i++){ vector.add(i); } //线程1，向vector容器移除值 new Thread(()-&amp;gt;{ for(int i=0; i &amp;lt;vector.size(); i++){ vector.</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8j.u.c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8j.u.c/</guid><description>线程安全-并发容器J.U.C ArrayList -&amp;gt; CopyOnWriteArrayList HashSet、TreeSet -&amp;gt; CopyOnWriteArraySet 、ConcurrentSkipListSet HashMap、TreeMap -&amp;gt; ConcurrentHashMap 、ConcurrentSkipListMap CopyOnWriteArrayList 适合读多写少的场景。读的时候再原数组读不需要加锁，写的时候会copy一份会单独加锁。
代码示例：
package com.yanxizhu.demo.concurrency.concurrent; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.ArrayList; import java.util.List; import java.util.concurrent.*; /** * @description: 线程安全容器：CopyOnWriteArrayList * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/24 9:52 * @version: 1.0 */ @Slf4j @ThreadSafety public class DemoCopyOnWriteArrayList { // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; private static List&amp;lt;Integer&amp;gt; list = new CopyOnWriteArrayList&amp;lt;&amp;gt;(); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</guid><description>线程封闭 当访问共享数据时，通常是要使用同步。如果要避免使用同步，就是不提供共享数据。如果仅在单线程中访问数据，就不需要同步，这种技术就叫做线程封闭，它是实现线程安全最简单的方式之一。当某个对象封闭在一个线程当中时将自动实现线程安全性，即使被封闭的对象本身它并不是安全的，实现线程主要有三种方式。
实现线程封闭的三种方式：
1、Ad-hoc线程封闭：程序控制实现，最糟糕，忽略
2、堆栈封闭：局部变量，无并发问题：
栈封闭简单理解就是通过局部变量来实现线程封闭，多个线程访问对象的同一个方法，方法内部的局部变量会拷贝到每个线程的线程栈当中，只有当前线程才能访问到，互不干扰。所以局部变量是不被多个线程所共享的。尽量少用全局变量(不是全局常量)。
3、ThreadLocal线程封闭：特别好的封闭方法。
维护线程封闭一种更规范的方法就是使用ThreadLocal。ThreadLocal底层是一个map，可以就是线程名字，value就是我们封装的对象。ThreadLocal提供get、set方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回的是当前线程在调用set时设置的值。
ThreadLocal一般用于防止对可变的单实例变量或者全局变量进行共享。
ThreadLocal使用：代码示例
1、自定义ThreadLoca工具 package com.yanxizhu.demo.concurrency.DemoThrodLocal.ThreadLock; /** * @description: 使用ThrodLock的线程封闭，实现在一个线程种数据共享 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/22 22:56 * @version: 1.0 */ public class MyThroldLock { private final static ThreadLocal&amp;lt;Long&amp;gt; requestholder = new ThreadLocal&amp;lt;&amp;gt;(); //用ThreadLock提供的set方法，向ThreadLock中放入共享数据id //一般在实际接口处理前调用 public static void add(Long id) { requestholder.set(id); } //用ThreadLock提供的get方法获取ThreadLock中共享的数据 public static Long get() { return requestholder.get(); } //用ThreadLock提供的remove方法移除共享数据，不然容易导致内存溢出 //一般在接口真正处理完后调用 public static void remove() { requestholder.remove(); } } 2、自定义过滤器Filter package com.</description></item><item><title/><link>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%8C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%8C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF/</guid><description>线程按序交替
package com.yanxizhu; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: 线程按序交替 * @date: 2022/3/19 14:47 * @version: 1.0 */ public class PrintInfo { public static void main(String[] args) { print print = new print(); new Thread(new Runnable() { @Override public void run() { for(int i=1;i&amp;lt;5;i++){ try { print.printA(i); } catch (InterruptedException e) { e.printStackTrace(); } } } },&amp;#34;A&amp;#34;).start(); new Thread(new Runnable() { @Override public void run() { for(int i=1;i&amp;lt;5;i++){ try { print.</description></item><item><title/><link>https://willxwu.github.io/posts/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</guid><description>解决CAS的ABA问题
CAS虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。
什么是ABA问题 比如：
线程1从主存中读取值A，另一个线程2也从主存中读取值A，此时线程2将主存值修改成了B，然后线程2又将主存值修改成了A，这时候线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功，这是不正确的。
如何解决ABA问题 通过AtomicStampedReference的compareAndSet方法进行处理，这里的compareAndSet比一般的多了一个stamp的比较。
源码如下：
public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.reference &amp;amp;&amp;amp; expectedStamp == current.stamp &amp;amp;&amp;amp; ((newReference == current.reference &amp;amp;&amp;amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 多了一个stamp的比较，stamp是每次更新来维护的。</description></item><item><title/><link>https://willxwu.github.io/posts/%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 package com.yanxizhu; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @description: 读写锁(互斥锁) * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 15:23 * @version: 1.0 */ public class ReadWriteDemo { public static void main(String[] args) { ReadWriteTest readWriteTest = new ReadWriteTest(); new Thread(()-&amp;gt;{ readWriteTest.write((int) (Math.random()*101)); },&amp;#34;写锁&amp;#34;).start(); for(int i=1;i&amp;lt;50;i++){ new Thread(()-&amp;gt;{ readWriteTest.get(); },&amp;#34;读锁&amp;#34;).start(); } } } class ReadWriteTest{ int num =0; private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //读 public void get(){ readWriteLock.readLock().lock(); try{ System.out.println(num+&amp;#34;==&amp;#34;+Thread.currentThread().getName()); }finally { readWriteLock.</description></item><item><title/><link>https://willxwu.github.io/posts/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/posts/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>Jenkins容器docker部署springboot项目-问题记录 一、docker容器内不能使用vim 解决方案：
以root进入容器内
docker exec -it -user root jenkins /bin/bash 更新软件包
apt-get update 升级过程可能非常慢，因为是从海外站点拉取镜像，所以我们可以配置一个国内的镜像源，加速镜像拉取更新。
备份原文件
mv /etc/apt/sources.list /etc/apt/sources.list.bak 查看容器中Debian版本
cat /etc/issue 修改配置sources.list文件
根据自己版本修改成对应内容，修改内容参考阿里镜像https://developer.aliyun.com/mirror/debian
我容器Debian为11.x版本，修改内容为：
deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib 重新执行</description></item></channel></rss>