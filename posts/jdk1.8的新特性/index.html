<!doctype html><html lang=en-us><head><title>// willxwu</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.104.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="John Doe"><meta name=description content><link rel=stylesheet href=https://willxwu.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="JDK1.8的新特性 一、接口的默认方法 Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：
代码如下：
interface Formula{ double calculate(int a); default double sqrt(int a){ return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下： Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0
文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt（a*100）。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注：在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，Java8的这个在语义上有差别。
二、Lambda表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下：
List names=Arrays.asList（&ldquo;peterF&rdquo;，&ldquo;anna&rdquo;，&ldquo;mike&rdquo;，&ldquo;xenia&rdquo;）； Collections.sort（names，new Comparator）{@Override public int compare（String a，String b）{ return b.compareTo（a）；}}）；
只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java8中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式： 代码如下： Collections.sort（names，（String a，String b）->{return b.compareTo（a）；}）；
看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下： Collections.sort（names，（String a，String b）->b.compareTo（a）；
对于函数体只有一行代码的，你可以去掉大括号0以及return关键字，但是你还可以写得更短点：
代码如下： Collections.sort（names，（a，b）>b.compareTo（a）；
Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：
三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？
每一个lambda表达式都对应一个类型，通常是接口类型。 而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@Functionallnterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。
示例如下：
代码如下： @Functionallnterface interface Converter<F，T>{T convert（F from）；}Converter<String，Integer>converter= from）->Integer."><meta property="og:title" content><meta property="og:description" content="JDK1.8的新特性 一、接口的默认方法 Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：
代码如下：
interface Formula{ double calculate(int a); default double sqrt(int a){ return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下： Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0
文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt（a*100）。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注：在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，Java8的这个在语义上有差别。
二、Lambda表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下：
List names=Arrays.asList（&ldquo;peterF&rdquo;，&ldquo;anna&rdquo;，&ldquo;mike&rdquo;，&ldquo;xenia&rdquo;）； Collections.sort（names，new Comparator）{@Override public int compare（String a，String b）{ return b.compareTo（a）；}}）；
只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java8中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式： 代码如下： Collections.sort（names，（String a，String b）->{return b.compareTo（a）；}）；
看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下： Collections.sort（names，（String a，String b）->b.compareTo（a）；
对于函数体只有一行代码的，你可以去掉大括号0以及return关键字，但是你还可以写得更短点：
代码如下： Collections.sort（names，（a，b）>b.compareTo（a）；
Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：
三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？
每一个lambda表达式都对应一个类型，通常是接口类型。 而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@Functionallnterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。
示例如下：
代码如下： @Functionallnterface interface Converter<F，T>{T convert（F from）；}Converter<String，Integer>converter= from）->Integer."><meta property="og:type" content="article"><meta property="og:url" content="https://willxwu.github.io/posts/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"><meta property="article:section" content="posts"></head><body><header class=app-header><a href=https://willxwu.github.io/><img class=app-header-avatar src=/avatar.jpg alt="John Doe"></a><h1>willxwu</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>about</a>
-
<a class=app-header-menu-item href=/>home</a>
-
<a class=app-header-menu-item href=/link/>link</a>
-
<a class=app-header-menu-item href=/tags/>tags</a></nav><p>I write code and I take care about my privacy // Co-founder @ Owaka // Golang lover // Open source enthusiast</p><div class=app-header-social><a target=_blank href=https://github.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://twitter.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 1, 0001</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div></div></header><div class=post-content><h1 id=jdk18的新特性>JDK1.8的新特性</h1><h1 id=一接口的默认方法>一、接口的默认方法</h1><p>Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p><p>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Formula</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>calculate</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>sqrt</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>sqrt</span><span style=color:#f92672>(</span>a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。
代码如下：
Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a<em>100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0</em></p><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算sqrt（a*100）。在下一节中，我们将会看到实现单方法接口的更简单的做法。
译者注：在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，Java8的这个在语义上有差别。</p><h1 id=二lambda表达式>二、Lambda表达式</h1><p>首先看看在老版本的Java中是如何排列字符串的：
代码如下：</p><p>List names=Arrays.asList（&ldquo;peterF&rdquo;，&ldquo;anna&rdquo;，&ldquo;mike&rdquo;，&ldquo;xenia&rdquo;）；
Collections.sort（names，new Comparator）{@Override public int compare（String a，String b）{
return b.compareTo（a）；}}）；</p><p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。
在Java8中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式：
代码如下：
Collections.sort（names，（String a，String b）->{return b.compareTo（a）；}）；</p><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：
代码如下：
Collections.sort（names，（String a，String b）->b.compareTo（a）；</p><p>对于函数体只有一行代码的，你可以去掉大括号0以及return关键字，但是你还可以写得更短点：</p><p>代码如下：
Collections.sort（names，（a，b）>b.compareTo（a）；</p><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p><h1 id=三函数式接口>三、函数式接口</h1><p>Lambda表达式是如何在java的类型系统中表示的呢？</p><p>每一个lambda表达式都对应一个类型，通常是接口类型。
而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。
我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@Functionallnterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><p>代码如下：
@Functionallnterface interface Converter&lt;F，T>{T convert（F from）；}Converter&lt;String，Integer>converter=
from）->Integer.valueOf（from）；Integer converted=converter.convert（&ldquo;123&rdquo;）；System.out.printin（converted）；//123</p><p>需要注意如果@Functionallnterface如果没有指定，上面的代码也是对的。
译者注将lambda表达式映射到一个单方法的接口上，这种做法在Java8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget的addEventListener 第二个参数EventListener。</p><h1 id=四方法与构造函数引用>四、方法与构造函数引用</h1><p>前一节中的代码还可以通过静态方法引用来表示：
代码如下：
Converter&lt;String，Integer>converter=Integer:valueOf；Integer converted=converter.convert（&ldquo;123&rdquo;）；System.out.printin（converted）；//123
Java8允许你使用：关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：
代码如下：
converter=something:：startsWith；String converted=converter.convert（&ldquo;Java&rdquo;）；System.out.printin（converted）；//"
接下来看看构造函数是如何使用：关键字来引用的，首先我们定义一个包含多个构造函数的简单类：
代码如下：</p><p>代码如下：
Converter&lt;String，Integer> converter=Integer:：valueOf；Integer converted=converter.convert（&ldquo;123&rdquo;）；System.out.println（converted）；//123
Java8允许你使用：：关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：
代码如下：
converter=something:startsWith；String converted=converter.convert（&ldquo;Java&rdquo;）；system.out.println（converted）；/∥"y"
接下来看看构造函数是如何使用：关键字来引用的，首先我们定义一个包含多个构造函数的简单类：
代码如下：
class Person{String firstName；String lastName；Person）}
Person（String firstName，String lastName）{this.firstName =firstName；this.lastName=lastName；}}
接下来我们指定一个用来创建Person对象的对象工厂接口：
代码如下：
interface PersonFactory{P create（String firstName，String lastName）；}
这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：
代码如下：</p><p>PersonFactorypersonFactory=Person:：new；Person person=personFactory.create（&ldquo;Peter&rdquo;，
&ldquo;Parker&rdquo;）；</p><p>我们只需要使用Person:：new来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p><h1 id=五lambda作用域>五、Lambda作用域</h1><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p><h1 id=六访问局部变量>六、访问局部变量</h1><p>我们可以直接在lambda表达式中访问外层的局部变量：
代码如下：
final int num=1；Converter&lt;Integer，String>stringConverter=（from）->String.valueof（from +num）；stringConverter.convert（2）；//3</p><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：
代码如下：
int num=1；Converter&lt;Integer，String>stringConverter=（from）->String.valueof（from+num）；stringConverter.conver（2）；//3</p><p>不过这里的num必须不可被后面的代码修改（即隐性的具有fina的语义），例如下面的就无法编译：
代码如下：
int num=1；Converter&lt;Integer，String>stringConverter =（from）->string.valueof（from +num）；num=3；</p><p>在lambda表达式中试图修改num同样是不允许的。</p><h1 id=七访问对象字段与静态变量>七、访问对象字段与静态变量</h1><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：
代码如下：
class Lambda4{static int outerStaticNum；int outerNum；void testScopes（）{Converter&lt;Integer，String>stringConverter1=（from）->{outerNum=23；return String.valueof（from）；}；Converter&lt;Integer，String>stringConverter2=（from）->{outerStaticNum=72；return String.valueof（from）；}；}}</p><h1 id=八访问接口的默认方法>八、访问接口的默认方法</h1><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：
代码如下：
Formula formula=（a）->sqrt（a*100）；Built-in Functional Interfaces</p><p>JDK 1.8API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@Functionallnterface注解以便能用在lambda上。Java8APl同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><p><strong>Predicate接口</strong>
Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：
代码如下：
Predicatepredicate=（s）->s.length（）>0；predicate.test（&ldquo;foo&rdquo;）；//true predicate.negate（）.test（&ldquo;foo&rdquo;）；//false Predicate nonNull =Objects:nonNull；PredicateisNull=Objects:isNull；PredicateisEmpty=String:isEmpty；PredicateisNotEmpty=isEmpty.negate（）；</p><p><strong>Function接口</strong>
Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose，andThen）：代码如下：
Function&lt;String，Integer> tolnteger=Integer:valueOf；Function&lt;String，String>backToString=
tolnteger.andThen（String:valueOf）；backToString.apply（&ldquo;123&rdquo;）；//&ldquo;123&rdquo;</p><p>Supplier 接口Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数代码如下：
Supplier personSupplier=Person:new；personSupplier get（）；//new Person</p><p><strong>Consumer 接口</strong>Consumer接口表示执行在单个参数上的操作。
代码如下：
Consumergreeter=（p）->System.out.println（&ldquo;Hello，"+p.firstName）；greeter.accept（new Person（&ldquo;Luke&rdquo;，&ldquo;Skywalker&rdquo;））；</p><p>Comparator 接口Comparator是老ava中的经典接口，Java8在此之上添加了多种默认方法：
代码如下：
Comparatorcomparator =（p1，p2）->p1.firstName.compareTo（p2.firstName）；Person p1=new Person（&ldquo;John&rdquo;，&ldquo;Doe&rdquo;）；Person p2=new Person（&ldquo;Alice&rdquo;，&ldquo;Wonderland&rdquo;）；comparator.compare（p1，p2）；//>0 comparator.reversed（）.compare（p1，p2）；//&lt;0</p><p><strong>optional接口</strong>
Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：
Optional被定义为一个简单的容器，其值可能是null或者不是null。在Java8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java8中，不推荐你返回null而是返回Optional。
代码如下：
Optionaloptional=Optional.of（&ldquo;bam&rdquo;）；optional.isPresent（）；//true optional.get（）；//&ldquo;bam"optional.orElse（&ldquo;fallback&rdquo;）；//&ldquo;bam&rdquo;</p><p>optional.ifPresent((s)->System.out.println(s.charAt(O));//&ldquo;b&rdquo;</p><p><strong>Stream接口</strong>
java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。
Stream 的创建需要指定一个数据源，比如java.util.Collection的子类，List或者Set，Map不支持。Stream的操作可以串行执行或者并行执行。
首先看看Stream是怎么用，首先创建实例代码的用到的数据List：
代码如下：
List stringCollection=new ArrayList&lt;>（）；；stringCollection.add（&ldquo;ddd2&rdquo;）；stringCollection.add（&ldquo;aaa2&rdquo;）；stringCollection.add（&ldquo;bbb1&rdquo;）；stringCollection.add（&ldquo;aaa1&rdquo;）；stringCollection.add（&ldquo;bbb3&rdquo;）；stringCollection.add（&ldquo;ccc&rdquo;）；stringCollection.add（&ldquo;bbb2&rdquo;）；stringCollection.add（&ldquo;ddd1&rdquo;）；Java 8扩展了集合类，可以通过Collection.stream（）或者Collection.parallelStream（）来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><p><strong>Filter 过滤</strong>
过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。
代码如下：
stringCollection.stream（）.filter（s）->s.startsWith（&ldquo;a&rdquo;）.forEach（System.out:：println）；
//&ldquo;aaa2&rdquo;，&ldquo;aaal&rdquo;</p><p><strong>Sort 排序</strong>
排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。
代码如下：
stringCollection.stream（）.sorted（）.filter（s）->s.startsWith（&ldquo;a&rdquo;））.forEach（System.out:printin）；
//&ldquo;aaa1&rdquo;，&ldquo;aaa2&rdquo;
需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据
stringCollection是不会被修改的：
代码如下：
System.out.printin（stringCollection）；//ddd2，aaa2，bbb1，aaal，bbb3，ccc，bbb2，ddd1
Map映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。
代码如下：
stringCollection.stream（）.map（String:toUpperCase）.sorted（a，b）->b.compareTo（a））
.forEach（System.out:printin）；
//&ldquo;DDD2&rdquo;，&ldquo;DDD1&rdquo;，&ldquo;CCC&rdquo;，&ldquo;BBB3&rdquo;，&ldquo;BBB2&rdquo;，&ldquo;AAA2&rdquo;，&ldquo;AAA1&rdquo;</p><p>Map映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。
代码如下：
stringCollection.stream（）.map（String:toUpperCase）.sorted（（a，b）->b.compareTo（a））
.forEach（System.out:printin）；
//&ldquo;DDD2&rdquo;，&ldquo;DDD1&rdquo;，&ldquo;CCC&rdquo;，&ldquo;BBB3&rdquo;，&ldquo;BBB2&rdquo;，&ldquo;AAA2&rdquo;，&ldquo;AAA1&rdquo;</p><p><strong>Match 匹配</strong>
Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。
代码如下：
boolean anyStartsWithA=stringCollection.stream（）.anyMatch（s）->s.startsWith（&ldquo;a&rdquo;）；System.out.printin（anystartsWithA）；/∥true boolean allStartsWithA=stringCollection.stream（）.allMatch（s）->s.startsWith（&ldquo;a&rdquo;））；System.out.printin（allStartsWithA）；//false boolean noneStartsWithZ=stringCollection.stream（）.noneMatch（s）->s.startsWith（&ldquo;z&rdquo;）；System.out.printin（noneStartsWithZ）；//true</p><p>Count计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。
代码如下：
long startsWithB=stringCollection.stream（）.filter（（s）->s.startsWith（&ldquo;b&rdquo;））.count（）；System.out.printin（startsWithB）；//3
Reduce规约
这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p><p>代码如下：
Optional reduced=stringCollection.stream（）.sorted）.reduce（（51，52）->51+&rdquo;#"+52）；reduced.ifPresent（System.out:：println）；//&ldquo;aaal#aaa2#bbb1#bbb2#bbb3#cCC#ddd1#ddd2&rdquo;</p><p>并行<strong>Streams</strong></p><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。
下面的例子展示了是如何通过并行Stream来提升性能：
首先我们创建一个没有重复元素的大表：
代码如下：</p><p>int max=1000000; List values=new Arraylist&lt;>(max); for(inti=0;i&lt; max;i++){ UUID uuid=
UUID. randomUUID(); values. add(uuid. toString());}</p><p>然后我们计算一下排序这个Stream要耗时多久，串行排序：
代码如下：</p><p>long to=System. nanoTime(); long count=values. stream(). sorted(). count(); System. out. println(count); long t1=System. nanoTime(); long millis =TimeUnit. NANOSECONDS. toMillis(t1-to); System. out. println(String. format(&ldquo;sequential sort took:%d ms&rdquo;, millis);</p><p>∥串行耗时：899ms并行排序：</p><p>代码如下：
long to=System.nanoTime（）；long count=values.parallelStream（）.sorted）.count（）；System.out.println（count）；long t1=System.nanoTime（）；long mills=TimeUnit.NANOSECONDS.toMillis（t1-to）；System.out.printin（String.format（&ldquo;parallel sort took：
%d ms&rdquo;，millis））；</p><p>//并行排序耗时：472ms上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream（）改为parallelStream（）。</p><p>Map前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。
代码如下：
Map&lt;Integer，String>map=new HashMap&lt;>）；for（inti=0；i&lt;10；i++）{map.putlfAbsent（i，&ldquo;val&rdquo;+i）；}
map.forEach（id，val）>System.out.println（val）；以上代码很容易理解，putlfAbsent不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。
下面的例子展示了map上的其他有用的函数：</p><p>代码如下：</p><p>map. computelfPresent(3,(num, val)->val+num); map. get(3);//val33
map. computelfPresent(9,(num, val)->nul); map. containsKey(9);//falsemap. computelfAbsent(23, num->&ldquo;val&rdquo;+num); map. containsKey(23);//true map. computelfAbsent(3, num->&ldquo;bam&rdquo;); map. get(3);//val33</p><p>接下来展示如何在Map里删除一个键值全都匹配的项：
代码如下：
map.remove（3，&ldquo;val3&rdquo;）；map.get（3）；//val33map.remove（3，&ldquo;val33&rdquo;）；map.get（3）；/∥null另外一个有用的方法：
代码如下：
map.getOrDefault（42，&ldquo;not found&rdquo;）；//not found对Map的元素做合并也变得很容易了：
代码如下：</p><p>map.getOrDefault（42，&ldquo;not found&rdquo;）；//not found对Map的元素做合并也变得很容易了：
代码如下：
map.merge（9，&ldquo;val9&rdquo;，（value，newValue）->value.concat（newValue））；map.get（9）；//val9
map.merge（9，&ldquo;concat&rdquo;，（value，newValue）->value.concat（newValue）；map.get（9）；//val9concat Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h1 id=九date-api-java-8在包javatime下包含了一组全新的时间日期apl>九、Date API Java 8在包java.time下包含了一组全新的时间日期APl。</h1><p>新的日期APl和开源Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新APl里最重要的一些部分：</p><p><strong>Clock时钟</strong>
Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMils0来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。
代码如下：
Clock clock=Clock.systemDefaultZone（）；long millis =clock.mils（）；Instant instant=clock.instant（）；Date legacyDate=Date.from（instant）；//legacy java.util.Date</p><p><strong>Timezones时区</strong>
在新API中时区使用Zoneld来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。
代码如下：
System.out.println（Zoneld.getAvailableZonelds（））；//prints all available timezone ids Zoneld zone1=Zoneld.of（&ldquo;Europe/Berlin&rdquo;）；Zoneld zone2=Zoneld.of（&ldquo;Brazil/East&rdquo;）；System.out.println（zone1.getRules（）；System.out.printin（zone2.getRules（））；</p><p><strong>LocalTime本地时间</strong>
LocalTime 定义了一个没有时区信息的时间，例如晚上10点，或者17：30：15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：
代码如下：
LocalTime now1=LocalTime.now（zone1）；LocalTime now2=LocalTime.now（zone2）；System.out.println（now1.isBefore（now2）；//false long hoursBetween=ChronoUnit.HOURS.between（now1，now2）；long minutesBetween=
ChronoUnit.MINUTES.between（now1，now2）；System.out.println（hoursBetween）；//-3 System.out.printin（minutesBetween）；//-239
LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。
代码如下：
LocalTime late =LocalTime.of（23，59，59）；System.out.println（late）；//23：59：59
DateTimeFormatter germanFormatter=Date TimeFormatter.ofLocalizedTime（FormatStyle.SHORT）
.withLocale（Locale.GERMAN）；LocalTime leetTime=LocalTime.parse（&ldquo;13：37&rdquo;，germanFormatter）；System.out.printin（leetTime）；//13：37</p><p><strong>LocalDate本地日期</strong></p><p>LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。
代码如下：</p><p>LocalDate today=LocalDate.now（）；LocalDate tomorrow =today.plus（1，Chronounit.DAYS）；LocalDate yesterday=tomorrow.minusDays（2）；LocalDate independenceDay =LocalDate.of（2014，Month.JULY，4）；DayofWeek dayofweek=
independenceDay.getDayOfWeek（）；System.out.printin（dayofWeek）；//FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：
代码如下：
DateTimeFormatter germanFormatter=Date TimeFormatter.ofLocalizedDate（FormatStyle.MEDIUM）
.withLocale（Locale.GERMAN）；LocalDate xmas =LocalDate.parse（&ldquo;24.12.2014&rdquo;，germanFormatter）；System.out.println（xmas）；//2014-12-
24</p><p><strong>LocalDateTime 本地日期时间</strong>
LocalDateTime同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。
代码如下：
LocalDate Time sylvester=LocalDate Time.of（2014，Month.DECEMBER，31，23，59，59）；DayofWeek dayofWeek=sylvester.getDayofWeek（）；System.out.println（dayOfWeek）；//WEDNESDAY Month month=sylvester.getMonth（）；System.out.println（month）；//DECEMBER long minuteOfDay=sylvester getLong（ChronoField.MINUTE_OF_DAY）；System.out.println（minuteOfDay）；//
1439只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。
代码如下：
Instant instant=sylvester.atZone（Zoneld.systemDefault（）.tolnstant（）；Date legacyDate=Date.from（instant）；System.out.printin（legacyDate）；//Wed Dec 31 23：59：59 CET 2014格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><p>代码如下：
DateTimeFormatter formatter=DateTimeFormatter.ofPattern（&ldquo;MMM dd，yyyy-HH:mm&rdquo;）；LocalDateTime parsed=LocalDateTime.parse（&ldquo;Nov 03，2014-07：13&rdquo;，formatter）；String string=
formatter.format（parsed）；System.out.println（string）；//Nov 03，2014-07：13和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><h1 id=十annotation-注解>十、Annotation 注解</h1><p>在Java8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解：
代码如下：
@interface Hints{Hint]value（）；}
@Repeatable（Hints.class）@interface Hint{String value（）；}
Java8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。
例1：使用包装类当容器来存多个注解（老方法）代码如下：
@Hints（{@Hint（&ldquo;hint1&rdquo;），@Hint（&ldquo;hint2&rdquo;）}）class Person}
例2：使用多重注解（新方法）</p><p>代码如下：
@Hint（&ldquo;hint1&rdquo;）@Hint（&ldquo;hint2&rdquo;）class Person}</p><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：
代码如下：</p><p>Hint hint=Person. class. getAnnotation(Hint. class); System. out. println(hint);//null Hints hints1=Person. class. getAnnotation(Hints. class); System. out. printin(hints1. value(). length);//2</p><p>Hint[]hints2=Person.class.getAnnotationsBy Type（Hint.class）；System.out.printin（hints2.length）；//2即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation（Hints.class）来获取@Hints注解，更加方便的方法是使用getAnnotationsBy Type 可以直接获取到所有的@Hint注解。另外ava8的注解还增加到两种新的target上了：
代码如下：
@Target{ElementType.TYPE_PARAMETER，ElementType.TYPE_USE}）@interface MyAnnotation}
关于Java8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK1.8里还有很多很有用的东西，比如Arrays.parallelSort，StampedLock和CompletableFuture等等。</p></div><div class=post-footer></div></article></main></body></html>