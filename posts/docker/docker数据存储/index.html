<!doctype html><html lang=en-us><head><title>// willxwu</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="John Doe"><meta name=description content><link rel=stylesheet href=https://willxwu.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Docker数据存储
默认情况下，在运行中的容器里创建的文件，被保存在一个可写的容器层：

如果容器被删除了，则数据也没有了
这个可写的容器层是和特定的容器绑定的，也就是这些数据无法方便的和其它容器共享

Docker主要提供了两种方式做数据的持久化

Data Volume, 由Docker管理，(/var/lib/docker/volumes/ Linux), 持久化数据的最好方式
Bind Mount，由用户指定存储的数据具体mount在系统什么位置


一、Data Volume
环境准备
准备一个Dockerfile 和一个 my-cron的文件
$ ls
Dockerfile  my-cron
$ more Dockerfile
FROM alpine:latest
RUN apk update
RUN apk --no-cache add curl
ENV SUPERCRONIC_URL=https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 \
    SUPERCRONIC=supercronic-linux-amd64 \
    SUPERCRONIC_SHA1SUM=048b95b48b708983effb2e5c935a1ef8483d9e3e
RUN curl -fsSLO &#34;$SUPERCRONIC_URL&#34; \
    && echo &#34;${SUPERCRONIC_SHA1SUM}  ${SUPERCRONIC}&#34; | sha1sum -c - \
    && chmod +x &#34;$SUPERCRONIC&#34; \
    && mv &#34;$SUPERCRONIC&#34; &#34;/usr/local/bin/${SUPERCRONIC}&#34; \
    && ln -s &#34;/usr/local/bin/${SUPERCRONIC}&#34; /usr/local/bin/supercronic
COPY my-cron /app/my-cron
WORKDIR /app

VOLUME [&#34;/app&#34;]

# RUN cron job
CMD [&#34;/usr/local/bin/supercronic&#34;, &#34;/app/my-cron&#34;]
$
$ more my-cron
*/1 * * * * date >> /app/test.txt
构建镜像
$ docker image build -t my-cron .
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
my-cron      latest    e9fbd9a562c9   4 seconds ago   24.7MB
创建容器(不指定-v参数)
此时Docker会自动创建一个随机名字的volume，去存储我们在Dockerfile定义的volume VOLUME [&#34;/app&#34;]
$ docker run -d my-cron
9a8fa93f03c42427a498b21ac520660752122e20bcdbf939661646f71d277f8f
$ docker volume ls
DRIVER    VOLUME NAME
local     043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
$ docker volume inspect 043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-22T23:06:13+02:00&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264/_data&#34;,
        &#34;Name&#34;: &#34;043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
在这个Volume的mountpoint可以发现容器创建的文件。
创建容器(指定-v参数)
在创建容器的时候通过 -v 参数我们可以手动的指定需要创建Volume的名字，以及对应于容器内的路径，这个路径是可以任意的，不必需要在Dockerfile里通过VOLUME定义。
比如我们把上面的Dockerfile里的VOLUME删除
FROM alpine:latest
RUN apk update
RUN apk --no-cache add curl
ENV SUPERCRONIC_URL=https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 \
    SUPERCRONIC=supercronic-linux-amd64 \
    SUPERCRONIC_SHA1SUM=048b95b48b708983effb2e5c935a1ef8483d9e3e
RUN curl -fsSLO &#34;$SUPERCRONIC_URL&#34; \
    && echo &#34;${SUPERCRONIC_SHA1SUM}  ${SUPERCRONIC}&#34; | sha1sum -c - \
    && chmod +x &#34;$SUPERCRONIC&#34; \
    && mv &#34;$SUPERCRONIC&#34; &#34;/usr/local/bin/${SUPERCRONIC}&#34; \
    && ln -s &#34;/usr/local/bin/${SUPERCRONIC}&#34; /usr/local/bin/supercronic
COPY my-cron /app/my-cron
WORKDIR /app

# RUN cron job
CMD [&#34;/usr/local/bin/supercronic&#34;, &#34;/app/my-cron&#34;]
重新build镜像，然后创建容器，加-v参数
$ docker image build -t my-cron .
$ docker container run -d -v cron-data:/app my-cron
43c6d0357b0893861092a752c61ab01bdfa62ea766d01d2fcb8b3ecb6c88b3de
$ docker volume ls
DRIVER    VOLUME NAME
local     cron-data
$ docker volume inspect cron-data
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-22T23:25:02+02:00&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/cron-data/_data&#34;,
        &#34;Name&#34;: &#34;cron-data&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
$ ls /var/lib/docker/volumes/cron-data/_data
my-cron
$ ls /var/lib/docker/volumes/cron-data/_data
my-cron  test.txt
环境清理
强制删除所有容器，系统清理和volume清理
$ docker rm -f $(docker container ps -aq)
$ docker system prune -f
$ docker volume prune -f
二、Bind Mount
只需要将-v的data volume换成指定路径即可。windows下的linux就可以直接挂载到磁盘，linx的可以直接查看。
例如mysql
docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=密码 \
-d mysql:5.7
-v /mydata/mysql/log:/var/log/mysql
这里就是将容器中/var/log/mysql日志，通过Bind Mount持久化到linux主机的/mydata/mysql/log目录。
多个机器之间的容器共享数据

官方参考链接 https://docs.docker.com/storage/volumes/#share-data-among-machines
Docker的volume支持多种driver。默认创建的volume driver都是local
$ docker volume inspect vscode
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-23T21:33:57Z&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/vscode/_data&#34;,
        &#34;Name&#34;: &#34;vscode&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
这一节我们看看一个叫sshfs的driver，如何让docker使用不在同一台机器上的文件系统做volume
环境准备
准备三台Linux机器，之间可以通过SSH相互通信。



hostname
ip
ssh username
ssh password




docker-host1
192.168.200.10
vagrant
vagrant


docker-host2
192.168.200.11
vagrant
vagrant


docker-host3
192.168.200.12
vagrant
vagrant



安装plugin
在其中两台机器上安装一个plugin vieux/sshfs
[vagrant@docker-host1 ~]$ docker plugin install --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
[vagrant@docker-host2 ~]$ docker plugin install --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
创建volume
[vagrant@docker-host1 ~]$ docker volume create --driver vieux/sshfs \
                          -o sshcmd=vagrant@192.168.200.12:/home/vagrant \
                          -o password=vagrant \
                          sshvolume
查看
[vagrant@docker-host1 ~]$ docker volume ls
DRIVER               VOLUME NAME
vieux/sshfs:latest   sshvolume
[vagrant@docker-host1 ~]$ docker volume inspect sshvolume
[
    {
        &#34;CreatedAt&#34;: &#34;0001-01-01T00:00:00Z&#34;,
        &#34;Driver&#34;: &#34;vieux/sshfs:latest&#34;,
        &#34;Labels&#34;: {},
        &#34;Mountpoint&#34;: &#34;/mnt/volumes/f59e848643f73d73a21b881486d55b33&#34;,
        &#34;Name&#34;: &#34;sshvolume&#34;,
        &#34;Options&#34;: {
            &#34;password&#34;: &#34;vagrant&#34;,
            &#34;sshcmd&#34;: &#34;vagrant@192.168.200.12:/home/vagrant&#34;
        },
        &#34;Scope&#34;: &#34;local&#34;
    }
]
创建容器挂载Volume
创建容器，挂载sshvolume到/app目录，然后进入容器的shell，在/app目录创建一个test.txt文件
"><meta property="og:title" content><meta property="og:description" content="Docker数据存储
默认情况下，在运行中的容器里创建的文件，被保存在一个可写的容器层：

如果容器被删除了，则数据也没有了
这个可写的容器层是和特定的容器绑定的，也就是这些数据无法方便的和其它容器共享

Docker主要提供了两种方式做数据的持久化

Data Volume, 由Docker管理，(/var/lib/docker/volumes/ Linux), 持久化数据的最好方式
Bind Mount，由用户指定存储的数据具体mount在系统什么位置


一、Data Volume
环境准备
准备一个Dockerfile 和一个 my-cron的文件
$ ls
Dockerfile  my-cron
$ more Dockerfile
FROM alpine:latest
RUN apk update
RUN apk --no-cache add curl
ENV SUPERCRONIC_URL=https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 \
    SUPERCRONIC=supercronic-linux-amd64 \
    SUPERCRONIC_SHA1SUM=048b95b48b708983effb2e5c935a1ef8483d9e3e
RUN curl -fsSLO &#34;$SUPERCRONIC_URL&#34; \
    && echo &#34;${SUPERCRONIC_SHA1SUM}  ${SUPERCRONIC}&#34; | sha1sum -c - \
    && chmod +x &#34;$SUPERCRONIC&#34; \
    && mv &#34;$SUPERCRONIC&#34; &#34;/usr/local/bin/${SUPERCRONIC}&#34; \
    && ln -s &#34;/usr/local/bin/${SUPERCRONIC}&#34; /usr/local/bin/supercronic
COPY my-cron /app/my-cron
WORKDIR /app

VOLUME [&#34;/app&#34;]

# RUN cron job
CMD [&#34;/usr/local/bin/supercronic&#34;, &#34;/app/my-cron&#34;]
$
$ more my-cron
*/1 * * * * date >> /app/test.txt
构建镜像
$ docker image build -t my-cron .
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
my-cron      latest    e9fbd9a562c9   4 seconds ago   24.7MB
创建容器(不指定-v参数)
此时Docker会自动创建一个随机名字的volume，去存储我们在Dockerfile定义的volume VOLUME [&#34;/app&#34;]
$ docker run -d my-cron
9a8fa93f03c42427a498b21ac520660752122e20bcdbf939661646f71d277f8f
$ docker volume ls
DRIVER    VOLUME NAME
local     043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
$ docker volume inspect 043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-22T23:06:13+02:00&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264/_data&#34;,
        &#34;Name&#34;: &#34;043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
在这个Volume的mountpoint可以发现容器创建的文件。
创建容器(指定-v参数)
在创建容器的时候通过 -v 参数我们可以手动的指定需要创建Volume的名字，以及对应于容器内的路径，这个路径是可以任意的，不必需要在Dockerfile里通过VOLUME定义。
比如我们把上面的Dockerfile里的VOLUME删除
FROM alpine:latest
RUN apk update
RUN apk --no-cache add curl
ENV SUPERCRONIC_URL=https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 \
    SUPERCRONIC=supercronic-linux-amd64 \
    SUPERCRONIC_SHA1SUM=048b95b48b708983effb2e5c935a1ef8483d9e3e
RUN curl -fsSLO &#34;$SUPERCRONIC_URL&#34; \
    && echo &#34;${SUPERCRONIC_SHA1SUM}  ${SUPERCRONIC}&#34; | sha1sum -c - \
    && chmod +x &#34;$SUPERCRONIC&#34; \
    && mv &#34;$SUPERCRONIC&#34; &#34;/usr/local/bin/${SUPERCRONIC}&#34; \
    && ln -s &#34;/usr/local/bin/${SUPERCRONIC}&#34; /usr/local/bin/supercronic
COPY my-cron /app/my-cron
WORKDIR /app

# RUN cron job
CMD [&#34;/usr/local/bin/supercronic&#34;, &#34;/app/my-cron&#34;]
重新build镜像，然后创建容器，加-v参数
$ docker image build -t my-cron .
$ docker container run -d -v cron-data:/app my-cron
43c6d0357b0893861092a752c61ab01bdfa62ea766d01d2fcb8b3ecb6c88b3de
$ docker volume ls
DRIVER    VOLUME NAME
local     cron-data
$ docker volume inspect cron-data
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-22T23:25:02+02:00&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/cron-data/_data&#34;,
        &#34;Name&#34;: &#34;cron-data&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
$ ls /var/lib/docker/volumes/cron-data/_data
my-cron
$ ls /var/lib/docker/volumes/cron-data/_data
my-cron  test.txt
环境清理
强制删除所有容器，系统清理和volume清理
$ docker rm -f $(docker container ps -aq)
$ docker system prune -f
$ docker volume prune -f
二、Bind Mount
只需要将-v的data volume换成指定路径即可。windows下的linux就可以直接挂载到磁盘，linx的可以直接查看。
例如mysql
docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=密码 \
-d mysql:5.7
-v /mydata/mysql/log:/var/log/mysql
这里就是将容器中/var/log/mysql日志，通过Bind Mount持久化到linux主机的/mydata/mysql/log目录。
多个机器之间的容器共享数据

官方参考链接 https://docs.docker.com/storage/volumes/#share-data-among-machines
Docker的volume支持多种driver。默认创建的volume driver都是local
$ docker volume inspect vscode
[
    {
        &#34;CreatedAt&#34;: &#34;2021-06-23T21:33:57Z&#34;,
        &#34;Driver&#34;: &#34;local&#34;,
        &#34;Labels&#34;: null,
        &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/vscode/_data&#34;,
        &#34;Name&#34;: &#34;vscode&#34;,
        &#34;Options&#34;: null,
        &#34;Scope&#34;: &#34;local&#34;
    }
]
这一节我们看看一个叫sshfs的driver，如何让docker使用不在同一台机器上的文件系统做volume
环境准备
准备三台Linux机器，之间可以通过SSH相互通信。



hostname
ip
ssh username
ssh password




docker-host1
192.168.200.10
vagrant
vagrant


docker-host2
192.168.200.11
vagrant
vagrant


docker-host3
192.168.200.12
vagrant
vagrant



安装plugin
在其中两台机器上安装一个plugin vieux/sshfs
[vagrant@docker-host1 ~]$ docker plugin install --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
[vagrant@docker-host2 ~]$ docker plugin install --grant-all-permissions vieux/sshfs
latest: Pulling from vieux/sshfs
Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
52d435ada6a4: Complete
Installed plugin vieux/sshfs
创建volume
[vagrant@docker-host1 ~]$ docker volume create --driver vieux/sshfs \
                          -o sshcmd=vagrant@192.168.200.12:/home/vagrant \
                          -o password=vagrant \
                          sshvolume
查看
[vagrant@docker-host1 ~]$ docker volume ls
DRIVER               VOLUME NAME
vieux/sshfs:latest   sshvolume
[vagrant@docker-host1 ~]$ docker volume inspect sshvolume
[
    {
        &#34;CreatedAt&#34;: &#34;0001-01-01T00:00:00Z&#34;,
        &#34;Driver&#34;: &#34;vieux/sshfs:latest&#34;,
        &#34;Labels&#34;: {},
        &#34;Mountpoint&#34;: &#34;/mnt/volumes/f59e848643f73d73a21b881486d55b33&#34;,
        &#34;Name&#34;: &#34;sshvolume&#34;,
        &#34;Options&#34;: {
            &#34;password&#34;: &#34;vagrant&#34;,
            &#34;sshcmd&#34;: &#34;vagrant@192.168.200.12:/home/vagrant&#34;
        },
        &#34;Scope&#34;: &#34;local&#34;
    }
]
创建容器挂载Volume
创建容器，挂载sshvolume到/app目录，然后进入容器的shell，在/app目录创建一个test.txt文件
"><meta property="og:type" content="article"><meta property="og:url" content="https://willxwu.github.io/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"><meta property="article:section" content="posts"></head><body><header class=app-header><a href=https://willxwu.github.io/><img class=app-header-avatar src=/avatar.jpg alt="John Doe"></a><h1>willxwu</h1><nav class=app-header-menu><a class=app-header-menu-item href=/about/>about</a>
-
<a class=app-header-menu-item href=/>home</a>
-
<a class=app-header-menu-item href=/link/>link</a>
-
<a class=app-header-menu-item href=/tags/>tags</a></nav><p>I write code and I take care about my privacy // Co-founder @ Owaka // Golang lover // Open source enthusiast</p><div class=app-header-social><a target=_blank href=https://github.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://twitter.com/willxwu rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title></h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jan 1, 0001</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div></div></header><div class=post-content><h1 id=docker数据存储>Docker数据存储</h1><p>默认情况下，在运行中的容器里创建的文件，被保存在一个可写的容器层：</p><ul><li>如果容器被删除了，则数据也没有了</li><li>这个可写的容器层是和特定的容器绑定的，也就是这些数据无法方便的和其它容器共享</li></ul><p>Docker主要提供了两种方式做数据的持久化</p><ul><li>Data Volume, 由Docker管理，(/var/lib/docker/volumes/ Linux), 持久化数据的最好方式</li><li>Bind Mount，由用户指定存储的数据具体mount在系统什么位置</li></ul><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202304262015423.png alt=docker-volume></p><h1 id=一data-volume>一、Data Volume</h1><h2 id=环境准备>环境准备</h2><p>准备一个Dockerfile 和一个 my-cron的文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>Dockerfile  my-cron
</span></span><span style=display:flex><span>$ more Dockerfile
</span></span><span style=display:flex><span>FROM alpine:latest
</span></span><span style=display:flex><span>RUN apk update
</span></span><span style=display:flex><span>RUN apk --no-cache add curl
</span></span><span style=display:flex><span>ENV SUPERCRONIC_URL<span style=color:#f92672>=</span>https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SUPERCRONIC<span style=color:#f92672>=</span>supercronic-linux-amd64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SUPERCRONIC_SHA1SUM<span style=color:#f92672>=</span>048b95b48b708983effb2e5c935a1ef8483d9e3e
</span></span><span style=display:flex><span>RUN curl -fsSLO <span style=color:#e6db74>&#34;</span>$SUPERCRONIC_URL<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>SUPERCRONIC_SHA1SUM<span style=color:#e6db74>}</span><span style=color:#e6db74>  </span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> | sha1sum -c - <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chmod +x <span style=color:#e6db74>&#34;</span>$SUPERCRONIC<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> mv <span style=color:#e6db74>&#34;</span>$SUPERCRONIC<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;/usr/local/bin/</span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> ln -s <span style=color:#e6db74>&#34;/usr/local/bin/</span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> /usr/local/bin/supercronic
</span></span><span style=display:flex><span>COPY my-cron /app/my-cron
</span></span><span style=display:flex><span>WORKDIR /app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>VOLUME <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;/app&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RUN cron job</span>
</span></span><span style=display:flex><span>CMD <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;/usr/local/bin/supercronic&#34;</span>, <span style=color:#e6db74>&#34;/app/my-cron&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$
</span></span><span style=display:flex><span>$ more my-cron
</span></span><span style=display:flex><span>*/1 * * * * date &gt;&gt; /app/test.txt
</span></span></code></pre></div><h2 id=构建镜像>构建镜像</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image build -t my-cron .
</span></span><span style=display:flex><span>$ docker image ls
</span></span><span style=display:flex><span>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>my-cron      latest    e9fbd9a562c9   <span style=color:#ae81ff>4</span> seconds ago   24.7MB
</span></span></code></pre></div><h2 id=创建容器不指定-v参数>创建容器(不指定-v参数)</h2><p>此时Docker会自动创建一个随机名字的volume，去存储我们在Dockerfile定义的volume <code>VOLUME ["/app"]</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker run -d my-cron
</span></span><span style=display:flex><span>9a8fa93f03c42427a498b21ac520660752122e20bcdbf939661646f71d277f8f
</span></span><span style=display:flex><span>$ docker volume ls
</span></span><span style=display:flex><span>DRIVER    VOLUME NAME
</span></span><span style=display:flex><span>local     043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
</span></span><span style=display:flex><span>$ docker volume inspect 043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2021-06-22T23:06:13+02:00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;043a196c21202c484c69f2098b6b9ec22b9a9e4e4bb8d4f55a4c3dce13c15264&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>在这个Volume的mountpoint可以发现容器创建的文件。</p><h2 id=创建容器指定-v参数>创建容器(指定-v参数)</h2><p>在创建容器的时候通过 <code>-v</code> 参数我们可以手动的指定需要创建Volume的名字，以及对应于容器内的路径，这个路径是可以任意的，不必需要在Dockerfile里通过VOLUME定义。</p><p>比如我们把上面的Dockerfile里的VOLUME删除</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>FROM alpine:latest
</span></span><span style=display:flex><span>RUN apk update
</span></span><span style=display:flex><span>RUN apk --no-cache add curl
</span></span><span style=display:flex><span>ENV SUPERCRONIC_URL<span style=color:#f92672>=</span>https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-amd64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SUPERCRONIC<span style=color:#f92672>=</span>supercronic-linux-amd64 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    SUPERCRONIC_SHA1SUM<span style=color:#f92672>=</span>048b95b48b708983effb2e5c935a1ef8483d9e3e
</span></span><span style=display:flex><span>RUN curl -fsSLO <span style=color:#e6db74>&#34;</span>$SUPERCRONIC_URL<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>SUPERCRONIC_SHA1SUM<span style=color:#e6db74>}</span><span style=color:#e6db74>  </span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> | sha1sum -c - <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chmod +x <span style=color:#e6db74>&#34;</span>$SUPERCRONIC<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> mv <span style=color:#e6db74>&#34;</span>$SUPERCRONIC<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;/usr/local/bin/</span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> ln -s <span style=color:#e6db74>&#34;/usr/local/bin/</span><span style=color:#e6db74>${</span>SUPERCRONIC<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> /usr/local/bin/supercronic
</span></span><span style=display:flex><span>COPY my-cron /app/my-cron
</span></span><span style=display:flex><span>WORKDIR /app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># RUN cron job</span>
</span></span><span style=display:flex><span>CMD <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;/usr/local/bin/supercronic&#34;</span>, <span style=color:#e6db74>&#34;/app/my-cron&#34;</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>重新build镜像，然后创建容器，加-v参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image build -t my-cron .
</span></span><span style=display:flex><span>$ docker container run -d -v cron-data:/app my-cron
</span></span><span style=display:flex><span>43c6d0357b0893861092a752c61ab01bdfa62ea766d01d2fcb8b3ecb6c88b3de
</span></span><span style=display:flex><span>$ docker volume ls
</span></span><span style=display:flex><span>DRIVER    VOLUME NAME
</span></span><span style=display:flex><span>local     cron-data
</span></span><span style=display:flex><span>$ docker volume inspect cron-data
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2021-06-22T23:25:02+02:00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/cron-data/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;cron-data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$ ls /var/lib/docker/volumes/cron-data/_data
</span></span><span style=display:flex><span>my-cron
</span></span><span style=display:flex><span>$ ls /var/lib/docker/volumes/cron-data/_data
</span></span><span style=display:flex><span>my-cron  test.txt
</span></span></code></pre></div><h2 id=环境清理>环境清理</h2><p>强制删除所有容器，系统清理和volume清理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker rm -f <span style=color:#66d9ef>$(</span>docker container ps -aq<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>$ docker system prune -f
</span></span><span style=display:flex><span>$ docker volume prune -f
</span></span></code></pre></div><h1 id=二bind-mount>二、Bind Mount</h1><p>只需要将-v的data volume换成指定路径即可。windows下的linux就可以直接挂载到磁盘，linx的可以直接查看。</p><p>例如mysql</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -p 3306:3306 --name mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-v /mydata/mysql/log:/var/log/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-v /mydata/mysql/data:/var/lib/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-v /mydata/mysql/conf:/etc/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span>密码 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-d mysql:5.7
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-v /mydata/mysql/log:/var/log/mysql
</span></span></code></pre></div><p>这里就是将容器中/var/log/mysql日志，通过Bind Mount持久化到linux主机的/mydata/mysql/log目录。</p><h1 id=多个机器之间的容器共享数据>多个机器之间的容器共享数据</h1><p><img src=https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202305102158433.png alt=multi-host-volume></p><p>官方参考链接 <a href=https://docs.docker.com/storage/volumes/#share-data-among-machines>https://docs.docker.com/storage/volumes/#share-data-among-machines</a></p><p>Docker的volume支持多种driver。默认创建的volume driver都是local</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker volume inspect vscode
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2021-06-23T21:33:57Z&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/vscode/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;vscode&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>这一节我们看看一个叫sshfs的driver，如何让docker使用不在同一台机器上的文件系统做volume</p><h2 id=环境准备-1>环境准备</h2><p>准备三台Linux机器，之间可以通过SSH相互通信。</p><table><thead><tr><th>hostname</th><th>ip</th><th>ssh username</th><th>ssh password</th></tr></thead><tbody><tr><td>docker-host1</td><td>192.168.200.10</td><td>vagrant</td><td>vagrant</td></tr><tr><td>docker-host2</td><td>192.168.200.11</td><td>vagrant</td><td>vagrant</td></tr><tr><td>docker-host3</td><td>192.168.200.12</td><td>vagrant</td><td>vagrant</td></tr></tbody></table><h2 id=安装plugin>安装plugin</h2><p>在其中两台机器上安装一个plugin <code>vieux/sshfs</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host1 ~<span style=color:#f92672>]</span>$ docker plugin install --grant-all-permissions vieux/sshfs
</span></span><span style=display:flex><span>latest: Pulling from vieux/sshfs
</span></span><span style=display:flex><span>Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
</span></span><span style=display:flex><span>52d435ada6a4: Complete
</span></span><span style=display:flex><span>Installed plugin vieux/sshfs
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host2 ~<span style=color:#f92672>]</span>$ docker plugin install --grant-all-permissions vieux/sshfs
</span></span><span style=display:flex><span>latest: Pulling from vieux/sshfs
</span></span><span style=display:flex><span>Digest: sha256:1d3c3e42c12138da5ef7873b97f7f32cf99fb6edde75fa4f0bcf9ed277855811
</span></span><span style=display:flex><span>52d435ada6a4: Complete
</span></span><span style=display:flex><span>Installed plugin vieux/sshfs
</span></span></code></pre></div><h2 id=创建volume>创建volume</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host1 ~<span style=color:#f92672>]</span>$ docker volume create --driver vieux/sshfs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>                          -o sshcmd<span style=color:#f92672>=</span>vagrant@192.168.200.12:/home/vagrant <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>                          -o password<span style=color:#f92672>=</span>vagrant <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>                          sshvolume
</span></span></code></pre></div><p>查看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host1 ~<span style=color:#f92672>]</span>$ docker volume ls
</span></span><span style=display:flex><span>DRIVER               VOLUME NAME
</span></span><span style=display:flex><span>vieux/sshfs:latest   sshvolume
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host1 ~<span style=color:#f92672>]</span>$ docker volume inspect sshvolume
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;0001-01-01T00:00:00Z&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;vieux/sshfs:latest&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: <span style=color:#f92672>{}</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/mnt/volumes/f59e848643f73d73a21b881486d55b33&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;sshvolume&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;password&#34;</span>: <span style=color:#e6db74>&#34;vagrant&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;sshcmd&#34;</span>: <span style=color:#e6db74>&#34;vagrant@192.168.200.12:/home/vagrant&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><h2 id=创建容器挂载volume>创建容器挂载Volume</h2><p>创建容器，挂载sshvolume到/app目录，然后进入容器的shell，在/app目录创建一个test.txt文件</p><div class=highlight>e></div><p>这个文件我们可以在docker-host3上看到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host3 ~<span style=color:#f92672>]</span>$ pwd
</span></span><span style=display:flex><span>/home/vagrant
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host3 ~<span style=color:#f92672>]</span>$ ls
</span></span><span style=display:flex><span>test.txt
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>vagrant@docker-host3 ~<span style=color:#f92672>]</span>$ more test.txt
</span></span><span style=display:flex><span>this is ssh volume
</span></span></code></pre></div></div><div class=post-footer></div></article></main></body></html>