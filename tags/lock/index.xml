<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lock on Come Back</title><link>https://willxwu.github.io/tags/lock/</link><description>Recent content in lock on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Thu, 05 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/lock/index.xml" rel="self" type="application/rss+xml"/><item><title>Atomic使用</title><link>https://willxwu.github.io/post/lock/atomic%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/atomic%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.atomic.AtomicInteger; /** * @description: Atomic使用 * @date: 2022/3/19 10:14 * @version: 1.0 */ public class AtomicDemo { public static void main(String[] args) { ////通过synchronized、volatile实现 // demo demo = new demo(); // for(int i=0;i&amp;lt;10;i++){ // new Thread(demo).start(); // } //使用AtomicInteger实现 demo2 demo = new demo2(); for(int i=0;i&amp;lt;10;i++){ new Thread(demo).start(); } } //通过synchronized、volatile实现 public static class demo implements Runnable{ private volatile int num=0; @Override public void run() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.</description></item><item><title>Java J.U.C之AQS</title><link>https://willxwu.github.io/post/lock/j.u.c%E4%B9%8Baqs/</link><pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/j.u.c%E4%B9%8Baqs/</guid><description>&lt;h1 id="aqs">AQS&lt;/h1>
&lt;p>J.U.C之AQS，底层由线程队列实现。AbstractQueuedSynchronizer简称AQS，JUC的核心。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204252000380.png" alt="">&lt;/p>
&lt;p>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。
利用了一个int类型表示状态。
使用方法是继承。
子类通过继承并通过实现它的方法管理其状态{acquire和release}的方法操纵状态。
可以同时实现排它锁和共享锁模式（独占、共享）。&lt;/p></description></item><item><title>Java 读写锁</title><link>https://willxwu.github.io/post/lock/%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 package com.yanxizhu; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @description: 读写锁(互斥锁) * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 15:23 * @version: 1.0 */ public class ReadWriteDemo { public static void main(String[] args) { ReadWriteTest readWriteTest = new ReadWriteTest(); new Thread(()-&amp;gt;{ readWriteTest.write((int) (Math.random()*101)); },&amp;#34;写锁&amp;#34;).start(); for(int i=1;i&amp;lt;50;i++){ new Thread(()-&amp;gt;{ readWriteTest.get(); },&amp;#34;读锁&amp;#34;).start(); } } } class ReadWriteTest{ int num =0; private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //读 public void get(){ readWriteLock.readLock().lock(); try{ System.out.println(num+&amp;#34;==&amp;#34;+Thread.currentThread().getName()); }finally { readWriteLock.</description></item><item><title>Java CountDownLatch闭锁使用</title><link>https://willxwu.github.io/post/lock/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.CountDownLatch; /** * @date: 2022/3/19 11:09 * @version: 1.0 */ public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); myCountDownlatch myCountDownlatch = new myCountDownlatch(countDownLatch); long start = System.currentTimeMillis(); for(int i=0;i&amp;lt;5;i++){ new Thread(myCountDownlatch).start(); } countDownLatch.await(); long end = System.currentTimeMillis(); System.out.println(&amp;#34;耗时：&amp;#34;+(end-start)); } public static class myCountDownlatch implements Runnable{ private CountDownLatch countDownLatch; public myCountDownlatch(CountDownLatch countDownLatch){ this.countDownLatch = countDownLatch; } @Override public void run() { synchronized (this){ try{ for(int i =0;i&amp;lt;500;i++){ if(i % 2==0){ System.</description></item><item><title>Java FutureTask用于闭锁</title><link>https://willxwu.github.io/post/lock/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /** * @description: FutureTask可用于闭锁 * @date: 2022/3/19 11:48 * @version: 1.0 */ public class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { myFutureTask myFutureTask = new myFutureTask(); FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(myFutureTask); new Thread(futureTask).start(); //必须等线程执行完，才执行下面的代码，因此FutureTask可用于闭锁 Integer integer = futureTask.get(); System.out.println(&amp;#34;integer=&amp;#34;+integer); System.out.println(&amp;#34;=======================&amp;#34;); } public static class myFutureTask implements Callable&amp;lt;Integer&amp;gt;{ @Override public Integer call() throws Exception { int i=1; for(;i&amp;lt;1000000;i++){ i++; } return i; } } }</description></item><item><title>Java ReentrantLock显示锁</title><link>https://willxwu.github.io/post/lock/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: ReentrantLock * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 12:37 * @version: 1.0 */ public class LockDemo { public static void main(String[] args) { titck titck = new titck(); new Thread(titck,&amp;#34;线程1&amp;#34;).start(); new Thread(titck,&amp;#34;线程2&amp;#34;).start(); new Thread(titck,&amp;#34;线程3&amp;#34;).start(); } public static class titck implements Runnable{ Lock lock = new ReentrantLock(); private int titck = 100; @Override public void run() { while(true){ lock.lock(); try{ if(titck&amp;gt;0){ try { Thread.</description></item><item><title>Java Synchronized Lock</title><link>https://willxwu.github.io/post/lock/reentrantlock%E4%B8%8E%E9%94%81/</link><pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/reentrantlock%E4%B8%8E%E9%94%81/</guid><description>&lt;p>锁分为Synchronized和锁Lock。&lt;/p>
&lt;h1 id="reentrantlock与锁">ReentrantLock与锁&lt;/h1>
&lt;p>ReentrantLock(可重入锁)与Synchronized(同步锁)的区别：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>可重入性：区别不大，都是通过计数器，当计数器下降为0时，锁释放。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>锁的实现：Synchronized依赖JVM，ReentrantLock基于JDK实现。(类似Synchronized是操作系统实现，ReentrantLock是敲代码实现),ReentrantLock可通过看源码明白实现，Synchronized依赖JVM就看不到实现原理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能的区别：优化之前Synchronized比ReentrantLock性能差很多，优化后Synchronized引入偏向锁、轻量级锁也就是自旋锁后，2者性能差不多了。差不多时，官方推荐Synchronized。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>功能的区别：Synchronized的使用方便简洁，隐式获取锁释放锁，ReentrantLock需要手动获取锁，释放锁，如果忘记容易出现死锁，所以最好再finally中释放锁。锁的颗粒度和灵活度很明显ReentrantLock优于Synchronized。&lt;/p>
&lt;p>ReentrantLock独有的功能：&lt;/p>
&lt;ol>
&lt;li>ReentrantLock可指定公平锁、非公平锁，而Synchronized只能时非公平锁。公平锁：先等待的先获取锁，反之亦然。&lt;/li>
&lt;li>提供了一个Condition类，可以分组唤醒需要唤醒的线程，Synchronized要么随机唤醒，要么全部唤醒。&lt;/li>
&lt;li>提供能够中断等待锁的线程的机制，lock.lockInterruptibly()，lockInterruptibly是一种自旋锁，通过循环来调用CAS来加锁，性能比较好，就是因为不会进入内核阻塞状态。&lt;/li>
&lt;/ol>
&lt;p>使用场景：必须实现上面3个功能时，就必须用了。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Java ScheduledThreadPool线程调度</title><link>https://willxwu.github.io/post/lock/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>ScheduledThreadPool线程调度 package com.yanxizhu; import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.</description></item><item><title>Java Synchronized</title><link>https://willxwu.github.io/post/lock/synchronized/</link><pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/synchronized/</guid><description>&lt;p>Atomic原子性提供了互斥访问。同一时刻只能由一个线程来操作。除了Atomic原子性，还有锁。&lt;/p>
&lt;h1 id="jdk提供的锁主要分2类">jdk提供的锁主要分2类&lt;/h1>
&lt;p>1、&lt;strong>Synchronized&lt;/strong>：一种依赖JVM去实现锁的关键字，&lt;strong>Synchronized&lt;/strong>，在这个对象作用的范围内，都是同一时刻，只能有一个线程去操作。注意是，&lt;strong>作用对象的作用范围内。&lt;/strong>&lt;/p>
&lt;p>2、另一种jdk代码层面的锁，jdk里面提供了一个Lock的接口，主要是依赖特殊的CPU指令，实现类中比较有代表性的是ReentrantLock。&lt;/p></description></item><item><title>原子性-Atomic类常见的使用</title><link>https://willxwu.github.io/post/lock/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>1、(信号量)Semaphore+(闭锁)CountDownLatch+(常用源自类)AtomicInteger package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; /** * @description: 线程安全 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/19 20:05 * @version: 1.0 */ @Slf4j @ThreadSafety public class DemoSemaphoreAndCountDownLatchAndAtomic { //用户数量 private static final int clientsTotal = 5000; //并发数量 private static final int concurrencyTotal = 200; //累加总和 private static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title>解决CAS的ABA问题</title><link>https://willxwu.github.io/post/lock/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</guid><description>CAS虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。
什么是ABA问题 比如：
线程1从主存中读取值A，另一个线程2也从主存中读取值A，此时线程2将主存值修改成了B，然后线程2又将主存值修改成了A，这时候线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功，这是不正确的。
如何解决ABA问题 通过AtomicStampedReference的compareAndSet方法进行处理，这里的compareAndSet比一般的多了一个stamp的比较。
源码如下：
public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.reference &amp;amp;&amp;amp; expectedStamp == current.stamp &amp;amp;&amp;amp; ((newReference == current.reference &amp;amp;&amp;amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 多了一个stamp的比较，stamp是每次更新来维护的。</description></item></channel></rss>