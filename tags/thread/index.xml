<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>thread on Come Back</title><link>https://willxwu.github.io/tags/thread/</link><description>Recent content in thread on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Wed, 08 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>线程安全策略</title><link>https://willxwu.github.io/post/thread/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</link><pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</guid><description>&lt;p>线程安全策略&lt;/p>
&lt;h1 id="不可变对象">不可变对象&lt;/h1>
&lt;p>&lt;strong>不可变对象需要满足的条件：&lt;/strong>
对象创建以后其状态就不能修改
对象所有域都是final类型
对象是正确创建的（在对象创建期间，this引用没有逸出）&lt;/p>
&lt;hr>
&lt;h2 id="一final关键字">&lt;strong>一、final关键字&lt;/strong>&lt;/h2>
&lt;p>final关键字：可修饰类、方法、变量。&lt;/p>
&lt;p>&lt;strong>修饰类&lt;/strong>：不能被继承&lt;/p>
&lt;p>&lt;strong>修饰方法&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>锁定方法不被继承类修改；&lt;/li>
&lt;li>效率&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>修饰变量&lt;/strong>：基本数据类型变量、引用类型变量&lt;/p></description></item><item><title>Java Executors线程池</title><link>https://willxwu.github.io/post/thread/executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>Executors线程池 package com.yanxizhu; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1.</description></item><item><title>Java CopyOnWriteArrayList</title><link>https://willxwu.github.io/post/thread/copyonwritearraylist%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86/</link><pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/copyonwritearraylist%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86/</guid><description>package com.yanxizhu; import java.util.*; /** * @description: synchronizedList遍历错误 * @date: 2022/3/19 11:30 * @version: 1.0 */ public class ConCurrentHashMapTest { public static void main(String[] args) { conCurrentDemo conCurrentDemo = new conCurrentDemo(); for(int i=0;i&amp;lt;5;i++){ new Thread(conCurrentDemo).start(); } } public static class conCurrentDemo implements Runnable{ //并发线程安全，修改报错 private static List&amp;lt;String&amp;gt; list = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;()); static { list.add(&amp;#34;apple&amp;#34;); list.add(&amp;#34;xiaomi&amp;#34;); list.add(&amp;#34;huawei&amp;#34;); } @Override public void run() { Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); list.add(&amp;#34;iphone&amp;#34;); } } } } 线程安全报错：</description></item><item><title>Atomic使用</title><link>https://willxwu.github.io/post/lock/atomic%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/atomic%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.atomic.AtomicInteger; /** * @description: Atomic使用 * @date: 2022/3/19 10:14 * @version: 1.0 */ public class AtomicDemo { public static void main(String[] args) { ////通过synchronized、volatile实现 // demo demo = new demo(); // for(int i=0;i&amp;lt;10;i++){ // new Thread(demo).start(); // } //使用AtomicInteger实现 demo2 demo = new demo2(); for(int i=0;i&amp;lt;10;i++){ new Thread(demo).start(); } } //通过synchronized、volatile实现 public static class demo implements Runnable{ private volatile int num=0; @Override public void run() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.</description></item><item><title>线程并发及CAS</title><link>https://willxwu.github.io/post/lock/%E5%B9%B6%E5%8F%91%E5%8F%8Acas/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E5%B9%B6%E5%8F%91%E5%8F%8Acas/</guid><description>&lt;h1 id="计算机架构">计算机架构&lt;/h1>
&lt;h2 id="cpu多级缓存">&lt;strong>CPU多级缓存&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204192221622.png" alt="">&lt;/p>
&lt;h2 id="为什么需要cpu-cache">&lt;strong>为什么需要CPU cache&lt;/strong>&lt;/h2>
&lt;p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu-&amp;gt;cache-&amp;gt;memory）。&lt;/p></description></item><item><title>线程唤醒</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92/</guid><description>wait、notifyAll()、await()、signalAll() 为了避免虚假唤醒问题，应该总是使用在循环中 wait、notifyAll():
package com.yanxizhu; import java.util.function.Consumer; /* * 生产者和消费者案例 */ public class TestProductorAndConsumer { public static void main(String[] args) { Clerk clerk = new Clerk(); Productor pro = new Productor(clerk); Consumers cus = new Consumers(clerk); new Thread(pro, &amp;#34;生产者 A&amp;#34;).start(); new Thread(cus, &amp;#34;消费者 B&amp;#34;).start(); new Thread(pro, &amp;#34;生产者 C&amp;#34;).start(); new Thread(cus, &amp;#34;消费者 D&amp;#34;).start(); } } //店员 class Clerk{ private int product = 0; //进货 public synchronized void get(){//循环次数：0 while(product &amp;gt;= 1){//为了避免虚假唤醒问题，应该总是使用在循环中 System.</description></item><item><title>Java J.U.C之AQS</title><link>https://willxwu.github.io/post/lock/j.u.c%E4%B9%8Baqs/</link><pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/j.u.c%E4%B9%8Baqs/</guid><description>&lt;h1 id="aqs">AQS&lt;/h1>
&lt;p>J.U.C之AQS，底层由线程队列实现。AbstractQueuedSynchronizer简称AQS，JUC的核心。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/willxwu/CDN@main/images/202204252000380.png" alt="">&lt;/p>
&lt;p>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。
利用了一个int类型表示状态。
使用方法是继承。
子类通过继承并通过实现它的方法管理其状态{acquire和release}的方法操纵状态。
可以同时实现排它锁和共享锁模式（独占、共享）。&lt;/p></description></item><item><title>Java 读写锁</title><link>https://willxwu.github.io/post/lock/%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>读写锁 package com.yanxizhu; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @description: 读写锁(互斥锁) * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 15:23 * @version: 1.0 */ public class ReadWriteDemo { public static void main(String[] args) { ReadWriteTest readWriteTest = new ReadWriteTest(); new Thread(()-&amp;gt;{ readWriteTest.write((int) (Math.random()*101)); },&amp;#34;写锁&amp;#34;).start(); for(int i=1;i&amp;lt;50;i++){ new Thread(()-&amp;gt;{ readWriteTest.get(); },&amp;#34;读锁&amp;#34;).start(); } } } class ReadWriteTest{ int num =0; private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //读 public void get(){ readWriteLock.readLock().lock(); try{ System.out.println(num+&amp;#34;==&amp;#34;+Thread.currentThread().getName()); }finally { readWriteLock.</description></item><item><title>Java CountDownLatch闭锁使用</title><link>https://willxwu.github.io/post/lock/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/countdownlatch%E9%97%AD%E9%94%81%E4%BD%BF%E7%94%A8/</guid><description>import java.util.concurrent.CountDownLatch; /** * @date: 2022/3/19 11:09 * @version: 1.0 */ public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(5); myCountDownlatch myCountDownlatch = new myCountDownlatch(countDownLatch); long start = System.currentTimeMillis(); for(int i=0;i&amp;lt;5;i++){ new Thread(myCountDownlatch).start(); } countDownLatch.await(); long end = System.currentTimeMillis(); System.out.println(&amp;#34;耗时：&amp;#34;+(end-start)); } public static class myCountDownlatch implements Runnable{ private CountDownLatch countDownLatch; public myCountDownlatch(CountDownLatch countDownLatch){ this.countDownLatch = countDownLatch; } @Override public void run() { synchronized (this){ try{ for(int i =0;i&amp;lt;500;i++){ if(i % 2==0){ System.</description></item><item><title>Java FutureTask用于闭锁</title><link>https://willxwu.github.io/post/lock/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/futuretask%E7%94%A8%E4%BA%8E%E9%97%AD%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /** * @description: FutureTask可用于闭锁 * @date: 2022/3/19 11:48 * @version: 1.0 */ public class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { myFutureTask myFutureTask = new myFutureTask(); FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(myFutureTask); new Thread(futureTask).start(); //必须等线程执行完，才执行下面的代码，因此FutureTask可用于闭锁 Integer integer = futureTask.get(); System.out.println(&amp;#34;integer=&amp;#34;+integer); System.out.println(&amp;#34;=======================&amp;#34;); } public static class myFutureTask implements Callable&amp;lt;Integer&amp;gt;{ @Override public Integer call() throws Exception { int i=1; for(;i&amp;lt;1000000;i++){ i++; } return i; } } }</description></item><item><title>Java ReentrantLock显示锁</title><link>https://willxwu.github.io/post/lock/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/reentrantlock%E6%98%BE%E7%A4%BA%E9%94%81/</guid><description>package com.yanxizhu; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: ReentrantLock * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/3/19 12:37 * @version: 1.0 */ public class LockDemo { public static void main(String[] args) { titck titck = new titck(); new Thread(titck,&amp;#34;线程1&amp;#34;).start(); new Thread(titck,&amp;#34;线程2&amp;#34;).start(); new Thread(titck,&amp;#34;线程3&amp;#34;).start(); } public static class titck implements Runnable{ Lock lock = new ReentrantLock(); private int titck = 100; @Override public void run() { while(true){ lock.lock(); try{ if(titck&amp;gt;0){ try { Thread.</description></item><item><title>Java Synchronized Lock</title><link>https://willxwu.github.io/post/lock/reentrantlock%E4%B8%8E%E9%94%81/</link><pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/reentrantlock%E4%B8%8E%E9%94%81/</guid><description>&lt;p>锁分为Synchronized和锁Lock。&lt;/p>
&lt;h1 id="reentrantlock与锁">ReentrantLock与锁&lt;/h1>
&lt;p>ReentrantLock(可重入锁)与Synchronized(同步锁)的区别：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>可重入性：区别不大，都是通过计数器，当计数器下降为0时，锁释放。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>锁的实现：Synchronized依赖JVM，ReentrantLock基于JDK实现。(类似Synchronized是操作系统实现，ReentrantLock是敲代码实现),ReentrantLock可通过看源码明白实现，Synchronized依赖JVM就看不到实现原理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能的区别：优化之前Synchronized比ReentrantLock性能差很多，优化后Synchronized引入偏向锁、轻量级锁也就是自旋锁后，2者性能差不多了。差不多时，官方推荐Synchronized。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>功能的区别：Synchronized的使用方便简洁，隐式获取锁释放锁，ReentrantLock需要手动获取锁，释放锁，如果忘记容易出现死锁，所以最好再finally中释放锁。锁的颗粒度和灵活度很明显ReentrantLock优于Synchronized。&lt;/p>
&lt;p>ReentrantLock独有的功能：&lt;/p>
&lt;ol>
&lt;li>ReentrantLock可指定公平锁、非公平锁，而Synchronized只能时非公平锁。公平锁：先等待的先获取锁，反之亦然。&lt;/li>
&lt;li>提供了一个Condition类，可以分组唤醒需要唤醒的线程，Synchronized要么随机唤醒，要么全部唤醒。&lt;/li>
&lt;li>提供能够中断等待锁的线程的机制，lock.lockInterruptibly()，lockInterruptibly是一种自旋锁，通过循环来调用CAS来加锁，性能比较好，就是因为不会进入内核阻塞状态。&lt;/li>
&lt;/ol>
&lt;p>使用场景：必须实现上面3个功能时，就必须用了。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Java ScheduledThreadPool线程调度</title><link>https://willxwu.github.io/post/lock/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/scheduledthreadpool%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>ScheduledThreadPool线程调度 package com.yanxizhu; import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.</description></item><item><title>Java Synchronized</title><link>https://willxwu.github.io/post/lock/synchronized/</link><pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/synchronized/</guid><description>&lt;p>Atomic原子性提供了互斥访问。同一时刻只能由一个线程来操作。除了Atomic原子性，还有锁。&lt;/p>
&lt;h1 id="jdk提供的锁主要分2类">jdk提供的锁主要分2类&lt;/h1>
&lt;p>1、&lt;strong>Synchronized&lt;/strong>：一种依赖JVM去实现锁的关键字，&lt;strong>Synchronized&lt;/strong>，在这个对象作用的范围内，都是同一时刻，只能有一个线程去操作。注意是，&lt;strong>作用对象的作用范围内。&lt;/strong>&lt;/p>
&lt;p>2、另一种jdk代码层面的锁，jdk里面提供了一个Lock的接口，主要是依赖特殊的CPU指令，实现类中比较有代表性的是ReentrantLock。&lt;/p></description></item><item><title>原子性-Atomic类常见的使用</title><link>https://willxwu.github.io/post/lock/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E5%8E%9F%E5%AD%90%E6%80%A7-atomic%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>1、(信号量)Semaphore+(闭锁)CountDownLatch+(常用源自类)AtomicInteger package com.yanxizhu.demo.concurrency.atomic; import com.yanxizhu.demo.concurrency.annotation.ThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; /** * @description: 线程安全 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/19 20:05 * @version: 1.0 */ @Slf4j @ThreadSafety public class DemoSemaphoreAndCountDownLatchAndAtomic { //用户数量 private static final int clientsTotal = 5000; //并发数量 private static final int concurrencyTotal = 200; //累加总和 private static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title>Java线程可见性</title><link>https://willxwu.github.io/post/thread/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/</guid><description>&lt;h1 id="可见性">可见性&lt;/h1>
&lt;p>可见性：一个线程对主内存的修改可以及时的被其它线程观察到。&lt;/p>
&lt;p>&lt;strong>导致共享变量在线程间不可见的原因：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>线程交叉执行&lt;/li>
&lt;li>重排序结合线程交叉执行&lt;/li>
&lt;li>共享变量更新后的值没有在工作内存与主存间及时更新&lt;/li>
&lt;/ol></description></item><item><title>解决CAS的ABA问题</title><link>https://willxwu.github.io/post/lock/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/lock/%E8%A7%A3%E5%86%B3cas%E7%9A%84aba%E9%97%AE%E9%A2%98/</guid><description>CAS虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。
什么是ABA问题 比如：
线程1从主存中读取值A，另一个线程2也从主存中读取值A，此时线程2将主存值修改成了B，然后线程2又将主存值修改成了A，这时候线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功，这是不正确的。
如何解决ABA问题 通过AtomicStampedReference的compareAndSet方法进行处理，这里的compareAndSet比一般的多了一个stamp的比较。
源码如下：
public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.reference &amp;amp;&amp;amp; expectedStamp == current.stamp &amp;amp;&amp;amp; ((newReference == current.reference &amp;amp;&amp;amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } 多了一个stamp的比较，stamp是每次更新来维护的。</description></item><item><title>Java线程封闭</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</link><pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</guid><description>&lt;h1 id="线程封闭">&lt;strong>线程封闭&lt;/strong>&lt;/h1>
&lt;p>当访问共享数据时，通常是要使用同步。如果要避免使用同步，就是不提供共享数据。如果仅在单线程中访问数据，就不需要同步，这种技术就叫做线程封闭，它是实现线程安全最简单的方式之一。当某个对象封闭在一个线程当中时将自动实现线程安全性，即使被封闭的对象本身它并不是安全的，实现线程主要有三种方式。&lt;/p>
&lt;p>实现线程封闭的三种方式：&lt;/p></description></item><item><title>Java线程不安全的类与写法</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%86%99%E6%B3%95/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%86%99%E6%B3%95/</guid><description>线程不安全的类与写法 线程不安全的类：类的对象可以同时被多个线程访问，比如抛出异常，逻辑错误。下面介绍一些常见的类。
StringBuilder StringBuilder线程不安全的类
代码示例
package com.yanxizhu.demo.concurrency.threadUnSafetyClass; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; /** * @description: 线程不安全的类：StringBuilder * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/24 9:01 * @version: 1.0 */ @Slf4j @UnThreadSafety public class DemoStringBuilder { //用户数量 private static final int clientsTotal = 5000; //并发数量 private static final int concurrencyTotal = 200; //累加总和 private static StringBuilder stringBuilder = new StringBuilder(); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.</description></item><item><title>Java线程安全-同步容器</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</link><pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</guid><description>&lt;h1 id="线程安全-同步容器">线程安全-同步容器&lt;/h1>
&lt;h2 id="主要包括">主要包括&lt;/h2>
&lt;p>ArrayList -&amp;gt; Vector，Stack&lt;/p>
&lt;p>HashMap-&amp;gt;HashTable（key、value不能为null）
Collections.synchronizedXXX（List、Set、Map）&lt;/p>
&lt;p>都是使用Synchronized进行修饰的，性能不是特别好。可以使用并发容器代替。&lt;/p>
&lt;p>注意：同步容器也可能是线程步安全的。&lt;/p></description></item><item><title>Java线程安全-并发容器J.U.C</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8j.u.c/</link><pubDate>Fri, 11 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8j.u.c/</guid><description>&lt;h1 id="线程安全-并发容器juc">线程安全-并发容器J.U.C&lt;/h1>
&lt;ul>
&lt;li>ArrayList -&amp;gt; CopyOnWriteArrayList&lt;/li>
&lt;li>HashSet、TreeSet -&amp;gt; CopyOnWriteArraySet 、ConcurrentSkipListSet&lt;/li>
&lt;li>HashMap、TreeMap -&amp;gt; ConcurrentHashMap 、ConcurrentSkipListMap&lt;/li>
&lt;/ul>
&lt;h1 id="copyonwritearraylist">CopyOnWriteArrayList&lt;/h1>
&lt;p>适合读多写少的场景。读的时候再原数组读不需要加锁，写的时候会copy一份会单独加锁。&lt;/p></description></item><item><title>Java线程4种创建方式</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</guid><description>&lt;h1 id="异步与线程池">异步与线程池&lt;/h1>
&lt;h1 id="1初始化线程的4种方式">1、初始化线程的4种方式&lt;/h1>
&lt;p>1）、继承Thread
2）、实现Runnable接口
3）、实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常）
4）、线程池&lt;/p>
&lt;p>方式1和方式2：主进程无法获取线程的运算结果。不适合当前场景。&lt;/p>
&lt;p>方式3：主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。可以导致服务器资源耗尽。
方式4：通过如下两种方式初始化线程池&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Executors&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">newFiexed&lt;/span> &lt;span style="color:#a6e22e">ThreadPool&lt;/span>&lt;span style="color:#f92672">(&lt;/span>3&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//或者
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> ThreadPoolExecutor&lt;span style="color:#f92672">(&lt;/span>corePoolSize&lt;span style="color:#f92672">,&lt;/span>maximumPoolSize&lt;span style="color:#f92672">,&lt;/span>keepAliveTime&lt;span style="color:#f92672">,&lt;/span>TimeUnit unit&lt;span style="color:#f92672">,&lt;/span> workQueue&lt;span style="color:#f92672">,&lt;/span>threadFactory&lt;span style="color:#f92672">,&lt;/span>handler&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java线程八锁</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/</link><pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/</guid><description>线程八锁 package com.yanxizhu; /* * 题目：判断打印的 &amp;#34;one&amp;#34; or &amp;#34;two&amp;#34; ？ * * 1. 两个普通同步方法，两个线程，标准打印， 打印? //one two * 2. 新增 Thread.sleep() 给 getOne() ,打印? //one two * 3. 新增普通方法 getThree() , 打印? //three one two * 4. 两个普通同步方法，两个 Number 对象，打印? //two one * 5. 修改 getOne() 为静态同步方法，打印? //two one * 6. 修改两个方法均为静态同步方法，一个 Number 对象? //one two * 7. 一个静态同步方法，一个非静态同步方法，两个 Number 对象? //two one * 8. 两个静态同步方法，两个 Number 对象? //one two * * 线程八锁的关键： * ①非静态方法的锁默认为 this, 静态方法的锁为 对应的 Class 实例 * ②某一个时刻内，只能有一个线程持有锁，无论几个方法。 */ public class TestThread8Monitor { public static void main(String[] args) { Number number = new Number(); Number number2 = new Number(); new Thread(new Runnable() { @Override public void run() { number.</description></item><item><title>Java线程按序交替</title><link>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E6%8C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF/</link><pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/thread/%E7%BA%BF%E7%A8%8B%E6%8C%89%E5%BA%8F%E4%BA%A4%E6%9B%BF/</guid><description>package com.yanxizhu; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @description: 线程按序交替 * @date: 2022/3/19 14:47 * @version: 1.0 */ public class PrintInfo { public static void main(String[] args) { print print = new print(); new Thread(new Runnable() { @Override public void run() { for(int i=1;i&amp;lt;5;i++){ try { print.printA(i); } catch (InterruptedException e) { e.printStackTrace(); } } } },&amp;#34;A&amp;#34;).start(); new Thread(new Runnable() { @Override public void run() { for(int i=1;i&amp;lt;5;i++){ try { print.</description></item><item><title>Java Thread</title><link>https://willxwu.github.io/post/javase/06_java-thread/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/javase/06_java-thread/</guid><description>&lt;p>进程：CPU为每个应用程序分配的独立空间，一个进程可能有多个线程。进程为线程中的摸个执行任务程序，多个进程之间可以进行共享数据。而JAVA的线程则是由JVM进程分配的，main方法所在线程，则成为主线程。&lt;/p>
&lt;h3 id="线程状态">〇、线程状态&lt;/h3>
&lt;p>正常情况线程执行步骤：新建-》运行-》死亡&lt;/p>
&lt;p>当CPU资源不够时，CUP分配给各个线程的资源可能不同(貌似有点像是线程在抢资源，实际是CPU分配资源给每个线程)。
因此就会出现线程的阻塞、休眠、等待3个状态。其中阻塞状态，当cpu资源够时，阻塞状态的线程可能恢复到运行状态，而休眠、等待的线程也可能进入运行状态。休眠、等待状态可能转换成阻塞状态，但是阻塞状态不会变成休眠、等待状态。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/willxwu/cdn@1.1.7/images/uploads/2020/javase/upload_4b906c6a19ca62fceb56203e229f6ee2.png" alt="线程状态图.png">&lt;/p>
&lt;h3 id="一多线程的实现">一、多线程的实现&lt;/h3>
&lt;h5 id="0线程常用方法">0、线程常用方法&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> learn.javase.threads&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 继承Thread创建线程，设置线程名称、获取线程名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Jole
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadDemo01&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyThreadsDemo mt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MyThreadsDemo&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mt&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setName&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Hi&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mt&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">start&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取当前线程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Thread t &lt;span style="color:#f92672">=&lt;/span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">currentThread&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>t&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>线程实现方式主测试类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> learn.javase.threads&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyThreadsDemo&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Thread&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">MyThreadsDemo&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Google&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">&amp;lt;&lt;/span>5&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sleep&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#66d9ef">catch&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Exception e&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>e&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getMessage&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>