<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Come Back</title><link>https://willxwu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Mon, 11 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-多线程Future设计模式原理,自定义实现一个Future程序。</title><link>https://willxwu.github.io/post/java8/18_java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/18_java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</guid><description>JAVA8-多线程Future设计模式原理,自定义实现一个Future程序。 自定义实现Future，理解设计模式原理。
Future模式实现 自定义代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 自定义模拟future，理解Future的使用。 */ public class FutureInAction { public static void main(String[] args) throws InterruptedException { Funture&amp;lt;String&amp;gt; funture = invoke(() -&amp;gt; { try { //模拟操作计算很长时间 Thread.sleep(10000); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (Exception e) { e.printStackTrace(); return &amp;#34;Error&amp;#34;; } }); //操作计算很长时间，还没操作计算完成，只返回了future，虽然此时返回值为null，但是可以接着执行官其它操作,不会阻塞后续操作。 System.out.println(funture.get()); System.out.println(funture.get()); System.out.println(funture.get()); //知道操作计算完成后，将值返回 while (!funture.isDone()) { Thread.sleep(10); } System.out.println(funture.get()); } private static &amp;lt;T&amp;gt; Funture&amp;lt;T&amp;gt; invoke(Callable&amp;lt;T&amp;gt; callable) { AtomicReference&amp;lt;T&amp;gt; result = new AtomicReference&amp;lt;&amp;gt;(); AtomicBoolean finished = new AtomicBoolean(false); Thread t = new Thread(() -&amp;gt; { T value = callable.</description></item><item><title>安全发布,详解单例模式</title><link>https://willxwu.github.io/post/design-patterns/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E8%AF%A6%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/design-patterns/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E8%AF%A6%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>安全发布对象 什么是安全发布？
发布对象：使一个对象能够被当前范围之外的代码所使用
代码示例
package com.yanxizhu.demo.concurrency.unSafePublish; import com.yanxizhu.demo.concurrency.annotation.UnThreadSafety; import lombok.extern.slf4j.Slf4j; import java.util.Arrays; /** * @description: 安全发布,这个例子是线程不安全的 * @author: &amp;lt;a href=&amp;#34;mailto:batis@foxmail.com&amp;#34;&amp;gt;清风&amp;lt;/a&amp;gt; * @date: 2022/4/21 21:45 * @version: 1.0 */ @Slf4j @UnThreadSafety public class UnSafePublish { private String[] states = {&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}; public String[] getStates() { return states; } public static void main(String[] args) { UnSafePublish unSafePublish = new UnSafePublish(); log.info(&amp;#34;{}&amp;#34;, Arrays.toString(unSafePublish.getStates())); unSafePublish.getStates()[0] = &amp;#34;d&amp;#34;; log.info(&amp;#34;{}&amp;#34;, Arrays.toString(unSafePublish.getStates())); } } 运行结果：
21:48:00.633 [main] INFO com.</description></item></channel></rss>