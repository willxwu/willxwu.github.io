<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>事务 on Come Back</title><link>https://willxwu.github.io/tags/%E4%BA%8B%E5%8A%A1/</link><description>Recent content in 事务 on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Sat, 14 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/%E4%BA%8B%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL优化</title><link>https://willxwu.github.io/post/mysql/mysql%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/mysql/mysql%E4%BC%98%E5%8C%96/</guid><description>&lt;h1 id="索引">索引&lt;/h1>
&lt;h2 id="一全表扫描">&lt;strong>一、全表扫描&lt;/strong>&lt;/h2>
&lt;p>没有使用索引的时候，数据的查询需要进行多次IO读写，这样的性能较差——全表扫描的过程。&lt;/p>
&lt;h2 id="二索引">&lt;strong>二、索引&lt;/strong>&lt;/h2>
&lt;p>为数据库的某个字段创建索引，相当是为这个字段的内容创建了一个目录。通过这个目录可以快速的实现数据的定位，也就是通过索引能够快速的找到某条数据所在磁盘的位置。&lt;/p>
&lt;h2 id="三索引存放位置">&lt;strong>三、索引存放位置&lt;/strong>&lt;/h2></description></item><item><title>Springboot同一Server类方法调用事务解决方案</title><link>https://willxwu.github.io/post/spring/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/spring/springboot%E5%90%8C%E4%B8%80server%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>Springboot同一Server类方法调用事务解决方案 1、引入springboot-aop start &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 主要是使用里面的动态代理
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.7&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 2、开启动态代理 @EnableAspectJAutoProxy(exposeProxy = true) @EnableDiscoveryClient @SpringBootApplication public class FamilyBookingApplication { public static void main(String[] args) { SpringApplication.run(FamilyBookingApplication.class, args); } } @EnableAspectJAutoProxy(exposeProxy = true)：
开启aspectj动态代理功能。以后所有的动态代理都是aspectj对象暴露代理对象。
3、本类互调用代理对象调用 @Service(&amp;#34;userService&amp;#34;) public class UserServiceImpl implements userService { @Transactional public void a(){ UserService userService = (UserService)AopContext.currentProxy(); userService.b(); userService.c(); } @Transactional public void b(){ } @Transactional public void c(){ } }</description></item></channel></rss>