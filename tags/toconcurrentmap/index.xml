<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>toConcurrentMap on Come Back</title><link>https://willxwu.github.io/tags/toconcurrentmap/</link><description>Recent content in toConcurrentMap on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Thu, 14 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/toconcurrentmap/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-实现一个异步基于事件回调的Future程序</title><link>https://willxwu.github.io/post/java8/20_java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/</link><pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/20_java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/</guid><description>JAVA8-实现一个异步基于事件回调的Future程序 前面2个例子（JAVA8-多线程Future设计模式原理,自定义实现一个Future程序、JAVA8-JDK自带Future,Callable,ExecutorService）+该例子，是为了学习CompletableFuture，理解其原理。
自定义Future程序代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 实现一个异步基于事件回调的Future程序 */ public class FutureInAction3 { public static void main(String[] args) { Future&amp;lt;String&amp;gt; future = invoke(() -&amp;gt; { try { Thread.sleep(10000L); return &amp;#34;I&amp;#39;m finished.&amp;#34;; } catch (InterruptedException e) { return &amp;#34;I&amp;#39;m Error.&amp;#34;; } }); //注册一个事件 future.setCompletable(new Completable&amp;lt;String&amp;gt;() { @Override public void completable(String s) { System.out.println(s); } @Override public void excetion(Throwable cause) { System.out.println(&amp;#34;Error&amp;#34;); cause.printStackTrace(); } }); //下面就可以执行其它逻辑了。。。 System.out.println(&amp;#34;。。。。。。。。。&amp;#34;); System.out.println(future.get()); System.</description></item><item><title>JAVA8-JDK自带Future,Callable,ExecutorService</title><link>https://willxwu.github.io/post/java8/19_java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/19_java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</guid><description>JAVA8-JDK自带Future,Callable,ExecutorService 代码示例：
package com.example.study.java8.funture; import java.util.List; import java.util.concurrent.*; /** * 和自定义Future中block一样会卡住 */ public class FutureInAction2 { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { //创建一个单线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); //返回一个future，里面的操作可能还没完成，但不影响后续的操作。 Future&amp;lt;String&amp;gt; future = executorService.submit(() -&amp;gt; { try { Thread.sleep(10000L); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (InterruptedException e) { return &amp;#34;I&amp;#39;m error&amp;#34;; } }); //没有结果会抛出，中断异常 String value = future.get(); System.out.println(value); //关闭进程 executorService.shutdown(); //shutdownNow关闭进程，但是会返回有那些进程还没有执行完。 List&amp;lt;Runnable&amp;gt; runnables = executorService.shutdownNow(); } } 输出结果：</description></item><item><title>JAVA8-多线程Future设计模式原理,自定义实现一个Future程序。</title><link>https://willxwu.github.io/post/java8/18_java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/18_java8-%E5%A4%9A%E7%BA%BF%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfuture%E7%A8%8B%E5%BA%8F/</guid><description>JAVA8-多线程Future设计模式原理,自定义实现一个Future程序。 自定义实现Future，理解设计模式原理。
Future模式实现 自定义代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 自定义模拟future，理解Future的使用。 */ public class FutureInAction { public static void main(String[] args) throws InterruptedException { Funture&amp;lt;String&amp;gt; funture = invoke(() -&amp;gt; { try { //模拟操作计算很长时间 Thread.sleep(10000); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (Exception e) { e.printStackTrace(); return &amp;#34;Error&amp;#34;; } }); //操作计算很长时间，还没操作计算完成，只返回了future，虽然此时返回值为null，但是可以接着执行官其它操作,不会阻塞后续操作。 System.out.println(funture.get()); System.out.println(funture.get()); System.out.println(funture.get()); //知道操作计算完成后，将值返回 while (!funture.isDone()) { Thread.sleep(10); } System.out.println(funture.get()); } private static &amp;lt;T&amp;gt; Funture&amp;lt;T&amp;gt; invoke(Callable&amp;lt;T&amp;gt; callable) { AtomicReference&amp;lt;T&amp;gt; result = new AtomicReference&amp;lt;&amp;gt;(); AtomicBoolean finished = new AtomicBoolean(false); Thread t = new Thread(() -&amp;gt; { T value = callable.</description></item><item><title>JAVA8-default、static</title><link>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</guid><description>JAVA8-default、static default方法 1.8之前出现的问题:开发了一个接口，后面实现该接口的实现类，都需要实现接口中定义的方法。1.8之后接口中使用default定义新增的方法后，其实现类可以不用实现该方法。
例如Collection接口中新增了对stream的操作方法：stream()
public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; { default Stream&amp;lt;E&amp;gt; stream() { return StreamSupport.stream(spliterator(), false); } } 其实现类就可以不用再实现stream()方法，这样对于版本兼容就比较好了。
static 定义的方法 可以通过接口直接调用该方法，例如：
public interface Function&amp;lt;T, R&amp;gt; { static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() { return t -&amp;gt; t; } } 注意：接口中有default定义的方法实现了，但并不是抽象类。
接口：可以被多个类实现。
抽象类：继承了一个抽象类，就不能再继承另一个抽象类，因为类是单继承。
实列 自己用default实现一个接口
package com.example.study.java8.method; /** * default使用 */ public class DefaultAction { public static void main(String[] args) { A a = ()-&amp;gt;10; System.out.println(a.size()); System.out.println(a.isEmpty()); } public interface A{ int size(); //判断容器是否为空 default boolean isEmpty(){ return size()==0; } } } 输出结果：</description></item><item><title>JVA8-自定义Spliterator</title><link>https://willxwu.github.io/post/java8/16_jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/16_jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</guid><description>JVA8-自定义Spliterator 需求说明：将一段话按换行符分割成多个执行，并输出。
package com.example.study.java8.forkjoin; import java.util.Objects; import java.util.Spliterator; import java.util.function.Consumer; import java.util.stream.Stream; import java.util.stream.StreamSupport; /** * 自定义Spliterator * 实列：将一段话按换行符分割成多个执行，并输出。 */ public class SpliteratorInAction { //需要处理的数据 private static String text = &amp;#34;The tryAdvance method feeds the Consumer with the Character in the String at the current index\n&amp;#34; + &amp;#34;position and increments this position. The Consumer passed as argument is an internal Java class\n&amp;#34; + &amp;#34;forwarding the consumed Character to the set of functions that have to be applied to it while\n&amp;#34; + &amp;#34;traversing the stream, which in this case is only a reducing function, namely, the accumulate method\n&amp;#34; + &amp;#34;of the WordCounter class.</description></item><item><title>JAVA8-Fork Join</title><link>https://willxwu.github.io/post/java8/15_java8-fork-join/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/15_java8-fork-join/</guid><description>JAVA8-Fork Join Fork：将一个任务拆分成多个线程执行。 Join：将每个现场结果join，最后得到结果。
范例：求数组总和 前置数据：
public static int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 1、原始实现方式 public static int calc() { int result = 0; for (int i = 0; i &amp;lt; data.length; i++) { result += data[i]; } return result; } 原始实现方式调用：
System.out.println(&amp;#34;result=&amp;gt; &amp;#34; + calc()); 2、RecursiveTask实现 RecursiveTask有返回值。
package com.example.study.java8.forkjoin; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; import java.util.concurrent.RecursiveTask; @Data @AllArgsConstructor @NoArgsConstructor @ToString public class AccumulatorRecursiveTask extends RecursiveTask&amp;lt;Integer&amp;gt; { private int start; private int end; private int[] data; private int LIMIT=3; public AccumulatorRecursiveTask(int start, int end, int[] data) { this.</description></item><item><title>JAVA8 Stream parallel 并行执行</title><link>https://willxwu.github.io/post/java8/14_java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</link><pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/14_java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</guid><description>Stream parallel 并行执行 范例：求1~100000000的和，执行10次，看时间效率。 代码 package com.example.study.java8.collector; import java.util.function.Function; import java.util.stream.LongStream; import java.util.stream.Stream; /** * Stream parallel并行执行 * 实列：求10次，1~100000000的和，看时间效率。 */ public class ParallelProcessing { public static void main(String[] args) { //获取电脑CPU核数 System.out.println(&amp;#34;当前电脑CPU核数= &amp;#34; + Runtime.getRuntime().availableProcessors()); System.out.println(&amp;#34;The best process time(normalAdd)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::normalAdd, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream1)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream1, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream2)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream2, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream3)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream3, 100_000_000) + &amp;#34; MS&amp;#34;); System.</description></item><item><title>JAVA8-Collector interface源码分析</title><link>https://willxwu.github.io/post/java8/13_collector-interface%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/13_collector-interface%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>Collector interface源码分析 源码 public interface Collector&amp;lt;T, A, R&amp;gt; { Supplier&amp;lt;A&amp;gt; supplier(); BiConsumer&amp;lt;A, T&amp;gt; accumulator(); Function&amp;lt;A, R&amp;gt; finisher(); BinaryOperator&amp;lt;A&amp;gt; combiner(); Set&amp;lt;Characteristics&amp;gt; characteristics(); } 说明： 1.T is the generic type of the items in the stream to be collected. 2.A is the type of the accumulator, the object on which the partial result will be accumulated during the collection process. 3.R is the type of the object (typically, but not always, the collection) resulting from the collect operation.</description></item><item><title>JAVA8-Collectors API summingDouble、summingInt、testSummingLong、toCollection、toConcurrentMap、toList、toSet、toMap</title><link>https://willxwu.github.io/post/java8/12_java8-collectors-api-summingdoublesumminginttestsumminglongtocollectiontoconcurrentmaptolisttosettomap/</link><pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/12_java8-collectors-api-summingdoublesumminginttestsumminglongtocollectiontoconcurrentmaptolisttosettomap/</guid><description>JAVA8-Collectors API:summingDouble、summingInt、testSummingLong、toCollection、toConcurrentMap、toList、toSet、toMap 前置数据
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、summingDouble public static void testAveragingDouble(){ System.out.println(&amp;#34;testAveragingDouble&amp;#34;); //用reduce聚合求和 Optional.ofNullable(menu.stream().map(Dish::getCalories).reduce(Integer::sum)).get().ifPresent(System.out::println); //用collectors averagingDouble求平均值 Optional.ofNullable(menu.stream().collect(averagingDouble(Dish::getCalories))).ifPresent(System.out::println); } 输出结果：</description></item></channel></rss>