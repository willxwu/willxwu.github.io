<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基本用法 on Come Back</title><link>https://willxwu.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link><description>Recent content in 基本用法 on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Wed, 27 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-Stream基本使用及特点</title><link>https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>Stream基本使用及特点 Stream说明 Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错。
1、可连续操作：
filter, map, and limit can be connected together to form a pipeline. 2、操作中断
collect causes the pipeline to be executed and closes it. 使用范例： package com.example.study.java8.streams; import java.util.*; import java.util.stream.Stream; import static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; /** * Stream使用 * Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错 * You can see two groups of operations: * 1、可连续操作 *  filter, map, and limit can be connected together to form a pipeline. * 2、操作中断 *  collect causes the pipeline to be executed and closes it.</description></item><item><title>JAVA8-CompletableFuture基本用法</title><link>https://willxwu.github.io/post/java8/26_completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/26_completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid><description>JAVA8-CompletableFuture基本用法 针对&amp;lt;实现一个异步基于事件回调的Future程序&amp;gt; 用CompletableFuture进行改进。
代码示例：
package com.example.study.java8.completableFutures; import java.util.Optional; import java.util.Random; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; /** * CompletableFuture 基本用法 */ public class CompletableFutureInAction1 { private final static Random RANDOM = new Random(System.currentTimeMillis()); public static void main(String[] args) throws ExecutionException, InterruptedException { //实际开发中，一般不直接new，而是使用工厂创建 // CompletableFuture&amp;lt;Void&amp;gt; voidCompletableFuture = CompletableFuture.runAsync(); CompletableFuture&amp;lt;Double&amp;gt; completableFuture = new CompletableFuture&amp;lt;&amp;gt;(); new Thread(()-&amp;gt;{ double value = get(); completableFuture.complete(value); }).start(); //不会阻塞程序执行 System.out.println(&amp;#34;===========no====block====..&amp;#34;); //1、后面获取程序执行结果 // Optional.ofNullable(completableFuture.get()).ifPresent(System.out::println); //2、执行完后，通过回调自动返回结果 completableFuture.whenComplete((v,t)-&amp;gt;{ Optional.ofNullable(v).ifPresent(System.out::println); Optional.ofNullable(t).ifPresent(x-&amp;gt;x.printStackTrace()); }); } private static double get(){ try { Thread.</description></item></channel></rss>