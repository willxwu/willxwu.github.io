<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ExecutorService, on Come Back</title><link>https://willxwu.github.io/tags/executorservice/</link><description>Recent content in ExecutorService, on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Wed, 13 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/executorservice/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-JDK自带Future,Callable,ExecutorService</title><link>https://willxwu.github.io/post/java8/19_java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</link><pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/19_java8-jdk%E6%8F%90%E4%BE%9B%E7%9A%84future/</guid><description>JAVA8-JDK自带Future,Callable,ExecutorService 代码示例：
package com.example.study.java8.funture; import java.util.List; import java.util.concurrent.*; /** * 和自定义Future中block一样会卡住 */ public class FutureInAction2 { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { //创建一个单线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); //返回一个future，里面的操作可能还没完成，但不影响后续的操作。 Future&amp;lt;String&amp;gt; future = executorService.submit(() -&amp;gt; { try { Thread.sleep(10000L); return &amp;#34;I&amp;#39;m finished&amp;#34;; } catch (InterruptedException e) { return &amp;#34;I&amp;#39;m error&amp;#34;; } }); //没有结果会抛出，中断异常 String value = future.get(); System.out.println(value); //关闭进程 executorService.shutdown(); //shutdownNow关闭进程，但是会返回有那些进程还没有执行完。 List&amp;lt;Runnable&amp;gt; runnables = executorService.shutdownNow(); } } 输出结果：</description></item></channel></rss>