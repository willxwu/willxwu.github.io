<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java8 on Come Back</title><link>https://willxwu.github.io/tags/java8/</link><description>Recent content in java8 on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Sun, 10 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/java8/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-default、static</title><link>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</guid><description>JAVA8-default、static default方法 1.8之前出现的问题:开发了一个接口，后面实现该接口的实现类，都需要实现接口中定义的方法。1.8之后接口中使用default定义新增的方法后，其实现类可以不用实现该方法。
例如Collection接口中新增了对stream的操作方法：stream()
public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; { default Stream&amp;lt;E&amp;gt; stream() { return StreamSupport.stream(spliterator(), false); } } 其实现类就可以不用再实现stream()方法，这样对于版本兼容就比较好了。
static 定义的方法 可以通过接口直接调用该方法，例如：
public interface Function&amp;lt;T, R&amp;gt; { static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() { return t -&amp;gt; t; } } 注意：接口中有default定义的方法实现了，但并不是抽象类。
接口：可以被多个类实现。
抽象类：继承了一个抽象类，就不能再继承另一个抽象类，因为类是单继承。
实列 自己用default实现一个接口
package com.example.study.java8.method; /** * default使用 */ public class DefaultAction { public static void main(String[] args) { A a = ()-&amp;gt;10; System.out.println(a.size()); System.out.println(a.isEmpty()); } public interface A{ int size(); //判断容器是否为空 default boolean isEmpty(){ return size()==0; } } } 输出结果：</description></item><item><title>JVA8-自定义Spliterator</title><link>https://willxwu.github.io/post/java8/16_jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/16_jva8-%E8%87%AA%E5%AE%9A%E4%B9%89spliterator/</guid><description>JVA8-自定义Spliterator 需求说明：将一段话按换行符分割成多个执行，并输出。
package com.example.study.java8.forkjoin; import java.util.Objects; import java.util.Spliterator; import java.util.function.Consumer; import java.util.stream.Stream; import java.util.stream.StreamSupport; /** * 自定义Spliterator * 实列：将一段话按换行符分割成多个执行，并输出。 */ public class SpliteratorInAction { //需要处理的数据 private static String text = &amp;#34;The tryAdvance method feeds the Consumer with the Character in the String at the current index\n&amp;#34; + &amp;#34;position and increments this position. The Consumer passed as argument is an internal Java class\n&amp;#34; + &amp;#34;forwarding the consumed Character to the set of functions that have to be applied to it while\n&amp;#34; + &amp;#34;traversing the stream, which in this case is only a reducing function, namely, the accumulate method\n&amp;#34; + &amp;#34;of the WordCounter class.</description></item><item><title>JAVA8-Fork Join</title><link>https://willxwu.github.io/post/java8/15_java8-fork-join/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/15_java8-fork-join/</guid><description>JAVA8-Fork Join Fork：将一个任务拆分成多个线程执行。 Join：将每个现场结果join，最后得到结果。
范例：求数组总和 前置数据：
public static int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 1、原始实现方式 public static int calc() { int result = 0; for (int i = 0; i &amp;lt; data.length; i++) { result += data[i]; } return result; } 原始实现方式调用：
System.out.println(&amp;#34;result=&amp;gt; &amp;#34; + calc()); 2、RecursiveTask实现 RecursiveTask有返回值。
package com.example.study.java8.forkjoin; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; import java.util.concurrent.RecursiveTask; @Data @AllArgsConstructor @NoArgsConstructor @ToString public class AccumulatorRecursiveTask extends RecursiveTask&amp;lt;Integer&amp;gt; { private int start; private int end; private int[] data; private int LIMIT=3; public AccumulatorRecursiveTask(int start, int end, int[] data) { this.</description></item><item><title>JAVA8-Collectors API averaging、collectingAndThen、counting、groupingBy</title><link>https://willxwu.github.io/post/java8/10_java8-collectors-api-averagingcollectingandthencountinggroupingby/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/10_java8-collectors-api-averagingcollectingandthencountinggroupingby/</guid><description>JAVA8-Collectors API:averaging、collectingAndThen、counting、groupingBy 前置数据
public static final List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&amp;#34;pork&amp;#34;, false, 800, Dish.Type.MEAT), new Dish(&amp;#34;beef&amp;#34;, false, 700, Dish.Type.MEAT), new Dish(&amp;#34;chicken&amp;#34;, false, 400, Dish.Type.MEAT), new Dish(&amp;#34;french fries&amp;#34;, true, 530, Dish.Type.OTHER), new Dish(&amp;#34;rice&amp;#34;, true, 350, Dish.Type.OTHER), new Dish(&amp;#34;season fruit&amp;#34;, true, 120, Dish.Type.OTHER), new Dish(&amp;#34;pizza&amp;#34;, true, 550, Dish.Type.OTHER), new Dish(&amp;#34;prawns&amp;#34;, false, 300, Dish.Type.FISH), new Dish(&amp;#34;salmon&amp;#34;, false, 450, Dish.Type.FISH)); 范例：
1、averagingDouble 求平均值 public static void testAveragingDouble(){ System.out.println(&amp;#34;testAveragingDouble&amp;#34;); //用reduce聚合求和 Optional.ofNullable(menu.stream().map(Dish::getCalories).reduce(Integer::sum)).get().ifPresent(System.out::println); //用collectors averagingDouble求平均值 Optional.ofNullable(menu.stream().collect(averagingDouble(Dish::getCalories))).ifPresent(System.out::println); } 输出结果：</description></item><item><title>JAVA8-Stream数据类型：mapToInt、mapToLong、mapToDouble</title><link>https://willxwu.github.io/post/java8/07_java8-stream-%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/07_java8-stream-%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F/</guid><description>Stream数据类型 1、mapToInt、mapToLong、mapToDouble ## 可以将包装类拆箱成基本数据类型，节约内存空间 ## 范例：
方式一：reduce实现
//方式一：reduce实现 List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); list.stream().reduce(Integer::sum).ifPresent(System.out::println); 方式二：mapToInt
//方式二：mapToInt list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); IntStream mapToInt = list.stream().mapToInt(i -&amp;gt; i.intValue()); int sum = mapToInt.sum(); System.out.println(sum); 方式三：mapToInt后用reduce实现
//方式三：mapToInt后用reduce实现 list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); IntStream intStream = list.stream().mapToInt(i -&amp;gt; i.intValue()); int reduce = list.</description></item><item><title>JAVA8-Stream API：filter、distinct、skip、limit</title><link>https://willxwu.github.io/post/java8/06_java8-stream-apifilterdistinctskiplimit/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/06_java8-stream-apifilterdistinctskiplimit/</guid><description>二、Stream API：filter、distinct、skip、limit 被操作数据
List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,6,5,4,3,2,1); 1、filter 过滤 范例：
//filter 过滤 List&amp;lt;Integer&amp;gt; filterResult = list.stream().filter(i -&amp;gt; i % 2 == 0).collect(toList()); filterResult.stream().forEach(System.out::println); 2、distinct 去重 范例：
//distinct 去重 List&amp;lt;Integer&amp;gt; distinctResult = list.stream().distinct().collect(toList()); distinctResult.stream().forEach(System.out::println); 3、skip 截断 范例：
//skip 截断(跳过前面几个,超过长度，直接返回空) List&amp;lt;Integer&amp;gt; skipResult = list.stream().skip(5).collect(toList()); skipResult.stream().forEach(System.out::println); 4、limit 查询几条 范例：
//limit 查询几条 List&amp;lt;Integer&amp;gt; limitResult = list.stream().limit(3).collect(toList()); limitResult.stream().forEach(System.out::println); 二、Stream API：Map 1、map 数据处理 被操作数据
List&amp;lt;Integer&amp;gt; list = Arrays.</description></item><item><title>JAVA8-如何创建Stream</title><link>https://willxwu.github.io/post/java8/05_java8-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAstream/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/05_java8-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAstream/</guid><description>创建Stream 创建Stream方式： 创建Stream的方式 1、通过Collection 2、通过values 3、通过Arrays 4、通过file 5、通过iterate创建,无限的创建 6、通过Generate创建 7、自定义Supplier，创建Stream 使用范例 1、Collection创建，输出值顺序与之前放入值顺序一致。 范例：
/** * 通过Collection创建Stream，数据顺序和放入顺序一致 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByCollection(){ List&amp;lt;String&amp;gt; list = Arrays.asList(new String(&amp;#34;Hello&amp;#34;), new String(&amp;#34;world&amp;#34;), new String(&amp;#34;please&amp;#34;)); return list.stream(); } 2、values创建,输出值顺序与之前放入值顺序一致。 范例：
/** * 通过values创建Stream，顺序一直 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByValues(){ return Stream.of(&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;,&amp;#34;please&amp;#34;); } 3、Arrays创建,输出值顺序与之前放入值顺序一致。 范例：
/** * 3、通过Arrays创建，顺序一致 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByArrays(){ return Arrays.stream(new String[]{&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;,&amp;#34;please&amp;#34;}); } 4、File创建 范例：
/** * 4、通过file创建 * @return */ public static Stream&amp;lt;String&amp;gt; createStreamByFile(){ Path path = Paths.</description></item><item><title>JAVA8-Stream源码</title><link>https://willxwu.github.io/post/java8/04_java8-stream%E6%BA%90%E7%A0%81/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/04_java8-stream%E6%BA%90%E7%A0%81/</guid><description>Stream基本使用及特点 Stream说明 Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错。
1、可连续操作：
filter, map, and limit can be connected together to form a pipeline. 2、操作中断
collect causes the pipeline to be executed and closes it. 使用范例： package com.example.study.java8.streams; import java.util.*; import java.util.stream.Stream; import static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; /** * Stream使用 * Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错 * You can see two groups of operations: * 1、可连续操作 *  filter, map, and limit can be connected together to form a pipeline. * 2、操作中断 *  collect causes the pipeline to be executed and closes it.</description></item><item><title>JAVA8方法推导</title><link>https://willxwu.github.io/post/java8/03_java8%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/03_java8%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC/</guid><description>Lambda方法推导详细解析 什么情况下可以进行方法推导? 类的方法（静态方法）
对象的方法
构造方法
自定义函数式接口
范例： package com.example.study.java8.InterfaceFunction; import java.util.Arrays; import java.util.Comparator; import java.util.List; import java.util.function.BiFunction; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Supplier; /** * 方法推导 * 什么情况下可以进行方法推导： * 1、类的方法（静态方法） * 2、对象的方法 * 3、构造方法 */ public class MethodReferenceUsageDemoOne { public static void main(String[] args) { //方法推导，范例一：类的方法 //原始写法 Consumer&amp;lt;String&amp;gt; consumer = s-&amp;gt; System.out.println(s); genericityConsumer(consumer, &amp;#34;hello&amp;#34;); //1、进化一 genericityConsumer(s-&amp;gt;System.out.println(s), &amp;#34;world&amp;#34;); //2、进化二 genericityConsumer(System.out::println, &amp;#34;nice&amp;#34;); System.out.println(&amp;#34;===========================&amp;#34;); //方法推导，范例二：类的方法 List&amp;lt;Apple&amp;gt; list = Arrays.asList(new Apple(&amp;#34;red&amp;#34;, 10) , new Apple(&amp;#34;red&amp;#34;, 60) , new Apple(&amp;#34;blue&amp;#34;, 40) , new Apple(&amp;#34;black&amp;#34;, 30) , new Apple(&amp;#34;green&amp;#34;, 80) , new Apple(&amp;#34;blue&amp;#34;, 90) , new Apple(&amp;#34;green&amp;#34;, 60) , new Apple(&amp;#34;green&amp;#34;, 50) , new Apple(&amp;#34;red&amp;#34;, 20)); System.</description></item><item><title>Java8-functionInterface</title><link>https://willxwu.github.io/post/java8/02_java8-functioninterface/</link><pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/02_java8-functioninterface/</guid><description>&lt;h1 id="lambda表达式用法">Lambda表达式用法&lt;/h1>
&lt;h6 id="用户范例">用户范例&lt;/h6>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.example.study.java8.InterfaceFunction&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * lambda表达式用法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LambdaUsage&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runnable runnable1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">()-&amp;gt;&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runnable runnable2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Runnable&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process&lt;span style="color:#f92672">(&lt;/span>runnable1&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process&lt;span style="color:#f92672">(&lt;/span>runnable2&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process&lt;span style="color:#f92672">(()-&amp;gt;&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">process&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Runnable runnable&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runnable&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java8-Lambda语法</title><link>https://willxwu.github.io/post/java8/01_java8-lambda%E8%AF%AD%E6%B3%95/</link><pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/01_java8-lambda%E8%AF%AD%E6%B3%95/</guid><description>&lt;h1 id="lambda表达式">Lambda表达式&lt;/h1>
&lt;h2 id="一lambda语法">一、lambda语法&lt;/h2>
&lt;p>参数列表 lambda body部分&lt;/p>
&lt;p>(o1,o2)-&amp;gt;o1.getWeight().compareTo(o2.getWeight());&lt;/p>
&lt;h2 id="二合法lamdba表达式">二、 合法lamdba表达式&lt;/h2>
&lt;p>1、s -&amp;gt; s.length(); 或者 (String s) -&amp;gt; s.length();&lt;/p>
&lt;p>2、apple -&amp;gt; apple.getColor().equals(&amp;ldquo;great&amp;rdquo;); 或者 (Apple apple) -&amp;gt; apple.getColor().equals(&amp;ldquo;great&amp;rdquo;);&lt;/p>
&lt;p>3、(int x, int y) -&amp;gt; {&lt;/p>
&lt;p>System.out.println(x);&lt;/p>
&lt;p>System.out.println(y);&lt;/p>
&lt;p>};&lt;/p>
&lt;p>4、() -&amp;gt; 12;&lt;/p>
&lt;p>5、()-{};&lt;/p>
&lt;p>6、()-&amp;gt;“hello” 或者 ()-&amp;gt;{return &amp;ldquo;hello&amp;rdquo;}&lt;/p>
&lt;h2 id="三语法总结">三、语法总结&lt;/h2>
&lt;p>语法一、（参数列表） -&amp;gt; 表达式&lt;/p>
&lt;p>语法二、（参数列表） -&amp;gt; {语句;}&lt;/p></description></item><item><title>JDK1.8的新特性</title><link>https://willxwu.github.io/post/java8/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</guid><description>&lt;h1 id="jdk18的新特性">JDK1.8的新特性&lt;/h1>
&lt;h1 id="一接口的默认方法">一、接口的默认方法&lt;/h1>
&lt;p>Java8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：&lt;/p>
&lt;p>代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Formula&lt;/span>&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">sqrt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sqrt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。
代码如下：
Formula formula=new Formula）{@Override public double calculate（int a）{return sqrt（a&lt;em>100）；}]；formula.calculate（100）；/100.0 formula.sqrt（16）；//4.0&lt;/em>&lt;/p></description></item></channel></rss>