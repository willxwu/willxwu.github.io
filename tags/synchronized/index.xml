<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>synchronized on 朱言蹊</title><link>https://www.yanxizhu.com/tags/synchronized/</link><description>Recent content in synchronized on 朱言蹊</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 08 Apr 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://www.yanxizhu.com/tags/synchronized/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA多线程</title><link>https://www.yanxizhu.com/posts/thread/</link><pubDate>Tue, 08 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.yanxizhu.com/posts/thread/</guid><description>进程：CPU为每个应用程序分配的独立空间，一个进程可能有多个线程。进程为线程中的摸个执行任务程序，多个进程之间可以进行共享数据。而JAVA的线程则是由JVM进程分配的，main方法所在线程，则成为主线程。
〇、线程状态 正常情况线程执行步骤：新建-》运行-》死亡
当CPU资源不够时，CUP分配给各个线程的资源可能不同(貌似有点像是线程在抢资源，实际是CPU分配资源给每个线程)。 因此就会出现线程的阻塞、休眠、等待3个状态。其中阻塞状态，当cpu资源够时，阻塞状态的线程可能恢复到运行状态，而休眠、等待的线程也可能进入运行状态。休眠、等待状态可能转换成阻塞状态，但是阻塞状态不会变成休眠、等待状态。
一、多线程的实现 0、线程常用方法 package learn.javase.threads; /** * 继承Thread创建线程，设置线程名称、获取线程名称 * @author Jole * */ public class ThreadDemo01 { public static void main(String[] args) { MyThreadsDemo mt = new MyThreadsDemo(); mt.setName(&amp;#34;Hi&amp;#34;); mt.start(); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName()); } } 线程实现方式主测试类：
package learn.javase.threads; public class MyThreadsDemo extends Thread{ public MyThreadsDemo() { super(&amp;#34;Google&amp;#34;); } public void run() { for(int i=0;i&amp;lt;5;i++) { try { Thread.sleep(1000); System.out.println(i); }catch(Exception e) { System.</description></item></channel></rss>