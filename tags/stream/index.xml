<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stream on Come Back</title><link>https://willxwu.github.io/tags/stream/</link><description>Recent content in Stream on Come Back</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright><lastBuildDate>Wed, 27 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://willxwu.github.io/tags/stream/index.xml" rel="self" type="application/rss+xml"/><item><title>JAVA8-Stream基本使用及特点</title><link>https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>Stream基本使用及特点 Stream说明 Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错。
1、可连续操作：
filter, map, and limit can be connected together to form a pipeline. 2、操作中断
collect causes the pipeline to be executed and closes it. 使用范例： package com.example.study.java8.streams; import java.util.*; import java.util.stream.Stream; import static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; /** * Stream使用 * Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错 * You can see two groups of operations: * 1、可连续操作 *  filter, map, and limit can be connected together to form a pipeline. * 2、操作中断 *  collect causes the pipeline to be executed and closes it.</description></item><item><title>JAVA8-default、static</title><link>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/17_java8-default%E6%96%B9%E6%B3%95/</guid><description>JAVA8-default、static default方法 1.8之前出现的问题:开发了一个接口，后面实现该接口的实现类，都需要实现接口中定义的方法。1.8之后接口中使用default定义新增的方法后，其实现类可以不用实现该方法。
例如Collection接口中新增了对stream的操作方法：stream()
public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; { default Stream&amp;lt;E&amp;gt; stream() { return StreamSupport.stream(spliterator(), false); } } 其实现类就可以不用再实现stream()方法，这样对于版本兼容就比较好了。
static 定义的方法 可以通过接口直接调用该方法，例如：
public interface Function&amp;lt;T, R&amp;gt; { static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() { return t -&amp;gt; t; } } 注意：接口中有default定义的方法实现了，但并不是抽象类。
接口：可以被多个类实现。
抽象类：继承了一个抽象类，就不能再继承另一个抽象类，因为类是单继承。
实列 自己用default实现一个接口
package com.example.study.java8.method; /** * default使用 */ public class DefaultAction { public static void main(String[] args) { A a = ()-&amp;gt;10; System.out.println(a.size()); System.out.println(a.isEmpty()); } public interface A{ int size(); //判断容器是否为空 default boolean isEmpty(){ return size()==0; } } } 输出结果：</description></item><item><title>JAVA8 Stream parallel 并行执行</title><link>https://willxwu.github.io/post/java8/14_java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</link><pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate><guid>https://willxwu.github.io/post/java8/14_java8-stream-parallel-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</guid><description>Stream parallel 并行执行 范例：求1~100000000的和，执行10次，看时间效率。 代码 package com.example.study.java8.collector; import java.util.function.Function; import java.util.stream.LongStream; import java.util.stream.Stream; /** * Stream parallel并行执行 * 实列：求10次，1~100000000的和，看时间效率。 */ public class ParallelProcessing { public static void main(String[] args) { //获取电脑CPU核数 System.out.println(&amp;#34;当前电脑CPU核数= &amp;#34; + Runtime.getRuntime().availableProcessors()); System.out.println(&amp;#34;The best process time(normalAdd)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::normalAdd, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream1)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream1, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream2)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream2, 100_000_000) + &amp;#34; MS&amp;#34;); System.out.println(&amp;#34;The best process time(iterateStream3)=&amp;gt; &amp;#34; + measureSumPerformance(ParallelProcessing::iterateStream3, 100_000_000) + &amp;#34; MS&amp;#34;); System.</description></item></channel></rss>