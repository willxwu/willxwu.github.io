<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.119.0"><meta charset=utf-8><title>Hello World</title><link href=//cdn.jsdelivr.net rel=dns-prefetch><link href=//cdnjs.cloudflare.com rel=dns-prefetch><link href=//at.alicdn.com rel=dns-prefetch><link href=//fonts.googleapis.com rel=dns-prefetch><link href=//fonts.gstatic.com rel=dns-prefetch><link href=///disqus.com rel=dns-prefetch><link href=//c.disquscdn.com rel=dns-prefetch><link href=//www.google-analytics.com rel=dns-prefetch><meta name=author content="Come Back"><meta name=description content="Life is not so complicated, simple is better"><meta name=twitter:card content="summary"><meta name=twitter:site content="@twitter_username"><meta name=twitter:title content="Hello World"><meta name=twitter:description content="Life is not so complicated, simple is better"><meta name=twitter:image content="/images/avatar.png"><meta property="og:type" content="website"><meta property="og:title" content="Hello World"><meta property="og:description" content="Life is not so complicated, simple is better"><meta property="og:url" content="https://willxwu.github.io/"><meta property="og:image" content="/images/avatar.png"><link rel=canonical href=https://willxwu.github.io/><link rel=alternate type=application/rss+xml href=https://willxwu.github.io/index.xml title="Come Back"><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no,email=no,adress=no"><meta http-equiv=cache-control content="no-transform"><meta name=robots content="index,follow"><meta name=referrer content="origin-when-cross-origin"><meta name=theme-color content="#02b875"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=apple-mobile-web-app-title content="Come Back"><meta name=msapplication-tooltip content="Come Back"><meta name=msapplication-navbutton-color content="#02b875"><meta name=msapplication-TileColor content="#02b875"><meta name=msapplication-TileImage content="/icons/icon-144x144.png"><link rel=icon href=https://willxwu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://willxwu.github.io/icons/icon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://willxwu.github.io/icons/icon-32x32.png><link rel=icon sizes=192x192 href=https://willxwu.github.io/icons/icon-192x192.png><link rel=apple-touch-icon href=https://willxwu.github.io/icons/icon-152x152.png><link rel=manifest href=https://willxwu.github.io/manifest.json><link rel=preload href=https://willxwu.github.io/styles/main-rendered.min.css as=style><link rel=preload href="https://fonts.googleapis.com/css?family=Lobster" as=style><link rel=preload href=https://willxwu.github.io/images/avatar.png as=image><link rel=preload href=https://willxwu.github.io/images/grey-prism.svg as=image><style>body{background:#f4f3f1 url(/images/grey-prism.svg)repeat fixed}</style><link rel=stylesheet href=https://willxwu.github.io/styles/main-rendered.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lobster"><!--[if lte IE 8]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js></script><![endif]--><!--[if lte IE 9]><script src=https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js></script><![endif]--></head><body><div class=suspension><a role=button aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden=true></span></a></div><header class=site-header><a href=https://willxwu.github.io><img class=avatar src=https://willxwu.github.io/images/avatar.png alt=Avatar></a><h1 class=title><a href=https://willxwu.github.io>Come Back</a></h1><p class=subtitle>All kinds of taste, are life.</p><button class=menu-toggle type=button aria-label="Main Menu" aria-expanded=false tab-index=0>
<span class="icon icon-menu" aria-hidden=true></span></button><nav class="site-menu collapsed"><h2 class=offscreen>Main Menu</h2><ul class=menu-list><li class=menu-item><a href=https://willxwu.github.io/>Home</a></li><li class=menu-item><a href=https://willxwu.github.io/archives/>archives</a></li><li class=menu-item><a href=https://willxwu.github.io/tags/>Tags</a></li><li class=menu-item><a href=https://willxwu.github.io/links/>Links</a></li><li class=menu-item><a href=https://willxwu.github.io/resume/>resume</a></li><li class=menu-item><a href=https://willxwu.github.io/about/>About</a></li></ul></nav><nav class="social-menu collapsed"><h2 class=offscreen>Social Networks</h2><ul class=social-list><li class=social-item><a href=mailto:name@domain.com title=Email aria-label=Email><span class="icon icon-email" aria-hidden=true></span></a></li><li class=social-item><a href=//github.com/github_username rel=me title=GitHub aria-label=GitHub><span class="icon icon-github" aria-hidden=true></span></a></li><li class=social-item><a href=//twitter.com/twitter_username rel=me title=Twitter aria-label=Twitter><span class="icon icon-twitter" aria-hidden=true></span></a></li><li class=social-item><a href=//weibo.com/weibo_username rel=me title=Weibo aria-label=Weibo><span class="icon icon-weibo" aria-hidden=true></span></a></li><li class=social-item><a href=https://willxwu.github.io/images/qrcode.jpg rel=me title=Wechat aria-label=Wechat><span class="icon icon-wechat" aria-hidden=true></span></a></li><li class=social-item><a href=//www.linkedin.com/in/linkedin_username rel=me title=LinkedIn aria-label=LinkedIn><span class="icon icon-linkedin" aria-hidden=true></span></a></li></ul></nav></header><section class="main post-list"><header class="list-header offscreen"><h2 class=list-label>All Posts</h2></header><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/29_lambda%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/ class=post-link>JAVA8-Lambda方法推导详细解析</a></h3><p class=post-meta>@Come Back · Jul 29, 2022 · 2 min read</p></header><p class=post-summary>Lambda方法推导详细解析 什么情况下可以进行方法推导? 类的方法（静态方法）
对象的方法
构造方法
自定义函数式接口
范例： package com.example.study.java8.InterfaceFunction; import java.util.Arrays; import java.util.Comparator; import java.util.List; import java.util.function.BiFunction; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Supplier; /** * 方法推导 * 什么情况下可以进行方法推导： * 1、类的方法（静态方法） * 2、对象的方法 * 3、构造方法 */ public class MethodReferenceUsageDemoOne { public static void main(String[] args) { //方法推导，范例一：类的方法 //原始写法 Consumer&lt;String> consumer = s-> System.out.println(s); genericityConsumer(consumer, "hello"); //1、进化一 genericityConsumer(s->System.out.println(s), "world"); //2、进化二 genericityConsumer(System.out::println, "nice"); System.out.println("==========================="); //方法推导，范例二：类的方法 List&lt;Apple> list = Arrays.asList(new Apple("red", 10) , new Apple("red", 60) , new Apple("blue", 40) , new Apple("black", 30) , new Apple("green", 80) , new Apple("blue", 90) , new Apple("green", 60) , new Apple("green", 50) , new Apple("red", 20)); System.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/29_lambda%E6%96%B9%E6%B3%95%E6%8E%A8%E5%AF%BC%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/28_java8-%E8%87%AA%E5%AE%9A%E4%B9%89collector/ class=post-link>JAVA8-自定义Collector</a></h3><p class=post-meta>@Come Back · Jul 28, 2022 · 1 min read</p></header><p class=post-summary>自定义Collector 实现Collector接口 package com.example.study.java8.collector; import java.util.*; import java.util.function.BiConsumer; import java.util.function.BinaryOperator; import java.util.function.Function; import java.util.function.Supplier; import java.util.stream.Collector; /** * 自定义Collector * T:元素类型 * List&lt;T>:要创建的类型 * List&lt;T>:最后要返回的类型 */ public class ToListCollector&lt;T> implements Collector&lt;T, List&lt;T>, List&lt;T>> { private void log(final String log) { System.out.println(Thread.currentThread().getName()+"-"+log); } //一定时可变的supplier，不是固定值 @Override public Supplier&lt;List&lt;T>> supplier() { log("supplier"); return ArrayList::new; } //要进行的操作 @Override public BiConsumer&lt;List&lt;T>, T> accumulator() { log("accumulator"); return List::add; } //将结果整合 @Override public BinaryOperator&lt;List&lt;T>> combiner() { log("combiner"); return (list1,list2)->{ list1.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/28_java8-%E8%87%AA%E5%AE%9A%E4%B9%89collector/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/ class=post-link>JAVA8-Stream基本使用及特点</a></h3><p class=post-meta>@Come Back · Jul 27, 2022 · 41 min read</p></header><p class=post-summary>Stream基本使用及特点 Stream说明 Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错。
1、可连续操作：
filter, map, and limit can be connected together to form a pipeline. 2、操作中断
collect causes the pipeline to be executed and closes it. 使用范例： package com.example.study.java8.streams; import java.util.*; import java.util.stream.Stream; import static java.util.Comparator.comparing; import static java.util.stream.Collectors.toList; /** * Stream使用 * Stream操作分为：2组，//注意，流式管道操作，只能操作一次，否则报错 * You can see two groups of operations: * 1、可连续操作 *  filter, map, and limit can be connected together to form a pipeline. * 2、操作中断 *  collect causes the pipeline to be executed and closes it.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/27_java8-stream%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93stream%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/26_completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/ class=post-link>JAVA8-CompletableFuture基本用法</a></h3><p class=post-meta>@Come Back · Jul 26, 2022 · 1 min read</p></header><p class=post-summary>JAVA8-CompletableFuture基本用法 针对&lt;实现一个异步基于事件回调的Future程序> 用CompletableFuture进行改进。
代码示例：
package com.example.study.java8.completableFutures; import java.util.Optional; import java.util.Random; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; /** * CompletableFuture 基本用法 */ public class CompletableFutureInAction1 { private final static Random RANDOM = new Random(System.currentTimeMillis()); public static void main(String[] args) throws ExecutionException, InterruptedException { //实际开发中，一般不直接new，而是使用工厂创建 // CompletableFuture&lt;Void> voidCompletableFuture = CompletableFuture.runAsync(); CompletableFuture&lt;Double> completableFuture = new CompletableFuture&lt;>(); new Thread(()->{ double value = get(); completableFuture.complete(value); }).start(); //不会阻塞程序执行 System.out.println("===========no====block====.."); //1、后面获取程序执行结果 // Optional.ofNullable(completableFuture.get()).ifPresent(System.out::println); //2、执行完后，通过回调自动返回结果 completableFuture.whenComplete((v,t)->{ Optional.ofNullable(v).ifPresent(System.out::println); Optional.ofNullable(t).ifPresent(x->x.printStackTrace()); }); } private static double get(){ try { Thread.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/26_completablefuture%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/25_completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/ class=post-link>JAVA8-completableFuture 异步编排</a></h3><p class=post-meta>@Come Back · Jul 21, 2022 · 2 min read</p></header><p class=post-summary>通过线程池性能稳定，也可以获取执行结果，并捕获异常。但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。因此我们可以使用completableFuture 异步编排方案。
比如：一个业务场景，需要同时获取多个数据，如果同步线程挨个执行，则需要时间为所有线程执行时间的总和。
如果我们使用异步线程执行，所需时间则为耗时最长那个异步线程的执行时间。
如果多个异常线程之间还存在依赖关系，比如线程3需要线程1的执行结果，线程6依赖线程3、线程2，那这个问题怎么解决呢。那就可以使用completableFuture 异步编排方案实现。
注意：completableFuture 是jdk1.8之后添加的一个功能。
CompletableFuture接口:
public class CompletableFuture&lt;T> implements Future&lt;T>, CompletionStage&lt;T> { public interface Future&lt;V> { 以前用到的FutureTask就是用到的Future可以得到返回结果
public class FutureTask&lt;V> implements RunnableFuture&lt;V> { public interface RunnableFuture&lt;V> extends Runnable, Future&lt;V> { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } Future可以得到返回结果
CompletableFuture随便一个方法，都接受一个Function
public &lt;U> CompletableFuture&lt;U> applyToEither( CompletionStage&lt;? extends T> other, Function&lt;? super T, U> fn) { return orApplyStage(null, other, fn); } @FunctionalInterface public interface Function&lt;T, R> { Function是一个@FunctionalInterface，所以对Lambda使用要熟悉。</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/25_completablefuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/24_java8-date-api-localdate-localtime-instant-duration-period/ class=post-link>JAVA8-CompletableFuture LocalDate, LocalTime, Instant, Duration, Period</a></h3><p class=post-meta>@Come Back · Jul 20, 2022 · 4 min read</p></header><p class=post-summary>JAVA8-Date and Time API： LocalDate, LocalTime, Instant, Duration, Period 旧API问题 1、代码不清晰，一下看不出要转换的日期。
**2、Date日期中还包含了时间 **
3、多线程情况下会报错。
代码重现：
package com.example.study.java8.datetime; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateTest { public static void main(String[] args) throws ParseException { //122格林威治时间 11月 23日期 //问题：不能清晰表示日期 Date date = new Date(122, 11, 23); System.out.println(date); //多线程情况下会出现一些问题： //30个线程，每个线程下循环100次，执行时间格式转换。 SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd"); for (int i = 0; i &lt; 30; i++) { new Thread(() -> { for (int j = 0; j &lt; 100; j++) { Date parseDate = null; try { parseDate = sdf.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/24_java8-date-api-localdate-localtime-instant-duration-period/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/23_ava8-completablefuture%E5%B8%B8%E7%94%A8apirunafterbothapplytoeitheraccepteither-runaftereither-allofanyof/ class=post-link>JAVA8-CompletableFuturerunAfterBoth、applyToEither、acceptEither 、runAfterEither 、allOf、anyOf</a></h3><p class=post-meta>@Come Back · Jul 19, 2022 · 3 min read</p></header><p class=post-summary>AVA8-CompletableFuture常用API：runAfterBoth、applyToEither、acceptEither 、runAfterEither 、allOf、anyOf 1、runAfterBoth ：2个CompletableFuture都执行完后,再执行其它操作 package com.example.study.java8.completableFutures.api; import java.util.concurrent.CompletableFuture; public class CompletableFutureAction2 { public static void main(String[] args) throws InterruptedException { //API-- 1、runAfterBoth: 2个都执行完后,再执行其它操作 CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread().getName() + "this is runing 1......"); return 1; }) .runAfterBoth(CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread().getName() + "this is runing 2......"); return 2; }), () -> System.out.println("done")); //为了防止主线程结束后，守护线程被关闭，模拟修改10000毫秒 Thread.sleep(10000); } } 输出结果：
ForkJoinPool.commonPool-worker-5this is runing 2...... ForkJoinPool.commonPool-worker-19this is runing 1...... done 2、 applyToEither：其中一个CompletableFuture执行完，就将结果传给另一个Fuction package com.example.study.java8.completableFutures.api; import java.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/23_ava8-completablefuture%E5%B8%B8%E7%94%A8apirunafterbothapplytoeitheraccepteither-runaftereither-allofanyof/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/22_java8-completablefuture%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9Cjoin%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/ class=post-link>JAVA8-CompletableFuture流水线工作，join多个异步任务详解</a></h3><p class=post-meta>@Come Back · Jul 17, 2022 · 2 min read</p></header><p class=post-summary>JAVA8-CompletableFuture流水线工作，join多个异步任务详解 需求：根据商品id，将每个商品价格翻2倍？
代码示例 package com.example.study.java8.completableFutures; import java.util.Arrays; import java.util.List; import java.util.Random; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.stream.Stream; import static java.util.stream.Collectors.toList; /** * 根据商品id，将每个商品价格翻2倍。CompletableFuture高并发执行。 */ public class CompletableFutureInAction4 { private final static Random RANDOM = new Random(System.currentTimeMillis()); public static void main(String[] args) { //防止主线程执行完后，守护线程也关闭 ExecutorService executorService = Executors.newFixedThreadPool(2, r -> { Thread thread = new Thread(r); thread.setDaemon(false); return thread; }); //5个商品ID List&lt;Integer> productIDs = Arrays.asList(1, 2, 3, 4, 5); //通过CompletableFuture查询5个商品价格 Stream&lt;CompletableFuture&lt;Double>> completableFutureStream = productIDs.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/22_java8-completablefuture%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9Cjoin%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/21_java8-completablefuture%E5%B8%B8%E7%94%A8api/ class=post-link>JAVA8-CompletableFuture常用API API thenApply、handle、thenRun、thenAccept、thenCompose、thenCombine、thenAcceptBoth</a></h3><p class=post-meta>@Come Back · Jul 16, 2022 · 2 min read</p></header><p class=post-summary>JAVA8-CompletableFuture常用API：thenApply、handle、thenRun、thenAccept、thenCompose、thenCombine、thenAcceptBoth 1、thenApply package com.example.study.java8.completableFutures.api; import java.util.Optional; import java.util.concurrent.CompletableFuture; /** * CompletableFuture常用API: thenApply、handle */ public class CompletableFutureAtion1 { public static void main(String[] args) throws InterruptedException { //API-- 1、thenApply //模拟其它 异步 逻辑操作然后返回结果1 CompletableFuture.supplyAsync(() -> 1) .thenApply(i -> Integer.sum(i, 10)) //thenApply 将结果加10 .whenComplete((v, t) -> Optional.ofNullable(v).ifPresent(System.out::println)); //同步执行打印结果 // .whenCompleteAsync() //异步操作，可以将结果在进行其它逻辑异步操作 //whenComplete VS whenCompleteAsync //为了防止主线程结束后，守护线程被关闭，模拟修改10000毫秒 Thread.sleep(10000); } } 输出结果：
11 对比 whenComplete VS whenCompleteAsync：whenCompleteAsync异步操作，可以将结果在进行其它逻辑异步操作。
2、handle package com.example.study.java8.completableFutures.api; import java.util.Optional; import java.util.concurrent.CompletableFuture; /** * CompletableFuture常用API: thenApply、handle */ public class CompletableFutureAtion1 { public static void main(String[] args) throws InterruptedException { //API- 2、handle CompletableFuture.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/21_java8-completablefuture%E5%B8%B8%E7%94%A8api/>Read More →</a></footer></article><article class=post-entry><header class=post-header><h3 class=post-title><a href=https://willxwu.github.io/post/java8/20_java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/ class=post-link>JAVA8-实现一个异步基于事件回调的Future程序</a></h3><p class=post-meta>@Come Back · Jul 14, 2022 · 2 min read</p></header><p class=post-summary>JAVA8-实现一个异步基于事件回调的Future程序 前面2个例子（JAVA8-多线程Future设计模式原理,自定义实现一个Future程序、JAVA8-JDK自带Future,Callable,ExecutorService）+该例子，是为了学习CompletableFuture，理解其原理。
自定义Future程序代码示例：
package com.example.study.java8.funture; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference; /** * 实现一个异步基于事件回调的Future程序 */ public class FutureInAction3 { public static void main(String[] args) { Future&lt;String> future = invoke(() -> { try { Thread.sleep(10000L); return "I'm finished."; } catch (InterruptedException e) { return "I'm Error."; } }); //注册一个事件 future.setCompletable(new Completable&lt;String>() { @Override public void completable(String s) { System.out.println(s); } @Override public void excetion(Throwable cause) { System.out.println("Error"); cause.printStackTrace(); } }); //下面就可以执行其它逻辑了。。。 System.out.println("。。。。。。。。。"); System.out.println(future.get()); System.</p><footer class=post-footer><a class=read-more href=https://willxwu.github.io/post/java8/20_java8-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E7%9A%84future%E7%A8%8B%E5%BA%8F/>Read More →</a></footer></article><footer class=list-footer><nav class=pagination><h3 class=offscreen>Pagination</h3><a class=pagination-next href=https://willxwu.github.io/page/2/>Older Posts →</a></nav></footer></section><footer class=site-footer><p>© 2017-2023 Come Back</p><p>Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> with theme <a href=https://github.com/laozhu/hugo-nuo target=_blank rel=noopener>Nuo</a>.</p></footer><script src=https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js></script>
<script src=https://willxwu.github.io/scripts/index.min.js></script>
<script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js").then(function(){console.log("[ServiceWorker] Registered")})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-XXXXXXXX-X","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>